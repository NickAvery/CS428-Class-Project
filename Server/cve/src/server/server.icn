$include "../common/defaults.icn"
$include "posix.icn"

$ifdef THREADS
$include "threadh.icn"
$endif

link datetime
link datecomp

# global ici_groups # not clear that server uses this GUI-heavy object
global proj_tooltip_msg, session_tooltip_msg,
       uTDays, uTHours, currMode, npcs

record SocketDriver(socket,
                    user,    # Associated user object, or &null if none
                    type,    # "listen", "user", "admin", "agnt", or "npc"
                    pending_output, # string containing generated
                                    # output not yet sent across the
                                    # socket barrier.
                    pending_input   # unhandled input (typically from
                                    # incomplete lines).
                    )

#
# CVE Daemon Server Class: handles all network related communications
#
class Server(listen_UDP_sock,
             Tsocket_drivers, # socket to SocketDriver objects
             socket_list,
             Tuser_sock,      # user to socket mapping
	     Tsock_user,      # socket to user mapping
             Cmds,            # commands object reference
             Tname_group,     # name to group obj ref mapping
             port,            # port to use
             logHandler,      # Logger object
             dynStHandler,    # dynamic state stuff
             fileHandler,     # fileTransfer object
             commandHelper,   # provides help on commands
             Tide,            # Table of users in the IDEsession
             IDECounter,      # IDE session counter
             IDE_Checked_Counter,
             Addcounter,
             Lusers_to_send,
             agents,
	     Tusername_user,
	     local_npc_set
             )

   #
   # open_TCP_listener(): starts listening on a specific port for TCP requests
   #
   method open_TCP_listener()
      # open up network to listen for connections until server is shut down
      local listen_sock, driver

      listen_sock := open(":" || port, "nl")
      if /listen_sock then {
         logHandler.logit("open_TCP_listener(:" ||image(port) || "): starting _
			   server failed because " || sys_errstr(&errno))
	 shutdown()
	 }
      logHandler.logit("open_TCP_listener(): Virtual Environment Server ",
                       cve_version(), " started on port ", port)

      driver := SocketDriver(listen_sock, &null, "listen", "", "")
      Tsocket_drivers[listen_sock] := driver
      put(socket_list, listen_sock)
   end

   #
   # open_UDP_listener(): starts listening on a specific port for UDP requests
   #
   method open_UDP_listener()
      listen_UDP_sock := open(":"||fileHandler.xm_ports.getAvatarPort(),"nua")|
	  stop("Failed Opening UDP", sys_errstr(&errno))
      logHandler.logit("open_UDP_listener(): UDP Connection started on port "||
               fileHandler.xm_ports.getAvatarPort())
   end

   method get_all_availability_str(userID, ava_files)
      local f, d, h, myTDays := table(),
         myLDays, i, myTHours, l, ln, lday, lhrs,
         times, all_ava_str := "", newlst
 
         myLDays := ["Sat", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri"]

         every myTDays [!myLDays] := table(0)
 
         every d := key(myTDays) do {
            myTHours := table()
            every myTHours[1 to 24] := 0
            myTDays[d] := myTHours
            }

         if f := open(USER_GLOBALPATH||PS||userID||PS||"temp.log", "r") then {
            while l := read(f) do {
               l ? {
                  while not(pos(0)) do {
                     ln := tab(find("[]"))
                     move(2)
                     ln ? {
	                 lday := tab(find(" "))
	                 move(1)
	                 lhrs := tab(0)
	                 }

                     if \lday & \lhrs then {
                        if lday === ("Sat" | "Sun" | "Mon" | 
                           "Tue" | "Wed" | "Thu" | "Fri") then {
	                   lhrs ? {
	                      i := 1
                              while not(pos(0)) do {
		                 times := integer(tab(find(" ")))
		                 myTDays[lday][i] +:= times
		                 move(1)
		                 i +:= 1
		                 }
	                      }
                           }
                        }
                     }
                  }
               }
            close(f) 
            }
      
         if f := open(USER_GLOBALPATH||PS||userID||
                   PS||"allavaTbl.log", "w") then {
            every d := key(myTDays) do {
               writes(f, d||" ")
               every h := 1 to 24 do {
                  if ava_files > 0 then
                     writes(f, ((myTDays[d])[h])/ava_files||" ")
                  else writes(f, "0 ")
	          }
               write(f)
               }
            close(f)
            }

         newlst := table()
         if f := open(USER_GLOBALPATH||PS||userID||
                      PS||"allavaTbl.log", "r") then {
            while l := read(f) do {
               l ? {
                  d := tab(find(" "))
                  move(1)
                  }
               newlst[d] := l
               }
            close(f)
            }
         all_ava_str := ""
         every all_ava_str ||:=
	     newlst["Sun"|"Mon"|"Tue"|"Wed"|"Thu"|"Fri"|"Sat"]||"&&"
      return all_ava_str
   end

   method getUserAFKInfo(userID, flag)
      local afkTDays, afk_rec, d, l, f, afk_str := "",
         aday, astr, afk_time


      afkTDays := table(0)
      every d := ("Sunday"|"Monday"|"Tuesday"|"Wednesday"|
                  "Thursday"|"Friday"|"Saturday") do
         afkTDays[d] := 0

      if f := open(USER_GLOBALPATH||PS||userID||
         PS||"afk_activity.log", "r") then {
         while afk_rec := read(f) do {
            if afk_rec ~== "" then {
               afk_rec ? {
                  aday := tab(find(" "))
                  move(1)
                  astr := tab(find("("))
                  move(1)
                  afk_time := integer(tab(find(")")))
                  move(1)
                  }
               afkTDays[aday] +:= afk_time
               }
            }
         close(f)
         }

      if f := open(USER_GLOBALPATH||PS||userID||
                   PS||"currWeek_afk_summary.log", "w") then {
         every d := ("Sunday"|"Monday"|"Tuesday "|
            "Wednesday"|"Thursday"|"Friday"|"Saturday") do {
             if \afkTDays[d] then
                afkTDays[d] := round(afkTDays[d])
             else
                afkTDays[d] := 0
             write(f,  d||" "||(afkTDays[d]/60))
             }
         close(f)
         }

      if f := open(USER_GLOBALPATH||PS||userID||
                   PS||"currWeek_afk_summary.log", "r") then {
         while l := read(f) do {
            afk_str ||:= l || "&&"
            }
         close(f)
         }
      if flag = 0 then {
         if f := open(USER_GLOBALPATH||PS||userID||
                      PS||"afk_summary.log", "a") then {
            write(f, &dateline)
            write(f, " ")
            every d := ("Sunday"|"Monday"|"Tuesday "|
               "Wednesday"|"Thursday"|"Friday"|"Saturday") do
               write(f,  d||" "||afkTDays[d])
            write(f, "--------------------------------------")
            close(f)
            }

         if f := open(USER_GLOBALPATH||PS||userID||
                      PS||"currWeek_afk_summary.log", "w") then {
            every d := ("Sunday"|"Monday"|"Tuesday "|
               "Wednesday"|"Thursday"|"Friday"|"Saturday") do
               write(f,  d||" 0")
            close(f)
            }
         if f := open(USER_GLOBALPATH||PS||userID||
                      PS||"afk_activity.log", "w") then {
            close(f)
            }
         }

      return afk_str
   end

   method usersAvailability()
      local login_time, login_date, login_hr, login_mnt,
         login_sec, login_day, f, d, h, myTDays := table(),
         myLDays, i, myTHours, logins_str, l, lday, lhrs,
         times, newlst


      myLDays := ["Sat", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri"]

      every myTDays[!myLDays] := table()

      every d := key(myTDays) do {
         myTHours := table()
         every myTHours[1 to 24] := 0
         myTDays[d] := myTHours
         }

      logins_str := ""
      if f := open("dat"||PS|| "availability.log", "r") then {
	 while l := read(f) do {
	    logins_str ||:= l || "&&"
	    }
         close(f)
         }

      logins_str ? {
	 while not(pos(0)) do {
	    l := tab(find("&&"))
	    move(2)
	    l ? {
	       lday := tab(find(" "))
	       move(1)
	       lhrs := tab(0)
	       }
            if \lday & \lhrs then {
            if lday === ("Sat"|"Sun"|"Mon"|"Tue"|"Wed"|"Thu"|"Fri") then {
	    lhrs ? {
	       i := 1
	       while not(pos(0)) do {
		  times := integer(tab(find(" ")))
		  myTDays[lday][i] := times
		  move(1)
		  i +:= 1
		  }
	       }
               }
               }
	    }
	 }

      login_date := &dateline
      login_time := &clock

      login_time ? {
         login_hr  := integer(tab(find(":")))
         move(1)
         login_mnt := integer(tab(find(":")))
         move(1)
         login_sec := integer(tab(0))
         }
      login_date ? {
         login_day  := tab(find(","))
         }

      if login_hr = 0 then
         login_hr := 24

      login_day := login_day[1:4]
      (myTDays[login_day])[login_hr] +:= 1

      if f := open("dat"||PS||"availability.log", "w") then {
         every d := key(myTDays) do {
            writes(f, d, " ")
	    every writes(f, myTDays[d][1 to 24], " ")
            write(f)
            }
         close(f)
         }

      newlst := table()
      if f := open("dat"||PS||"availability.log", "r") then {
         while l := read(f) do {
            l ? {
               d := tab(find(" "))
               move(1)  
               }
            newlst[d] := l
            }
         close(f)
         }
  
      if f := open("dat"||PS||"availability.log", "w") then {
         every write(f,  newlst["Sun"|"Mon"|"Tue"|"Wed"|"Thu"|"Fri"|"Sat"])
         close(f)
         }     
   end

   method write_msg(con, msg)
   end

   method login(driver)
      local parsed, params, user_id, password
      local buffer, x, new_user, q, user_type
      local savedPosition, u, uLDays, i, d

      local temp1, message     # Used for VoIP initialization
      local currNodeName, fd

      local avatar   # To deal with agent avatars
      local pinv, isdisabled

$ifdef THREADS
      buffer := <<@driver.socket | {
         if type(driver.socket)=="file" then close(driver.socket)
         fail
      }

      #see if command is valid and a login request
      if not (parsed := Cmds.LoginCommand(buffer)) then {
         logHandler.logit("Connection failed to login, sending command " ||
                          image(buffer))
         "Failed"@>>driver.socket   # NAK
          "\\say Connection Not Made, invalid command"@>>driver.socket
         if type(driver.socket)=="file" then close(driver.socket)
         fail
      }
      params := Cmds.SplitArgs(parsed[2], "split on space only")

      # make sure there is a username and password to process
      if /params | (*params < 2) then {
         logHandler.logit("login(): "||
                          "login with not enough parameters.")
         "Failed" @>> driver.socket
         if type(driver.socket)=="file" then close(driver.socket)
         fail
      }
$else
      buffer := read(driver.socket) | {
         if type(driver.socket)=="file" then close(driver.socket)
         fail
      }

      #see if command is valid and a login request
      if not (parsed := Cmds.LoginCommand(buffer)) then {
         logHandler.logit("Connection failed to login, sending command " ||
                          image(buffer))
         write(driver.socket, "Failed")   # NAK
         write(driver.socket, "\\say Connection Not Made, invalid command")
         if type(driver.socket)=="file" then close(driver.socket)
         fail
      }
      params := Cmds.SplitArgs(parsed[2], "split on space only")

      # make sure there is a username and password to process
      if /params | (*params < 2) then {
         logHandler.logit("login(): login with not enough parameters.")
         write(driver.socket,"Failed")
         if type(driver.socket)=="file" then close(driver.socket)
         fail
      }

$endif

      # login command seems valid so grab some info from it
      params[1] ? {
        if  = "-cvecypher" then {
           user_id := decypher(tab(0))
           password := decypher(params[2])
         }
        else {
           user_id := params[1]
           password := params[2]
           }
        }

      del_ide_invitations(user_id)

      if not (user_type := authenticate(user_id,password,driver.socket)) then {
         logHandler.logit("login(): Authentication failure for user " ||
                          image(user_id))

$ifdef THREADS
         "Failed"@>>driver.socket
         "Authentication Failed."@>>driver.socket
$else
         write(driver.socket, "Failed")
         write(driver.socket, "Authentication Failed.")
$endif
         if type(driver.socket)=="file" then close(driver.socket)
         fail
      }

      #
      # Handle duplicate logins. Since the new one is a valid login, logout the
      # old session.  Don't do this, however, to user "system".
      #
      if (user_id ~=== "system") & (x := getUser(user_id)) then {
         sendtoOne(user_id, "You are logging in on another machine!",
                   "inform", user_id)
$ifdef THREADS
          Tsocket_drivers[Tuser_sock[x]].pending_output @> Tuser_sock[x]
$else
          write(Tuser_sock[x], Tsocket_drivers[Tuser_sock[x]].pending_output)
$endif
         removeUser(Tuser_sock[x], "noconfirm")
      }

      logHandler.logit("run(): Successful Authentication of " ||
                       user_id || " from IP " || getIP(driver.socket))

      if user_id == "system" then {

$ifdef THREADS
         "Valid" @>> driver.socket
$else
         write(driver.socket, "Valid")
$endif
         addUser(driver, "system")
         driver.type := "admin"
         }
      else {
         if params[3] then
            driver.type := "npc"
         else {
            driver.type := \user_type | "user"
$ifdef AAA 
            usersAvailability()
            if not stat(USER_GLOBALPATH||PS||user_id||PS||"stats.log") then {
	       if fd := open(USER_GLOBALPATH||PS||user_id||PS||
                  "stats.log","w") then {
		  write(fd,
			"Project/Add 0\nProject/Access 0\n_
			 Project/Delete 0\nProject/Join 0\n_
			 Group/Add 0\nGroup/Delete 0\nGroup/Join 0\n_
			 Friend/Add 0\n_
			 Profile/View 0\nProfile/Update 0\n_
			 Session/Edit 0\nSession/Debug 0\n_
			 File/Compile 0\nFile/Open 0\nFile/Run 0\n_
			 Feed/Add 0\nFeed/Delete 0\nFeed/View 0")
		  close(fd)
		  }
             }


             if not stat("dat"||PS||"partner_stats.log") then {
	        if fd := open("dat"||PS||"partner_stats.log", "w") then {
	     	  write(fd, "P:Project Partner ~ G:Group Partner ~ E:Expert")
	     	  close(fd)
                   }
                }

             if not stat(USER_GLOBALPATH||PS||user_id||PS||"avaTable.log") then {
                if fd := open(USER_GLOBALPATH||PS||user_id||PS||
	     		     "avaTable.log", "w") then {
                    every d := ("Sun"|"Mon"|"Tue"|"Wed"|"Thu"|"Fri"|"Sat") do {
                       writes(fd, d||" ")
                       every i := 1 to 24 do
                          writes(fd, 0||" ")
                       write(fd)
                       }
                   close(fd)
                   }
                }
$endif
           }

         addUser(driver, user_id)

         # Tell the user user they logged in OK. Tell everyone
         # else about the new user. Tell everyone how many
         # users are online.
         isdisabled := 0 # chat is enabled when 0
$ifdef THREADS
         "Valid" @>> driver.socket
$else
         write(driver.socket, "Valid")
$endif
         sendtoOne(driver.user.name, "Login Completed.",
		   "inform", driver.user.name)
         sendtoMany(driver.socket, "User " || driver.user.name ||
                    " has logged in. ", "inform", 1)
         sendtoMany(driver.socket, "There are " || *Tuser_sock ||
                    " user(s) online.", "inform", 0)
         sendtoMany( driver.socket,driver.user.name, "Addusers", 1)
         sendtoOne(driver.user.name, driver.user.name||" "||isdisabled,
		   "Whoami", driver.user.name)
         sendtoMany(driver.socket,driver.user.name, "c", 1)

         #
	 # New IP strategy:
         # get the real IP from the machine itself using ifconfig/ipconfig and
         # store it in user.IP field; this will solve the undef problem forever
	 #
         sendtoOne(driver.user.name, " ", "vgetip", driver.user.name)
         sendtoOne(driver.user.name, DAT, "dat", driver.user.name)

         #
         # Create the new user's avatar on everyone's client
         #
         savedPosition := dynStHandler.loadAvatarState(driver.socket,
						       driver.user)

         if savedPosition[4] < 1.5 then
            savedPosition[4] := 1.5

         message := " " || user_id || " " ||
             savedPosition[1] || " " || savedPosition[2] || " " ||
             savedPosition[3] || " " || savedPosition[4] || " " || driver.type


         # need to calculate who should receive the avatar creation message
         # based on room proximity, similar to how move messages are sent;
         # use getRecipientUsers and sentToSelected

         sendtoMany( driver.socket, message, "avatar", 0)

	 #
	 # Tell the user about his active quests
	 #
	 new_user := Tusername_user[driver.user.name]
	 every q := !(new_user.active_quests_table) do {
	    message := "\\npcmsg " ||
	       (if \q.npc_name then ( q.npc_name||":") else "") ||
	       "Quest Title("|| q.title || ") URL Active " || q.url
	    driver.pending_output ||:= message || "\n"
	    }

	 #
	 # Tell the user about his pending invitations/requests
	 #
	 every pinv := !(new_user.pending_inv_table) do {
	    message := "\\ADDPending " || pinv.pid || ", " || pinv.uname ||
	    	       ", " || pinv.psubject || ", " || pinv.ppriority ||
	    	       ", " || pinv.pdate || ", " || pinv.pcomment
	    driver.pending_output ||:= message || "\n"
	    }

         #
         # Tell the user about his friends' locations
         #
$ifdef AAA
          if \(message := get_my_friendsLocations(driver.user.name)) then {
             message:= "FRIENDLOCATION " || message
  	     sendtoOne(driver.user.name, message,
	     "inform", driver.user.name)
             }
$endif
	 
         #
	 # Tell the user about all registered users
	 #
	 if \(message := all_users(driver.user.name)) then {
	     sendtoOne(driver.user.name, message, "allusers", driver.user.name)
	    }

$ifdef AAA
         #
         # Tell the user about all newsfeeds
         #
	 if \(message := get_all_newsfeeds(user_id)) then {
	    message:= "NEWSFEED " || message
	    sendtoMany(driver.user.name, message, "inform", 1)
            }
         #
         # Tell the user about all groups and their members
         #
	 if \(message := get_all_groups_and_members()) then {
	    message:= "GROUPS " || message
	    sendtoMany(driver.user.name, message, "inform", 1)
            }
         #
         # Tell the user about projects and project files
         #
	 if \(message := get_all_projects()) then {
	    message:= "PROJECTS " || message
	    sendtoMany(driver.user.name, message, "inform", 1)
            }
         #
         # Tell the user about his own projects list
         #
         if \(message := get_my_projects(driver.user.name)) then {
            message:= "MYPROJECTS " || message
	    sendtoOne(driver.user.name, message, "inform", driver.user.name)
            }
         #
         # Tell the user about his block list
         #
         if \(message := get_my_blocklist(driver.user.name)) then {
            message:= "MYBLOCKLIST " || message
	    sendtoOne(driver.user.name, message, "inform", driver.user.name)
            }

$endif
         #
         # Create everyone else's avatar on new user's client
         #
         every u := key(Tuser_sock) do {
            if u.name == user_id then next

            savedPosition := u.getPosition()
            message := u.name || " " || savedPosition[1] ||
	       " " || savedPosition[2] || " " || savedPosition[3] ||
	       " " || savedPosition[4] || " " || u.user_type

            sendtoOne(driver.user.name, message, "avatar", u.name)
         }

         # Now, to handle the agents' avatars.
         every avatar := !agents.avatars do {
            # TODO: We need to send an avatar command for each agent avatar
	    }

         #
         # DYNAMIC STATE HANDLING CODE
         #
         # this logic that handles problematic avatar position
         # in a edge will be removed later. We need logic that
         # will determine the intermmediate position and place
         # the avatar in either of the edges
         #
         # Send the dynamic data to the user. We know his
         # previous saved node already
         #
         currNodeName := dynStHandler.getAvatarNodeInfo(user_id,
                        savedPosition[1], savedPosition[3], savedPosition[2])


         #
         # If the client is in a valid node
         #
         if \currNodeName then {
            # save the temporary position in the user object to the Scene Graph
            dynStHandler.saveSafeAvtState(savedPosition,driver.user,
					  &null,driver.socket)

            dynStHandler.srvSceneGraph.updateAvatarState(
                          user_id, savedPosition[1], savedPosition[2],
                          savedPosition[3], savedPosition[4], savedPosition[5],
                          dynStHandler.TonlineUsers, MAX_MOVES)

            message := dynStHandler.getAdjDynamicState(Cmds,
                          map(currNodeName," -","__")||" "||
                          map(currNodeName," -","__") || " " ||
			  savedPosition[1] || " " || savedPosition[3] || " " ||
			  (savedPosition[1]+cos(savedPosition[4])) || " " ||
			  (savedPosition[3]+sin(savedPosition[4])),
			  driver.socket,driver.user)

            # We need to notify all actors in the current
            # node that the new user has arrived
            dynStHandler.srvSceneGraph.notify_actors_of_arrival(currNodeName,
								user_id)
         }
         else {
            #
            # If the client is passing through a exit, his
            # current node is not valid
            #
            message := "NOUPDATE"
            logHandler.logit("State not consistent at the moment.")
            }
        sendtoOne(driver.user.name,message,"dynstate",driver.user.name)
        }

$ifdef AAA
       if not stat("dat"||PS||"current_mode.log") then {
          if fd := open("dat"||PS|| "current_mode.log", "w") then
             close(fd)
          }

       every (usr := !Tusername_user).name ~== user_id do
          if (usr.get_activity_status()) ~== "Offline" then
              sendtoOne(usr.name, all_users(usr.name), "allusers", usr.name)
$endif

      return
   end

   #
   # run(): the main loop to service client requests
   #
   method run()
      local i, sock, L, L2
      local buffer,buffer2
      local driver
      local listen_sock
      local backup_time, curr_time, curr_day, curr_mnthday,
         currDayTime, userID, f, bhr, bmn, bsc,
         chr, cmn, csc, backup_day, currHour, 
         checktime := 0, npc_thread, timeout:=1000

      (\agents).startup()

      backup_time := "Saturday 00:00"
      backup_time ? {
            backup_day := tab(find(" ")) #current day
            move(1)
            bhr := tab(find(":")) #current hour
            move(1)
            bmn := tab(find(":")|0) #current min
            }

      repeat {

         checktime +:= 1
         if checktime%50=0 & find(backup_day, &dateline) then{
            checktime := 0
            curr_time := &dateline

            curr_time ? {
               curr_day := tab(find(", ")) #current day
               move(2)
               curr_mnthday := tab(find(", ")) #current day
               move(2)
               }
            currHour := &clock
            currDayTime := curr_day||" "||currHour
            currHour ? {
               chr := tab(find(":"))
               move(1)
               cmn := tab(find(":"))
               move(1)
               csc := tab(0)
               }

            if find(curr_day, backup_time) & chr === bhr & cmn === bmn &
                  csc <= 5 then {
                  every userID :=("."~==(".."~==(".SVN"~==(".svn"~==(
                      ==(!open(USER_GLOBALPATH))))))) do {
                     getUserAvailability(userID, 0)

                     #  The following two function's calls generate
                     # a weekly usage report for each user
                     # Day IDE-min 3D-min  AFK-min

                     getUserAFKInfo(userID, 0)
                     getUserUsage(userID, 0)
                     }
                  }
             }


$ifdef THREADS
         while npc_thread := <@ do{
            timeout := 0
            driver := SocketDriver(npc_thread, &null, "npc", "", "")
            Tsocket_drivers[npc_thread] := driver
            insert(local_npc_set, npc_thread)
            if not login(driver) then {
                     # If they can't log in, stop listening to them.
                     # login() would have closed the socket already
                     delete(Tsocket_drivers, npc_thread)
                     delete(local_npc_set, npc_thread)
                     }
                  }
               }
$endif

         L2:=[]
         every npc_thread:=!local_npc_set do
            if *npc_thread>0 then {
               put(L2, npc_thread)
               timeout := 0
               }

         L := select( socket_list, SERVER_TIMEOUT*timeout)

         if *L=*L2=0 & timeout < 250 then timeout +:=1


         every sock := (!L | !L2) do {
            driver := Tsocket_drivers[sock]

            if /driver then {   # this should not happen
                                # What is the best way to handle this?
               write("Driver is null; do not know socket ", image(sock))
               next  # fail?
            }

            case driver.type of {
               "listen": {

                  if not login(driver) then {
                     # If they can't log in, stop listening to them.
                     # login() would have closed the socket already
                     delete(Tsocket_drivers, sock)
                     every i := 1 to *socket_list do {
                        if socket_list[i] === sock then {
                            delete(socket_list, i)
                            break
                         }
                     }
                  }
                  # create a net listener socket to replace the last one
                  # note that the last one gets connected to a user in the
                  # lower level code regardless of whether the login works,
                  # and is thus not usable for listening for any new users.
                  # This is a feature of the unicon networking design, and
                  # probably a good one.

                  if listen_sock := open(":" || port, "nl") then {
                     driver := SocketDriver(listen_sock, &null, "listen",
                                            "", "")
                     Tsocket_drivers[listen_sock] := driver
                     put(socket_list, listen_sock)
                  } else {
                     logHandler.logit("can't open a new listener!")
                     # need to do more here
                  }
               }

	       # Read from connected, logged-in Users
	       "admin" | "user" | "npc" : {
                  if not (Tsocket_drivers[sock].pending_input) then {
		      write(&errout, "what the heck Tsock_d fails on ", image(sock))
		  }

                  if buffer2 := Tsocket_drivers[sock].pending_input ||
$ifdef THREADS
                      <@sock then {
$else
                      ready(sock) then {
$endif
                     Tsocket_drivers[sock].pending_input := ""
                     buffer2 ? {
                        while buffer := tab(find("\n")) do {
                           ExecuteCommand( Tsocket_drivers[sock].user.name,
                                          buffer )
                           move(1)
                        }
                        if *(buffer := tab(0)) > 0 then {
                           Tsocket_drivers[sock].pending_input ||:= buffer
                        }
                     }
                  } else {
                     write("Failure in reading input from socket ",
                           image(sock), "; removing user immediately")
		     write("removed user is ", Tsocket_drivers[sock].user.name)
                     removeUser( sock, "noconfirm" )
                  }
               }

               default: {
                  write("unknown driver.type ", image(driver.type))
               }
               # end default
            } # end case
         } # end every sock := !L

         every driver := !Tsocket_drivers do {
            if *(\ driver.pending_output) > 0 then {
$ifdef THREADS
                driver.pending_output @> driver.socket
$else
                write( driver.socket, driver.pending_output)
$endif
                driver.pending_output := ""
             }
         }

         dynStHandler.srvSceneGraph.services.handle_pending()
         (\agents).pulse()
      } # end repeat
   end

   ####
   #
   # Network protocol command handlers, called by ExecuteCommand().
   #
   # All handlers receive four parameters: user is a User, sock is a network
   # connection, cmd is the command name, rest is a list of parameters.
   #
   ###

   #
   # Implementation for "agents" command.  See preceding comment about
   # network protocol command handlers called by ExecuteCommand().
   #
   method do_agents(user, sock, cmd, rest)
   local username := user.name, room, actor

      sendtoOne(username, "Listing all agents", "say", username)
      every room := !dynStHandler.srvSceneGraph.nodesTable do {
	 every actor := !room.actors do {
	    if \ (actor.public) then {
	       sendtoOne(sock, image(actor), "say", sock)
	       }
	    }
        }
   end

   #
   # Implementation for "tellagent" command.  See preceding comment about
   # network protocol command handlers called by ExecuteCommand().
   #
   method do_tellagent(user, sock, cmd, rest)
   local room, actor
      every room := !dynStHandler.srvSceneGraph.nodesTable do {
	 every actor := !room.actors do {
	    if actor.name === rest then {
	       # sendtoOne(sock, image(actor), "say", sock)
	       write("found the agent")
	       }
	    }
	 }
      write("User " || image(sock) || " is trying to tell an agent something")
   end

   #
   # Implementation for "move" command.
   #
   method do_move(user, sock, cmd, rest)
   local TrecpUser_sock := table()
      #
      # save the temporary position in the user object in
      # <Tsock_user> list and to the Scene Graph
      #
      dynStHandler.saveAvatarState(Cmds, sock, user, rest)
      dynStHandler.getRecipientUsers(Cmds, user, Tuser_sock, TrecpUser_sock,
                                     "AvtMove", rest)
      sendtoSelected(sock, TrecpUser_sock, rest, "move", 1)
      return
   end

   #
   # Implementation for "addFriendAccept" command.
   #
   method do_addFriendAccept(user, sock, cmd, rest)
   local f, usr, usr1, usr2, frnds_set2, userID, newfriend, params
      params := Cmds.SplitArgs(rest)
      newfriend := params[2]
      userID  := params[3]
      if /(usr1 := Tusername_user[userID]) then { ## should handle this
	 fail
	 }
      if /(usr2 := Tusername_user[userID]) then { ## should handle this
	 fail
	 }
      insert(usr1.friends, newfriend)
      insert(usr2.friends, userID)

      if f := open(USER_GLOBALPATH||PS||userID||PS||"friends.log", "w")
      then {
	 every write(f, usr1.friends)
	 close(f)
	 }

      frnds_set2 := set()
      if f := open(USER_GLOBALPATH||PS||newfriend||PS||"friends.log", "r")
      then {
	 while insert(frnds_set2, read(f))
	 insert(frnds_set2, userID)
	 close(f)
	 }

      if f := open(USER_GLOBALPATH||PS||newfriend||PS|| "friends.log", "w")
      then {
	 every write(f, usr2.friends,)
	 close(f)
	 }

      update_notification_record("Friend/Add", userID, newfriend)
      update_stats("Friend/Add")
      update_user_stats("Friend/Add", userID)
      if \isPartner (newfriend, userID, "project") then
	 update_partner_stats("Friend", "P", "Add")
      if \isPartner (newfriend, userID, "sig") then
	 update_partner_stats("Friend", "G", "Add")

      every usr := !Tusername_user do
	 if (usr.get_activity_status()) ~== "Offline" then
	    sendtoOne(usr.name, all_users(usr.name), "allusers", usr.name)
   end

   #
   # implementation of movedoor command.
   # 
   method do_movedoor(user, sock, cmd, rest)
   local TrecpUser_sock
      TrecpUser_sock := table()
      dynStHandler.saveDoorState(Cmds,rest)
      # Obtain the avatars to send the door motion to.....
      dynStHandler.getRecipientUsers(Cmds, Tsock_user[sock], Tuser_sock,
				     TrecpUser_sock, "EdgeMove", rest)
      sendtoSelected(sock, TrecpUser_sock, rest, "doorMotion", 1)
   end
   method do_logwatch(user, sock, cmd, rest)
      logHandler.subscribe( sock, getIP(sock) )
   end
   method do_avatar(user, sock, cmd, rest)
      sendtoMany( sock, rest, "avatar", 1 )
   end
   method do_moveavatar(user, sock, cmd, rest)
      moveAvatar(sock, rest)
   end
   method do_say(user, sock, cmd, rest)
      sendtoMany(sock, rest, cmd, 1)
   end
   method do_users(user, sock, cmd, rest)
      sendtoOne(user.name, who_is_up(), "users", user.name)
   end
   method do_latency(user, sock, cmd, rest)
      sendtoOne(user.name, string(&clock) , "latency", user.name)
   end
   method do_allusers(user, sock, cmd, rest)
      sendtoOne(user.name, all_users(user.name), "allusers", user.name)
   end

   #
   # do_WEBopen was Url_Send: Invite user to (web) browsing session
   #
   method do_WEBopen(user, sock, cmd, rest)
      local recipient, params, rec_obj,client ,sock_to,url

      params := Cmds.SplitArgs(rest)
      recipient := params[1]
      url := params[2] || ":" || params[3]

      if /recipient then {
	 sendtoOne(sock, "No recipient provided. Usage: "||
                   "\\tell user message", "say", sock)
	 fail
	 }

      if rec_obj := getUser(recipient) then {
	 client := Tsocket_drivers[sock].user.name
	 sock_to := Tuser_sock[rec_obj]
	 sendtoOne(sock_to, client ||" "||url , "WEBopen", sock)
	 return
	 }
      sendtoOne(sock, "no such user is online: " || recipient, "say", sock)
   end

   method do_query(user, sock, cmd, rest)
      local params, msg, r
      params := Cmds.SplitArgs(\rest)
      
      if params[1] == "Room" then { # someday we might query about other stuff
         msg := "Room "
         if r := dynStHandler.srvSceneGraph.getRoomByName(params[2]) then
            msg ||:= r.name || " " || r.str_xyzlwh()
         else
            msg ||:= params[2] || " @Error don't know the room " || params[2]
         sendtoOne(user.name, msg, "query", user.name)
      }
   end


   #
   # ExecuteCommand(): validate command and service it
   #
   method ExecuteCommand( username, buffer )
      static Tcmds
      local UserCmd, parsed, message, params, TrecpUser_sock := table()
      local userToLoad,  avtName, oldNodeName, newNodeName
      local room, actor, x, sigName, sigOwner, userid
      local newfriend, hostuser, u, o_m, dot, addPostId

      local user := getUser(username)
      local sock := Tuser_sock[user]

      local breakPoint,
	     saveDatFileName, saveDatFileData, includeListDat, saveDatFile,
         fone, roomStats, tmpWord, tmpLetter, serverUpdateFile, listUpdateFiles,
         checkUpdate, tmpSplit, matched, checking, saveDatPath,
         readingData, fileData, tmpRoom, checkTime, checkFile

      local command, userID, pcontents, flag, f, line, feed_lbl, reply_lbl,
         feed_contents, fcontents, ln, fowner, usrid, rcontents, grphost,
         client, pinv, rec_obj, sock_to, permission, objType, profileName,
         new_member, userslst, log1, objName, objOwner, lst, removedUser,
         ustatus, Tusers, recipient, sender, msg, msgfrom, msgto, dt,
         profile_id, alluserinfo, allfriendslst, allprojectslst, myfriends_str,
         allgroupslst, allinterestslst, projName, profuserID, email, password,
         privacy, fout, privacy_settings, projects_privacy, groups_privacy,
         newsfeed_privacy, status_privacy, a_settings, p_settings, projOwner,
         pname, powner, pmembers, pfiles, pdate, fileName, ismember,
         project_access_time, file_access_time, fd, fbuffer, l, removedFile,
         currentlyworkingrecords, previouslychangedrecords, closedfileinfo,
         old_ver, allfilesstr, compare_file, with_file, diff_results_str,
         projhost, profName, mypartners_str,
         mpart_1, mpart_2, userID_1, userID_2, who_is_allowed, fcontents_lst,
         feed_name, flbl, blockedUser, line2, snode, i, action, usrWall,
         ownerColor, permissionType, fname, uId, faccess_time, time_spent,
         total_time_spent, user_time_tbl, max_time_spent, min_time_spent,
         most_active_member, stime, etime, actiontype, fn, pn, log2, ma_member,
         file_contents, experts_str, lang_name, uname, fName, lang_n,
         sessionName, colorfound, mc, memberColor, s_name, l_no, old_userID,
         commited_line_user_table, line_user_table, lineno, updatedlines_str,
         clines_file, line_user_str, memberID, deadline, ava_str,
         ppriority, new_user, userRequested, pdeadline, pprivacy,
         f_lbl, c, info_str, usrID, sType, roomName, event_type, usr,
         interactionType, blockedUsersLst, mfound, user_is_allowed, wall_str,
         room_coords, sigPath, projPath, objPath, projDesc, sigDesc, datpath,
         seconds_time, postName, p_permission, frnds_set, frnds_set2, 
         ava_files, newlst, all_avastr, d, fpath, user_mode_table,
         cmode,requestedUser, rmode, newfont, avaReport_str, cTime, to_user
         

      initial {
	 #
	 # Tcmds is a table mapping command names to [object,method] pairs.
	 # For those commands handled by this table, the method will be
	 # called as o.m(username, socket, cmd, argv)
	 #
	 Tcmds := table()
	 Tcmds["agents"] := [self, self.__m.do_agents]
	 Tcmds["tellagent"] := [self, self.__m.do_tellagent]
	 Tcmds["move"] := [self, self.__m.do_move]
	 Tcmds["addFriendAccept"] := [self, self.__m.do_addFriendAccept]
	 Tcmds["movedoor"] := [self, self.__m.do_movedoor]
	 Tcmds["logwatch"] := [self, self.__m.do_logwatch]
	 Tcmds["avatar"] := [self, self.__m.do_avatar]
	 Tcmds["moveavatar"] := [self, self.__m.do_moveavatar]
	 Tcmds["say"] := [self, self.__m.do_say]
	 Tcmds["users"] := [self, self.__m.do_users]
	 Tcmds["latency"] := [self, self.__m.do_latency]
	 Tcmds["allusers"] := [self, self.__m.do_allusers]
	 Tcmds["WEBopen"] := [self, self.__m.do_WEBopen]
	 Tcmds["query"] := [self, self.__m.do_query]
         }

      # A "temporary" table going from sock -> user objects. This is only
      # necessary while CVESceneGraph/ServerCVESceneGraph expect this table --
      # it looks like they really only want a list of the active users.
      #
      # A major question at this point is whether this table has to be
      # regenerated each call to ExecuteCommand as it historically was.
      Tsock_user  := table()
      every x := key(Tsocket_drivers) do {
         Tsock_user[x] := \ (Tsocket_drivers[x]).user
      }

      every parsed := Cmds.newParseCommand(buffer) do {
         UserCmd := parsed[1]
	 if o_m := \ (Tcmds[UserCmd]) then {
            # this looks like 5 parameters, but recall that #1 is "self"...
	    o_m[2](o_m[1], user, sock, UserCmd, parsed[2])
	    }
	 else
         case UserCmd of {
            "fire":{ # handle \fire command here
               write(&errout, "received \\fire command")
               }
            "createroom":{
               roomStats := []
               tmpWord := ""
               every tmpLetter := !parsed[2] do {
                  if tmpLetter == " " then {
                     put(roomStats, tmpWord)
                     tmpWord := ""
                  }
                  else tmpWord ||:= tmpLetter
               }
               put(roomStats, tmpWord)
               tmpRoom := Room(dynStHandler.srvSceneGraph.cveBuilder.opMode,
			       dynStHandler.srvSceneGraph.cveBuilder.world,
                               dynStHandler.srvSceneGraph.cveBuilder.dispatcher,
			       roomStats[1], roomStats[2], roomStats[3],
                               roomStats[4], roomStats[5], roomStats[6],
			       roomStats[7], roomStats[8])
               tmpRoom.make_default_left_wall(roomStats[8])
               tmpRoom.make_default_right_wall(roomStats[8])
               tmpRoom.make_default_front_wall(roomStats[8])
               tmpRoom.make_default_back_wall(roomStats[8])
               /tmpRoom.actors := []
               dynStHandler.srvSceneGraph.cveBuilder.sceneGraph.
                   putRoomInWorld(tmpRoom)
               dynStHandler.srvSceneGraph.cveBuilder.sceneGraph.
     		   nodesTable[roomStats[1]] := tmpRoom
               if log1 := open(PROJECT_GLOBALPATH||PS||
                  "rooms_info.log", "a") then {
                  write(log1, roomStats[1]," ",roomStats[2]," ",
                     roomStats[3]," ",roomStats[4]," ",roomStats[5]," ",
                     roomStats[6]," ",roomStats[7])
                  close(log1)
                  }

               sendtoMany(username, parsed[2], "createroom", 1)
            }
            "checkforupdates": {
               if not stat(DAT || PS || "ServerUpdate.tim") then {
                  if serverUpdateFile := open(DAT || PS || "ServerUpdate.tim", "w") then
                     close(serverUpdateFile)
               }
               listUpdateFiles := []

               if serverUpdateFile := open(DAT || PS ||"ServerUpdate.tim", "r") then {
                  while checkUpdate := read(serverUpdateFile) do {
                     tmpSplit := find("\t", checkUpdate)
                     if /checkUpdate | /tmpSplit then break
                     checkTime := checkUpdate[1:tmpSplit]
                     checkFile := checkUpdate[tmpSplit+1:0]
                     if parsed[2] < checkTime then {
                        matched := 0
#Pretty sure I can use the member function to make this more elegant
                        every checking := !listUpdateFiles do
                           if checkFile === checking then matched := 1
                        if matched = 0 then put(listUpdateFiles, checkFile)
                        }
                     }
                  close(serverUpdateFile)
                  }
               every checkFile := !listUpdateFiles do {
                  saveDatPath := checkFile
                  if not stat(checkFile) then break
                  if serverUpdateFile := open(checkFile, "r") then {
                     fileData := checkFile || "\t"
                     while readingData := read(serverUpdateFile) do
                        fileData ||:= readingData || "$"
                     close(serverUpdateFile)
                     }
                  sendtoOne(username, fileData, "createDatFile", username)
                  }
               sendtoOne(username, "BREAK", "createDatFile", username)
            }
	    #
	    # might need to add a "send to many" to keep online users
	    # up to date with saves.
	    # roomname&FLAGdata
# where roomname is the name of the room.
# & is a delimiter.
# FLAG is a one or a zero, 1 means the room needs to be added to the list
# of include files and zero means it is already in the list.
# data is the .dat file that the client sent it.       
            "saveroom":{
               breakPoint := find("&", parsed[2])
               saveDatFileName := parsed[2][1:breakPoint]
               saveDatFileData := parsed[2][breakPoint + 2:0]
               includeListDat := parsed[2][breakPoint+1:breakPoint+2]
               saveDatFileData := map(saveDatFileData, "@#~", "\n\t ")
               saveDatFile := open(DAT||PS||"roomdat"||PS||
				   saveDatFileName||".dat", "w")
               write(saveDatFile, saveDatFileData)
               close(saveDatFile)
               if includeListDat = 1 then {
                  if fone := open(DAT||PS||"roomdat"||PS||"roomlist.dat","wa")
		  then {
                     write(fone,"include roomdat"||PS||saveDatFileName||".dat")
                     close(fone)
                     }
                  }
               if fone := open(DAT || PS || "ServerUpdate.tim", "wa") then {
                  if includeListDat = 1 then
                     write(fone, &now || "\t" || DAT || PS ||
			   "roomdat" || PS || "roomlist.dat")
                  write(fone, &now || "\t" || DAT || PS ||
			"roomdat" || PS || saveDatFileName || ".dat")
                  close(fone)
                  }
               }

# towards minigames as special collaborative sessions
#	    "createsession": {
#	       write(&errout, "the server received your session request.")
#	       write("parsed ", image(parsed))
#	       write("parsed[2] ", image(parsed[2]))
#	       }
        ##
        ## Start NewsFeed commands
        ##
            "writeToWall" :{
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID :=  tab(find(" "))
                  move(1)
                  msg     := tab(0)
                  }
               if \find("collaboration session", msg) then {
                  if f := open(USER_GLOBALPATH||PS||userID||PS||"wall.log",
			       "a") then {
                     write(f, userID, " ", msg, "\n", &dateline,
			   "\n", repl("-",28),"\n")
                     close(f)
                     }
		  }
	       else {
		  msg ? {
		     mpart_1 := tab(find(" "))
		     move(1)
		     userID_2 := tab(find(" "))
		     move(1)
		     mpart_2 := tab(0)
		     }
                  if f := open(USER_GLOBALPATH||PS||userID||PS||
                     "wall.log", "a") then {
                     write(f, userID, " ", msg, "\n", &dateline,"\n",
			   repl("-",25), "\n")
                     close(f)
                     }
                  if f := open(USER_GLOBALPATH||PS||userID_2||PS||
                     "wall.log", "a") then {
                     write(f, userID, " ", mpart_1, " ", userID_2," ",mpart_2,
			   "\n", &dateline, "\n", repl("-",25), "\n")
                     close(f)
                     }
                  }
               #add_members_communication_record("Wall")
	       }
            "addWallPost" : {
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  objType := tab(find(" "))
                  move(1)
                  objName := tab(find(" "))
                  move(1)
                  addPostId := tab(find(" "))
                  move(1)
                  ppriority := tab(find(" "))
                  move(1)
                  pcontents := tab(0)
                  }
               if objType === "Group" then
                  datpath := GROUP_GLOBALPATH
               else
                  datpath := PROJECT_GLOBALPATH

               if f := open(datpath||PS||objName||PS||"Wall"||PS||
                  userID||"~"||ppriority||"["||addPostId||"].log", "w") then {
                  write(f, "User: ", userID, "     Date/Time: ", &dateline)
                  write(f, repl("=",50))
                  pcontents ? {
                     while not (pos(0)) do {
                        line := tab(find("$$"))
                        move(2)
                        write(f, line)
                        }
                     }
                  close(f)
                  }
               add_members_communication_record("Wall")
               }
            "delWallPost"   : {
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  objType := tab(find(" "))
                  move(1)
                  objName := tab(find(" "))
                  move(1)
                  postName := tab(0)
                  }
               if objType === "Group" then
                  datpath := GROUP_GLOBALPATH
               else
                  datpath := PROJECT_GLOBALPATH
               system("rm "||datpath||PS||objName||PS|| "Wall"||PS||postName)
               }
            "replyWallPost" : {
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  objType := tab(find(" "))
                  move(1)
                  objName := tab(find(" "))
                  move(1)
                  postName := tab(find(" "))
                  move(1)
                  rcontents := tab(0)
                  }

               if objType === "Group" then
                  datpath := GROUP_GLOBALPATH
               else
                  datpath := PROJECT_GLOBALPATH

               if f := open(datpath||PS||objName||PS||"Wall"||PS||postName,"a")
                  then {
                  write(f,  " ")
                  write(f, "Replied : "||userID|| " Date/Time: ",&dateline)
                  write(f, repl("=", 62))
                  rcontents ? {
                     while not (pos(0)) do {
                        line := tab(find("$$"))
                        move(2)
                        write(f, "          "||line)
                        }
                     }
                  close(f)
                  }
               add_members_communication_record("Wall")
               }
            "addFeed" :{
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  #ppriority := tab(find(" "))
                  #move(1)
                  pcontents := tab(find("@@"))
                  move(2)
                  flag := tab(find(" "))
                  move(1)
                  who_is_allowed := tab(find(":"))
                  move(1)
                  objName := tab(0)
                  }

               if *pcontents >= 30 then
                  feed_lbl := trim(pcontents[1:30], "$", 0)
               else feed_lbl := trim(pcontents, "$", 0)

               #if who_is_allowed ~== "ALL" then
               #   feed_lbl := userID || " " || feed_lbl

               if \flag = 0 then {
                  if f := open(NEWSFEED_GLOBALPATH||PS||userID||" "||
                     feed_lbl||"["||who_is_allowed||"].log", "w") then {
                     write(f, "User: ", userID, "     Date/Time: ", &dateline)
                     write(f, repl("=", 50))
                     if who_is_allowed === "ALL" then {
                        pcontents ? {
                           while not (pos(0)) do {
                              line := tab(find("$$"))
                              move(2)
                              write(f, line)
                              }
                           }
                        }
                     else write(f, userID || " " ||pcontents)
                     close(f)
                     }
                  }

               add_members_communication_record("Feed")

               ## Check this later
               addFeed_nodes(sock, userID, feed_lbl, ppriority,
                             who_is_allowed, objName)
               }
            "removeFeed" :{
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  feed_lbl := tab(find("@@"))
                  move(2)
                  reply_lbl := tab(find("@@"))
                  move(2)
                  flag := integer(tab(find(" ")))
                  move(1)
                  userID := tab(0)
                  }

               fcontents_lst := []
               feed_name := ""
               every feed_name := !open(NEWSFEED_GLOBALPATH) do {
                  if \find(feed_lbl, feed_name) then {
                     feed_name ? {
                        usrID := tab(find(" "))
                        move(1)
                        #ppriority := tab(find(" "))
                        #moveability(1)
                        f_lbl := tab(0)
                        }
                     feed_lbl := feed_name
                     }
                  }

               if f := open(NEWSFEED_GLOBALPATH||PS||feed_lbl, "r") then {
                  while ln := read(f) do {
                     if find("User:", ln) then {
                        ln ? {
                           flbl := tab(find(" "))
                           move(1)
                           fowner := tab(find(" "))
                           }
                        }
                     }
                  close(f)
                  }
               f_lbl := ""
	       feed_lbl ? {
		  while f_lbl ||:= tab(upto(' []')) do
		     f_lbl ||:= "\\"||move(1)
		  f_lbl ||:= tab(0)
		  }
               feed_name := feed_lbl
               feed_lbl := f_lbl

               if fowner == userID then {
                  if flag = 1 then { #Remove the feed
                     system("rm "||NEWSFEED_GLOBALPATH||PS||feed_lbl)
                     sendtoMany(userID, feed_name[1:-4]||"@@"||
                        reply_lbl||"@@"||flag, "removeFeed", 1)
                     } #if
                  else if flag = 0 then { #Remove the reply
                     if f:=open(NEWSFEED_GLOBALPATH||PS||feed_name, "r") then {
                        while line := read(f) do {
                           line2 := read(f)
                           if find("Replied >>>>", line) &
                              find(reply_lbl, line2) then {
                              while l := read(f) do
                                 if find("Replied >>>>", l) then {
                                    put(fcontents_lst, l)
                                    break
                                    }
                              }
                           else {
                              put(fcontents_lst, line, line2)
                              }
                           }
                        close(f)
                        } #if f := open
                     if f:=open(NEWSFEED_GLOBALPATH||PS||feed_name, "w") then {
                        every write(f, !fcontents_lst)
                        close(f)
                        }
                     sendtoMany(userID, feed_name ||"@@"||reply_lbl||"@@"||
                                        flag, "removeFeed", 0)
                     } #else
                  update_stats("Feed/Delete")
                  update_user_stats("Feed/Delete", userID)
                  } #if fowner
               }
            "viewFeed" :{
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID  := tab(find(" "))
                  move(1)
                  feed_lbl := tab(0)
                  }

               every feed_name := !open(NEWSFEED_GLOBALPATH) do {
                  if \find(feed_lbl, feed_name) then feed_lbl := feed_name
                  }

               fcontents := ""
               if f := open(NEWSFEED_GLOBALPATH||PS||feed_lbl, "r") then {
                  while line := read(f) do
                     fcontents ||:= line ||"$$"
                  close(f)
                  }
               update_stats("Feed/View")
               update_user_stats("Feed/View", userID)
               sendtoOne(userID, feed_lbl[1:-4]||"@@"||fcontents, "viewFeed",
			 userID)
               }
            "replytoFeed" :{
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  feed_lbl := tab(find("@@"))
                  move(2)
                  rcontents := tab(0)
                  }

               every feed_name := !open(NEWSFEED_GLOBALPATH) do {
                  if \find(feed_lbl, feed_name) then feed_lbl := feed_name
                  }
               if f := open(NEWSFEED_GLOBALPATH||PS||feed_lbl, "a") then {
                  write(f,  " ")
                  write(f, "          "||"Replied >>>> "||userID||
                        " Date/Time: ",&dateline)
                  rcontents ? {
                     while not (pos(0)) do {
                        line := tab(find("$$"))
                        move(2)
                        write(f, "          "||line)
                        }
                     }
                  close(f)
                  }
               if *rcontents >= 30 then
                  reply_lbl := trim(rcontents[1:30], "$", 0)
               else reply_lbl := trim(rcontents, "$", 0)

               add_members_communication_record("Feed")

               sendtoMany(userID, userID||" "||feed_lbl[1:-4]||
                  "@@"||reply_lbl, "replytoFeed", 1)
               }
        ##
        ## Start Groups commands
        ##
            "groupInvite"    : { #invite user to join group
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))       #invited user
                  move(1)
                  sigName := tab(find(" "))
                  move(1)
                  grphost:= tab(0)
                  }

               if /isBlocked(grphost, userID) then {
                  sigOwner := getOwner(sigName, "sig")
                  if grphost === sigOwner then {
                     Invite_to_join(sock, buffer, "sig")
                     }
                  else
                     sendtoOne(grphost, "You are not the group owner, only "||
                     sigOwner ||" can invite users to the group",
                     "tell", grphost)
                  }
               else
                  sendtoOne(grphost, "You cannot send invitation to user "||
                  userID, "tell", grphost)
               }
            "addFriend"      : { #add user to friends list
               params := Cmds.SplitArgs(buffer)
               newfriend := params[2]
               userID := params[3]
               client := Tsocket_drivers[sock].user.name

               if /isBlocked(userID, newfriend) then {
                  if /isFriend(userID, newfriend) then {
                     pinv := pending_invitation( SetUID(client[1]), client,
                        "Friendship Request", 3, ClockToSec(&clock),newfriend||
                        ", You got a friendship request from user "||client)
                     rec_obj := getUser(newfriend)
                     if \rec_obj then
                        sock_to := Tuser_sock[rec_obj]

                     add_notification_record("Friend/Add", userID, newfriend)
                     new_pending_invitation(sock, pinv, sock_to)
                     if \rec_obj then
                        sendtoOne(sock, newfriend||" "||userID,
                           "addFriend", sock_to)
                        sendtoOne(userID,
                           "A friendship request has been sent to "||newfriend||
                           ".", "tell", userID)
                     }
                  else
                     sendtoOne(userID, "You are friend of "||newfriend||".",
                     "tell", userID)
                  }
               else
                  sendtoOne(userID, "You cannot send invitation to user "||
                  newfriend, "tell", userID)
               }
            "blockUser"      : { #add user to friends list
               params := Cmds.SplitArgs(buffer)
               blockedUser := params[2]
               userID := params[3]
               if f := open(USER_GLOBALPATH||PS||userID||PS||
                            "blocklist.log", "a") then {
                  write(f, blockedUser)
                  close(f)
                  }
               }
            "unblockUser"      : { #remove user from the block list
               params := Cmds.SplitArgs(buffer)
               blockedUser := params[2]
               blockedUsersLst := []
               userID := params[3]
               if f := open(USER_GLOBALPATH||PS||userID||PS||
                            "blocklist.log", "r") then {
                  while u := read(f) do
                     if u ~== blockedUser then
                        put(blockedUsersLst, u)
                  close(f)
                  }
               if f := open(USER_GLOBALPATH||PS||userID||PS||
                            "blocklist.log", "w") then {
                  every write(f, !blockedUsersLst)
                  close(f)
                  }
               }
            "makesig"        : { #create special interest group
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  sigName := tab(find(" "))
                  move(1)
                  sigOwner := tab(find(" "))
                  move(1)
                  permission := tab(find(" "))
                  move(1)
                  sigDesc := tab(0)
                  }

               sigPath := GROUP_GLOBALPATH||PS||sigName
               mkdir(sigPath)
               mkdir(sigPath||PS||"msgs")
               mkdir(sigPath||PS||"Wall")

               setOwner(sigName, sigOwner, "sig")
               setPermission(sigName, permission, "sig")

               if log1 := open(sigPath||PS||"desc.log", "w") then {
                  sigDesc ? {
                     while not (pos(0)) do {
                        line := tab(find("$$"))
                        move(2)
                        write(log1, line)
                        }
                     }
                  close(log1)
                  }
               if f := open(sigPath||PS||"msgs"||PS||"msgs.log", "w") then {
                  close(f)
                  }
               update_stats("Group/Add")
               update_user_stats("Group/Add", sigOwner)
               sendtoMany(sigOwner, sigName||" "||sigOwner, "makesig", 0)
               }
            "setPermissions"     : {
               params := Cmds.SplitArgs(buffer)
               objType := params[2]
               permission := params[4]
               userID := params[5]
               if objType === "sig" then {
                  sigName := params[3]
                  if userID === getOwner(sigName, "sig") then {
                     setPermission(sigName, permission, objType)
                     sendtoOne(userID, "You changed the group("||sigName||
			   ") permissions to "||permission||".","tell", userID)
                     }
                  else
                     sendtoOne(userID,
			       "You cannot change this group permissions.",
			       "tell", userID)
                  }
               else if objType === "profile" then {
                  profileName := params[3]
                  if profileName === userID then {
                     setPermission(profileName, permission, objType)
                     sendtoOne(userID,
                     "Your profile's access permission is changed to "||
                     permission, "tell", userID)
                     }
                  else
                     sendtoOne(userID,
                     "You cannot change this group permissions.",
                     "tell", userID)
                  }
               else if objType === "project" then {
                  projName := params[3]
                  if userID === getOwner(projName, "project") then {
                     setPermission(projName, permission, objType)
                     sendtoOne(userID,
                     "You changed the project("||projName||") permissions "||
                     permission||".","tell", userID)
                     }
                  else
                     sendtoOne(userID,
			       "You cannot change this project permissions.",
			       "tell", userID)
                  }
               }
            "groupRemove"        : { #Remove a group
               params := Cmds.SplitArgs(buffer)
               sigName := params[2]
               userID := params[3]

               if \isOwner(userID, sigName, "sig") then {
                  system("rm -r "||GROUP_GLOBALPATH||PS||sigName||PS)
                  update_user_stats("Group/Delete", userID)
                  update_stats("Group/Delete")
                  sendtoMany(userID, sigName, "groupRemove", 0)
                  }
               else
                  sendtoOne(userID, "You cannot delete this group.",
                     "tell", userID)
               }
            "objDescription"    : {
               params := Cmds.SplitArgs(buffer)
               objName := params[2]
               objType := params[3]
               userID := params[4]

               msg := "\n"||repl("=",38)||"\n"
               msg ||:= "Description of "||"Group/Project ("||objName||")\n"
               msg ||:= repl("-",38)||"\n"
               if objType == "sig" then
                  objPath := GROUP_GLOBALPATH||PS||objName
               else objPath := PROJECT_GLOBALPATH||PS||objName

               if log1 := open(objPath||PS||"desc.log", "r") then {
                  while l := read(log1) do
                     msg ||:= l ||"\n"
                  close(log1)
                  }
               msg ||:= repl("=",38)||"\n"

               sendtoOne(userID, msg, "objDescription", userID)
               }
            "getDescription"    : {
               params := Cmds.SplitArgs(buffer)
               objName := params[2]
               objType := params[3]
               userID := params[4]

               if objType == "sig" then
                  objPath := GROUP_GLOBALPATH||PS||objName
               else objPath := PROJECT_GLOBALPATH||PS||objName
               
               msg := ""
               if log1 := open(objPath||PS||"desc.log", "r") then {
                  while l := read(log1) do
                     msg ||:= l ||"NEWLINE"
                  close(log1)
                  }
               sendtoOne(userID, msg, "getDescription", userID)
               }
            "setDescription"    : {
               buffer ? {
                  command := tab(find(" "))
                  move(1) 
                  objName := tab(find(" "))
                  move(1)
                  objType := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  msg := tab(0)
                  }

               if objType == "sig" then
                  objPath := GROUP_GLOBALPATH||PS||objName
               else objPath := PROJECT_GLOBALPATH||PS||objName

               if log1 := open(objPath||PS||"desc.log", "w") then {
                  msg ? {
                     while not(pos(0)) do {
                        l := tab(find("NEWLINE"))
                        move(7)
                        write(log1, l)
                        }
                     }
                  close(log1)
                  }
               }
            "groupWall"        : {
               params := Cmds.SplitArgs(buffer)
               objName := params[2]
               userID := params[3]
               objType := params[4]

               if \isOwner(userID, objName, objType) |
                  \isMember(objName, userID, objType) then {
                  wall_str := objName||" "||objType||" "||
                     getWallInfo(objName, objType)
                  sendtoOne(userID, wall_str, "groupWall", userID)
                  }
               else
                  sendtoOne(userID, "You cannot access this wall.",
                     "tell", userID)
               }
            "refreshWall"        : {
               params := Cmds.SplitArgs(buffer)
               objName := params[2]
               userID := params[3]
               objType := params[4]
               wall_str := objName||" "||objType||" "||
                  getWallInfo(objName, objType)

               sendtoOne(userID, wall_str, "refreshWall", userID)
               }
            "groupJoin"        : { #join a group
               params := Cmds.SplitArgs(buffer)
               new_member := params[2]
               sigName := params[3]

               sigOwner := getOwner(sigName, "sig")

               if /isBlocked(new_member, sigOwner) then {
                  if /isOwner(new_member, sigName, "sig") then {
                     if /isMember(sigName, new_member, "sig") then {
                        if getPermission(sigName, "sig") === "Friends" then {
                           if \isFriend(sigOwner, new_member) then {
                              join_request(sock, new_member, sigName,
                                 sigOwner, "sig")
                              }
                           else
                              sendtoOne(new_member, "Only owner friends'"||
                              "can join the group", "tell", new_member)
                           }
                        else if getPermission(sigName, "sig") ===
                           "Private" then {
                           sendtoOne(new_member,"You cannot join this group "||
                              ", It is private", "tell", new_member)
                           }
                        else if getPermission(sigName, "sig")==="Public" then {
                           join_request(sock, new_member, sigName, sigOwner,
                              "sig")
                           }
                        }
                     }
                  }
               else
                  sendtoOne(new_member, "You cannot join "||sigOwner||
                     "'s groups.", "tell", new_member)
               }
            "groupLeave"        : { #leave a group
               userslst := []
               params := Cmds.SplitArgs(buffer)
               userID := params[2]
               sigName:= params[3]
               mfound := &null
               if log1 := open(GROUP_GLOBALPATH||PS||sigName||PS||
                               "members.log", "r") then {
                  every put(userslst, read(log1))
                  close(log1)
                  }
               if log1 := open(GROUP_GLOBALPATH||PS||sigName||PS||
                               "members.log", "w") then {
                  every u := !userslst do {
                     if u ~== userID then write(log1, u)
                     else mfound := 1
                     }
                  close(log1)
                  }
               if \mfound then {
                  sendtoMany(userID, userID||" "||sigName, "groupLeave", 0)
                  sendtoOne(userID, "You just left the group.",
                     "tell", userID)
                  }
               else
                  sendtoOne(userID, "You are the owner. You cannot leave this _
                     group, but still can delete it.",
                     "tell", userID)
               }
            "sciAdduser"        : { #add new user to the group/project
               params := Cmds.SplitArgs(buffer)
               command:=\params[1]
               objType := \params[2]
               new_member := \params[3]
               objName := \params[4]
               objOwner := \params[5]
               #actType := \params[6]  #activity type (join or request)
               if objType === "sig" then {
                  #adds expert record
                  fileName := &null
                  if objName == "cpp" then
                     fileName := "objname.cpp"
                  else if objName == "java" then
                     fileName := "objname.java"
                  else if objName == "unicon" then
                     fileName := "objname.icn"
                  if \fileName then
                     add_expert_record(new_member, fileName)

                  #adds the new member to the users' list
                  if /isMember(objName, new_member, objType) &
                     /isOwner(new_member, objName, objType) then {
                     if log1 := open(GROUP_GLOBALPATH||PS||objName||PS||
                                  "members.log", "a") then {
                        write(log1, new_member)
                        close(log1)
                        }
                     }
                  update_notification_record("Group/Join", new_member, objOwner)
                  update_stats("Group/Join")
                  update_user_stats("Group/Join", new_member)
                  update_user_stats("Group/Join", objOwner)
                  if \isPartner (new_member, objOwner, "sig") then
                     update_partner_stats(objName, "G", "Join")
                  if \isPartner (new_member, objOwner, "project") then
                     update_partner_stats(objName, "P", "Join")
                  sendtoMany(objOwner, buffer, "sciAdduser", 0)
                  }
               else if objType === "project" then {
                  #adds expert record
                  fileName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
                     !open(PROJECT_GLOBALPATH||PS||objName||PS||"files"))))))))
                  if \fileName &
                     \find(".icn" | ".cpp" | ".c" | ".java", fileName) then
                     add_expert_record(new_member, fileName)

                  #adds the new member to the users' list
                  if /isMember(objName, new_member, objType) &
                     /isOwner(new_member, objName, objType) then {
                     if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                                  "members.log", "a") then {
                        write(log1, new_member)
                        close(log1)
                        }
                     ##########set_Member_Color(objName, new_member, "red")
                     }
                  update_notification_record("Project/Join", new_member,
					     objOwner)
                  update_stats("Project/Join")
                  update_user_stats("Project/Join", new_member)
                  update_user_stats("Project/Join", objOwner)
                  if \isPartner (new_member, objOwner, "project") then
                     update_partner_stats(objName, "P", "Join")
                  if \isPartner (new_member, objOwner, "sig") then
                     update_partner_stats(objName, "G", "Join")
                  sendtoOne(new_member, new_member||" "||objName,
                     "projTeleport", new_member)
                  }
               }
            "userRemove"        : { #Remove a user
               lst := [] #  store group members
               params := Cmds.SplitArgs(buffer)
               removedUser := trim(params[2], ' ', 0)
               sigName:= trim(params[3], ' ', 0)
               userID := trim(params[4], ' ', 0)

               if \isOwner(userID, sigName, "sig") then {
                  every u := !getMembers(sigName, "sig") do {
                     if u ~== removedUser then
                        put(lst, u)
                     }
                  setMembers(sigName, lst, "sig")
                  sendtoMany(userID, removedUser||" "||
                     getOwner(sigName, "sig"), "userRemove", 0)
                  }
               else
                  sendtoOne(userID, "Only the owner "||
			    getOwner(sigName, "sig")||" can remove users",
			    "tell", userID)
               }
            "changeStatus" : {#change status away, busy, offline, online
               params := Cmds.SplitArgs(buffer)
               userID := params[2]
               ustatus:= params[3]
               Tusers[userID] := ustatus
               sendtoMany(userID, userID||" "||ustatus, "changeStatus", 0)
               }
            "sendToGroup" : {
               params := Cmds.SplitArgs(buffer)
               msg := ""
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  sType := tab(find(" "))
                  move(1)
                  recipient := tab(find(" "))
                  move(1)
                  sender := tab(find(" "))
                  move(1)
                  snode := tab(find(" "))
                  move(1)
                  msg := tab(0)# data and time
                  }

               setMsg(sock, sType, recipient, sender, snode, msg)
               }
            "getEmail"   : {
               #params := Cmds.SplitArgs(buffer)
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  action := tab(find(" "))
                  move(1)
                  objName := tab(find(" "))
                  move(1)
                  objType := tab(find(" "))
                  move(1)
                  msgfrom := tab(find(" "))
                  move(1)
                  msgto := tab(find(" "))
                  move(1)
                  dt := tab(0)# data and time
                  }
               getMsg(sock, action, msgfrom, msgto, dt, objName, objType)
               }
            "avatlocation": {
               params := Cmds.SplitArgs(buffer)
               if /(new_user :=  Tusername_user[params[2]]) then next
               roomName := new_user.getRoom()
               sendtoMany(params[3], roomName, "avatlocation", 0)
               }

        ##
        ## Start user's profile tab commands
        ##
            "userAvailability"   : {  #single user availability
               params := Cmds.SplitArgs(buffer)
               userID := trim(params[2], " ", 0)
               userRequested :=  params[3]  # the user requested the info
               objType :=  params[4]  # the object type
               ava_files := 0 #show the number of the availbility files for each user 
               newlst := table("")
               all_avastr := ""
               every fname :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
                 !open(USER_GLOBALPATH||PS||userID)))))))) do {
                 if find("avaTable(", fname) then {
                    ava_files +:= 1
                    if f := open(USER_GLOBALPATH||PS||userID||
                                 PS||fname, "r") then {
                       while l := read(f) do {
                          l ? {
                             d := tab(find(" "))
                             move(1)
                             }
                          newlst[d] ||:= l || "[]"
                          }
                       close(f)
                       }
                    } 
                 }
               if f := open(USER_GLOBALPATH||PS||userID||
                           PS||"temp.log", "w") then {
                  every write(f, newlst["Sun"|"Mon"|"Tue"|"Wed"|
					"Thu"|"Fri"|"Sat"])
                      
                  close(f)
                  }
               all_avastr := get_all_availability_str(userID, ava_files)

               sendtoOne(userRequested, objType||" "||userID||"~"||
                  all_avastr, "userAvailability", userRequested)
               }
            "avaReport" : {
               params := Cmds.SplitArgs(buffer)
               userID := trim(params[2], " ", 0)
               usr := trim(params[3], " ", 0)

               # The following two function's calls generate 
               # a weekly usage report for each user
               # Day   IDE(min)  3D(min)  AFK(min)
               getUserAFKInfo(userID, 1)
               getUserUsage(userID, 1)

               avaReport_str := ""
               if f := open(USER_GLOBALPATH||PS||userID||
                  PS||"currWeek_ide_3d_usage.log", "r") then {
                  while l := read(f) do
                     if l ~== "" then
                        avaReport_str ||:= l ||"\n"
                  close(f)
                  }
               sendtoOne(usr, avaReport_str, "avaReport", usr)
               }
            "usersAvailability"  : { #shows all users' availabilty patterns
               params := Cmds.SplitArgs(buffer)
               userID := trim(params[2], " ", 0)
               ava_str := ""

               if log1 := open("dat"||PS||
                  "availability.log", "r") then {
                  while ava_str ||:= read(log1)||"&&"
                  close(log1)
                  }
               sendtoOne(userID, ava_str, "usersAvailability", userID)
               }
            "userProfile"        : { #User Profile
               params := Cmds.SplitArgs(buffer)
               profile_id := trim(params[2], " ", 0)
               userID :=  params[3]  # the user requested the profile
               user_is_allowed := isAllowed(profile_id, userID,
                  getPermission(profile_id, "profile"), "profile")
               if \user_is_allowed then {
                  #get user's general information
                  alluserinfo := ""
                  if log1 := open(USER_GLOBALPATH||PS||profile_id||
				  PS||profile_id||".reg", "r") then {
                     while u := read(log1) do {
                        alluserinfo ||:=  u || "&&"
                        }
                     close(log1)
                     }
                  if \alluserinfo then
                     trim(alluserinfo, "&&", 0)
                  #get user's friend list
                  allfriendslst := ""

                  if /(new_user := Tusername_user[userID]) then next
                  every allfriendslst ||:= !(new_user.friends) || " "

                  trim(allfriendslst, " ", 0)

                  allprojectslst := ""
                  allgroupslst   := ""
                  allinterestslst := ""
                  usrWall := ""
                  #get user's SIGs and their members
                  every sigName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
                     !open(GROUP_GLOBALPATH)))))))) do {
                     if \isMember(sigName, profile_id, "sig") |
                        \isOwner(profile_id, sigName, "sig") then {
                        if map(sigName) ==("cpp" | "java" |
                           "unicon" | "se&uml") then {
                           allinterestslst ||:=  sigName || "("
                           if log1 := open(GROUP_GLOBALPATH||PS||sigName||PS||
                                        "members.log","r") then {
                              while u := read(log1) do
                                 allinterestslst ||:=  u ||","
                              close(log1)
                              }
                           if log1 := open(GROUP_GLOBALPATH||PS||sigName||
                              PS||"owner.log","r") then {
                              while u := read(log1) do
                                 allinterestslst ||:=  u ||","
                              close(log1)
                              }
                           trim(allinterestslst, ",", 0)
                           allinterestslst ||:=  ") "
                           }
                        else {
                           allgroupslst ||:=  sigName || "("
                           if log1 := open(GROUP_GLOBALPATH||PS||sigName||PS||
                                        "members.log","r") then {
                              while u := read(log1) do
                                 allgroupslst ||:=  u ||","
                              close(log1)
                              }
                           if log1 := open(GROUP_GLOBALPATH||PS||sigName||
                              PS||"owner.log","r") then {
                              while u := read(log1) do
                                 allgroupslst ||:=  u ||","
                              close(log1)
                              }
                           trim(allgroupslst, ",", 0)
                           allgroupslst ||:=  ") "
                           }
                        }
                     }
                  #get user's projects and their members
                  every projName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
                     !open(PROJECT_GLOBALPATH)))))))) do {
                     if projName ~== "appropriate_partner.log" then {
                     if projName ~== "rooms_info.log" &
                        projName ~== "lastroom.log" then {
                        if \isMember(projName, profile_id, "project") |
                           \isOwner(profile_id, projName, "project") |
                           \getPermission(projName, "project") === "Public"
			then {
                           #if projName ~== "appropriate_partner.log" then
                           allprojectslst ||:=  projName || "("
                           if log1 := open(PROJECT_GLOBALPATH||PS||projName||
					   PS||"members.log","r") then {
                              while u := read(log1) do
                                 allprojectslst ||:=  u ||","
                              close(log1)
                              }
                           if log1 := open(PROJECT_GLOBALPATH||PS||projName||
					   PS||"owner.log","r") then {
                              while u := read(log1) do
                                 allprojectslst ||:=  u ||","
                              close(log1)
                              }
                           trim(allprojectslst, ",", 0)
                           allprojectslst ||:=  ") "
                           }
                        }
                        }
                     }

                  #get user's general information
                  if log1 := open(USER_GLOBALPATH||PS||profile_id||
                     PS||"wall.log", "r") then {
                     usrWall := ""
                     while u := read(log1) do {
                        usrWall ||:=  u || "&&"
                        }
                     close(log1)
                     }
                  trim(usrWall, "&&", 0)

                  sendtoOne(userID, profile_id||"$$"||((\alluserinfo|"")\1)||
                     "$$"||((\allfriendslst|"")\1)||"$$"||allgroupslst||"$$"||
                     allinterestslst||"$$"||allprojectslst||"$$"||usrWall,
                     "userProfile", userID)
                  }
               else {
                  sendtoOne(userID, "You are not allowed to view "||
                     "this profile.", "tell", userID)
                  }
               update_stats("Profile/View")
               update_user_stats("Profile/View", userID)
               if \isPartner (profile_id, userID, "project") then
                  update_partner_stats("Profile", "P", "View")
               if \isPartner (profile_id, userID, "sig") then
                  update_partner_stats("Profile", "G", "View")
               }
            "memberProjectsList" : {
               params := Cmds.SplitArgs(buffer)
               memberID := trim(params[2], " ", 0)
               userID :=  params[3]  # the user requested the info
               allprojectslst := ""
               #get user's projects and their members
               every projName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
                  !open(PROJECT_GLOBALPATH)))))))) do {
                     if \isMember(projName, memberID, "project") |
                        \isOwner(memberID, projName, "project") then {
                        allprojectslst ||:=  projName || "~~"
                        }
                     }
               sendtoOne(userID, allprojectslst, "memberProjectsList", userID)
               }
            "myProjectsList" : {
               params := Cmds.SplitArgs(buffer)
               userID :=  params[2]  # the user requested the info
               allprojectslst := ""
               #get user's projects and their members
               every projName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
                  !open(PROJECT_GLOBALPATH)))))))) do {
                     if \isMember(projName, userID, "project") |
                        \isOwner(userID, projName, "project") then {
                        allprojectslst ||:=  projName || "~~"
                        }
                     }
               sendtoOne(userID, allprojectslst, "myProjectsList", userID)
               }
            "myFriendsList" : {
               params := Cmds.SplitArgs(buffer)
               userID :=  params[2]  # the user requested the info
               myfriends_str := ""
               if *friendsList(userID) > 0 then
                  every myfriends_str ||:= !(friendsList(userID)) || "~~"
               sendtoOne(userID, myfriends_str, "myFriendsList", userID)
               }
            "myPartnersList" : {
               params := Cmds.SplitArgs(buffer)
               userID :=  params[2]  # the user requested the info
               mypartners_str := ""
               if *partnersList(userID) > 0 then
                  every mypartners_str ||:= !(partnersList(userID)) || "~~"
               sendtoOne(userID, mypartners_str, "myPartnersList", userID)
               }
            "setAccountSettings" : {
               buffer ? {
                  command  := tab(find(" "))
                  move(1)
                  userID   := tab(find("&&"))
                  move(2)
                  profName := tab(find("&&"))
                  move(2)
                  profuserID := tab(find("&&")) #profile user ID
                  move(2)
                  email    := tab(find("&&"))
                  move(2)
                  password := tab(find("&&"))
                  move(2)
                  privacy  := tab(0)
                  }
               if fout := open(USER_GLOBALPATH||PS||userID||PS||
                  "account_settings.log", "w") then {
                  write(fout, "Name     = ",profName,
			"\nUsername = ",profuserID, "\nEmail    = ", email,
			"\nPassword = ",password, "\nPrivacy  = ",privacy)
                  close(fout)
                  }
               update_stats("Profile/Update")
               update_user_stats("Profile/Update", userID)
               }
            "setPrivacySettings" : {
               buffer ? {
                  command  := tab(find(" "))
                  move(1)
                  userID   := tab(find("&&"))
                  move(2)
                  privacy_settings := tab(find("&&"))
                  move(2)
                  projects_privacy := tab(find("&&"))
                  move(2)
                  groups_privacy   := tab(find("&&"))
                  move(2)
                  newsfeed_privacy := tab(find("&&"))
                  move(2)
                  status_privacy   := tab(0)
                  }
               if fout := open(USER_GLOBALPATH||PS||userID||PS||
                  "privacy_settings.log", "w") then {
                  #write(fout, "Privacy  = "||privacy_settings)
                  write(fout, "Projects = "||projects_privacy)
                  write(fout, "Groups   = "||groups_privacy)
                  write(fout, "NewsFeed = "||newsfeed_privacy)
                  write(fout, "Status   = "||status_privacy)
                  close(fout)
                  }
               update_stats("Profile/Update")
               update_user_stats("Profile/Update", userID)
               }

            "getAccountSettings" : {
               params := Cmds.SplitArgs(buffer)
               userID := params[2]
               a_settings := ""
               if not stat(USER_GLOBALPATH||PS||userID||PS||
                  "account_settings.log") then {
                  if log1 := open(USER_GLOBALPATH||PS||userID||PS||
                     "account_settings.log", "w") then {
                     write(log1, "Name     = "||userID)
                     write(log1, "Username = "||userID)
                     write(log1, "Email    = "||"")
                     write(log1, "Password = "||"welcome")
                     write(log1, "Privacy  = "||"EveryOne")
                     close(log1)
                     }
                  }
               if log1 := open(USER_GLOBALPATH||PS||userID||PS||
                  "account_settings.log","r") then {
                   while u := read(log1) do
                      a_settings ||:=  u ||"&&"   # account settings
                   close(log1)
                   }
               sendtoOne(userID, a_settings, "getAccountSettings", userID)
               }
            "getPrivacySettings" : {
               params := Cmds.SplitArgs(buffer)
               userID := params[2]
               p_settings := ""
               if not stat(USER_GLOBALPATH||PS||userID||PS||
                  "privacy_settings.log") then {
                  if log1 := open(USER_GLOBALPATH||PS||userID||PS||
                     "privacy_settings.log", "w") then {
                     #write(log1, "Privacy  = "||privacy_settings)
                     write(log1, "Projects = "||"EveryOne")
                     write(log1, "Groups   = "||"EveryOne")
                     write(log1, "NewsFeed = "||"EveryOne")
                     write(log1, "Status   = "||"EveryOne")
                     close(log1)
                     }
                  }

               if log1 := open(USER_GLOBALPATH||PS||userID||PS||
                  "privacy_settings.log","r") then {
                  while u := read(log1) do {
                     p_settings ||:=  u ||"&&"   # privacy settings
                     }
                  close(log1)
                  }
               sendtoOne(userID, p_settings, "getPrivacySettings", userID)
               }
        ##
        ## Start projects commands
        ##
            "makeProject"        : { #create special interest group
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  projName := tab(find(" ")) 
                  move(1)
                  projOwner := tab(find(" "))
                  move(1)
                  ownerColor := tab(find(" "))
                  move(1)
                  deadline := tab(find(" "))
                  move(1)
                  permission := tab(find(" "))
                  move(1)
	          projDesc := tab(0)
                  }
               projPath := PROJECT_GLOBALPATH||PS||projName
               mkdir(projPath)
               mkdir(projPath||PS||"Wall")
               mkdir(projPath||PS||"files")
               mkdir(projPath||PS||"buffer_files")
               mkdir(projPath||PS||"members_activity")
               mkdir(projPath||PS||"files_activity")

               if log1 := open(projPath||PS||"desc.log", "w") then {
                  projDesc ? {
                     while not (pos(0)) do {
                        line := tab(find("$$"))
                        move(2)
                        write(log1, line)
                        }
                     }
                  close(log1)
                  }

               log1 := projPath||PS||"members_activity"||PS||
                  "currently_working.log"
               close(open(log1, "w"))
               log1 := projPath||PS||"members_activity"||PS||
                  "previously_changed.log"
               close(open(log1, "w"))
               log1 := projPath||PS||"files_activity"||PS||
                  "files_activities.log"
               close(open(log1, "w"))

               if log1 := open(projPath||PS||"member_color.log", "w") then {
                  write(log1, projOwner||":"||ownerColor)
                  close(log1)
		  }

               if log1 := open(projPath||PS||"proj_info.log", "w") then {
                  write(log1, "Started (Date): "||&date)
                  write(log1, "Started (Time): "||&clock)
                  write(log1, "Deadline: "||deadline)
                  write(log1, "Privacy: "||permission)
                  close(log1)
                  }

               if log1 := open(PROJECT_GLOBALPATH||PS||
			       "lastroom.log", "r") then {
                  room_coords := read(log1)
                  close(log1)
                  }
               else {
                  room_coords := "1000 1000 200 25 25 25"
                  }
               change_lastRoom_coordinates(room_coords)
               setOwner(projName, projOwner, "project")
               #setPermission(projName, permission, "project")
               set_Member_Color(projName, projOwner, ownerColor)
               update_stats("Project/Add")
               update_user_stats("Project/Add", projOwner)
               sendtoMany(projOwner, projName||" "||projOwner||" "||
                  room_coords, "makeProject", 0)
               }
            "projectDelete"        : { #Delete a project
               params := Cmds.SplitArgs(buffer)
               projName := params[2]
               userID := params[3]

               if \isOwner(userID, projName, "project") then {
                  system("rm -r "||PROJECT_GLOBALPATH||PS||projName||PS)
                  update_stats("Project/Delete")
                  update_user_stats("Project/Delete", userID)
                  sendtoMany(userID, projName, "projectDelete", 0)
                  }
               else
                  sendtoOne(userID, "You cannot delete this project."||
                     " You are not the project owner.", "tell", userID)
               }
            "getProjectInfo"     : {
               params := Cmds.SplitArgs(buffer)
               pname  := params[2]
               userID := params[3]
               powner := getOwner(pname, "project")
               pmembers :=""
               every u := !getMembers(pname, "project") do
                  pmembers ||:= u || ","
               pfiles := ""
               every u := !getprojectFiles(pname) do
                  pfiles ||:= u || "$$"
               pdate := ctime(stat(PROJECT_GLOBALPATH||PS||pname).mtime)[5:17]
               if log1 := open(PROJECT_GLOBALPATH||PS||
                  pname||PS||"proj_info.log", "r") then {
                  pdate := read(log1)
                  pdeadline := read(log1)
                  pprivacy := read(log1)
                  close(log1)
                  }
               if pname ~== ("appropriate_partner.log") then {
                  if pname ~== "rooms_info.log" &
                     pname ~== "lastroom.log" then {
                     sendtoOne(userID, pname||"&&"||powner||"&&"||pmembers||
			       "&&"|| pfiles||"&&"||pdate||"&&"||pdeadline||
			       "&&"||pprivacy, "getProjectInfo", userID)
                     }
                  }
               }
            "projfileOpen" : {
               params := Cmds.SplitArgs(buffer)
               projName  := params[2]
               fileName  := params[3]
               userID := params[4]

               permissionType := getPermission(projName, "project")

               if \isMember(projName, userID, "project") |
                  \isOwner(userID, projName, "project") |
                  \permissionType == "Public" then {
                  on_projfileOpen(projName, fileName, userID)
                  }
               else if \permissionType == "Friends" then {
                  if \isFriend(getOwner(projName, "project"), userID) then
                     on_projfileOpen(projName, fileName, userID)
                  }
               else {
                  sendtoOne(userID, "You don't have permission"||
                     " to open this file.", "tell", userID)
                  }
               }
            "projfileClose"       : {
               params := Cmds.SplitArgs(buffer)
               projName := params[2]
               fileName := params[3]
               userID     := params[4]
               seconds_time := ClockToSec(&clock) #current time in seconds

               # get the closed file information record(file name,
               # project name, date and time opened)
               # Then remove the file from the currently working on
               # files.
               lst := []
               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "members_activity"||PS||"currently_working.log", "r")
	       then {
                   while l := read(f) do {
                      if find(fileName || " " || userID, l) then
                         closedfileinfo := l
                         #(fileName||" "||userID||" "||access_time)
                      else put(lst, l)
                      }
                  close(f)
                  }
               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
			    "members_activity"||PS||"currently_working.log",
			    "w") then {
                  every write(f, !lst)
                  close(f)
                  }


               # Check the accessed file history
               # and compute the time spent working in this file before
               # closing and the total time spent working on this file

               lst := []
               if fd := open(PROJECT_GLOBALPATH||PS||projName||PS||
			     projName || "_access.log", "r") then {
                  while l := read(fd) do {
                      if find(fileName||" "||userID, l) then {
                         l ? {
                            fname := tab(find(" "))
                            move(1)
                            uId := tab(find(" "))
                            move(1)
                            faccess_time := tab(find(" "))
                            move(1)
                            time_spent := tab(0)
                            }
                          if time_spent == 0 then
                             time_spent := seconds_time - faccess_time
                          l := fname||" "||uId||" "||faccess_time||" "||
                             time_spent
                          }
                      put(lst, l)
                      }
                  close(fd)
                  }
               total_time_spent := 0
               if fd := open(PROJECT_GLOBALPATH||PS||projName||PS||
			     projName || "_access.log", "w") then {
                  every l := !lst do {
                     if l ~== "" then
                        write(fd, l)
                     if find(fileName||" "||userID, l) then {
                        l ? {
                           fname := tab(find(" "))
                           move(1)
                           uId := tab(find(" "))
                           move(1)
                           faccess_time := tab(find(" "))
                           move(1)
                           time_spent := integer(tab(0))
                           total_time_spent +:= time_spent
                           }
                         }
                     }
                  close(fd)
                  }

               user_time_tbl := table()
               if fd := open(PROJECT_GLOBALPATH||PS||projName||PS||fileName ||
                  "_time_spent.log", "r") then {
                  while l := read(fd) do {
                     if l ~== "" then {
                        l ? {
                           uId := tab(find(":"))
                           move(1)
                           time_spent := integer(tab(0))
                           }
                        user_time_tbl[uId] := time_spent
                        }
                     }
                  close(fd)
                  }
               user_time_tbl[userID] := total_time_spent
               if fd := open(PROJECT_GLOBALPATH||PS||projName||PS||fileName ||
                  "_time_spent.log", "w") then {
                  every u := key(user_time_tbl) do
                     write(fd, u||":"||user_time_tbl[u])
                  close(fd)
                  }

               max_time_spent := 0
               min_time_spent := 0
               every u := key(user_time_tbl) do {
                  if user_time_tbl[u] >= max_time_spent then
                     max_time_spent := user_time_tbl[u]
                  if user_time_tbl[u] <= min_time_spent then
                     min_time_spent := user_time_tbl[u]
                  }
               every u := key(user_time_tbl) do {
                  if integer(user_time_tbl[u]) === integer(max_time_spent) then {
                     most_active_member := u
                     }
                  }

               # store the previously changed files records in a list
               # (file name, project name, date and time opened, date and time
               # closed)
               # Then add the closed file record to the previously changed
               # files (file name, project name, date and time opened, date and
               # time closed)

               lst := []
               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
			    "files_activity"||PS||"files_activities.log",
			    "r") then {
                  while l := read(f) do {
                     if l ~== "" then {
                     if find(\closedfileinfo, l) then {
                        l ? {
                           fileName := tab(find(" "))
                           move(1)
                           userID := tab(find(" "))
                           move(1)
                           stime := tab(find(" "))  #star time
                           move(1)
                           etime := tab(find(" "))  #end time
                           move(1)
                           actiontype := tab(0)
                           }

                        put(lst, fileName||" "||userID ||" "||
                            stime||" "||seconds_time||" "||actiontype)
                        }
                     else put(lst, l)
                     }
                     }
                  close(f)
                  }

               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
			    "files_activity"||PS||"files_activities.log",
			    "w") then {
                  every write(f, !lst)
                  close(f)
                  }
               }
            "projfileAdd"       : {
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  projName := tab(find(" "))
                  move(1)
                  fileName := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  fcontents := tab(0)
                  }
               seconds_time := ClockToSec(&clock) #current time in seconds
               if \isMember(projName, userID, "project") |
                  \isOwner(userID, projName, "project") then {
                  if f := open(PROJECT_GLOBALPATH||PS||projName||
                     PS||"files"||PS||fileName, "w") then {
                     fcontents ? {
                        while not(pos(0)) do {
                           l := tab(find("\x1e"))
                           write(f, l)
                           move(1)
                           }
                        }
                     close(f)
                     }
                  if find("(PF)", fileName) then {
                     fileName ? {
                        fn := tab(find("(PF)")) #fileName
                        ="(PF)"
                        pn := tab(0)            #projName
                        }
                     fileName := fn
                     }

                  if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
		     "members_activity"||PS||"currently_working.log",
		     "w") then {
                     write(f, fileName||" "||userID||" "||seconds_time)
                     close(f)
                     }
                  if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                     "files_activity"||PS||"files_activities.log",
                     "w") then {
                     write(f, fileName||" "||userID||" "||seconds_time||
                        " "||seconds_time||" "||"Added")
                     close(f)
                     }
                  if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                     "files_activity"||PS||fileName||"_changedlines.log",
                     "w") then {
                     close(f)
                     }
                  if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                     "files_activity"||PS||fileName||
                     "_changedlines_with_uncommitted("||
                     userID||").log","w") then {
                     #write(f, 0||":"||userID)
                     close(f)
                     }
                  if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                     "creators.log","w") then {
                     write(f, fileName||" "||userID)
                     close(f)
                     }
                  if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                     "updaters.log","w") then {
                             #filename updater count_updates
                     write(f, fileName||" "||userID||" "||1)
                     close(f)
                     }

                  update_stats("Project/Add")
                  update_user_stats("Project/Add", userID)
                  sendtoMany(userID, projName||" "||fileName, "projfileAdd",
                             userID)
                  }
               else {
                  sendtoOne(userID, "You don't have permission to add "||
                              "files to the project.", "tell", userID)
                  }
               }
            "projfileDelete"        : { #Remove a project file
               lst := [] #  store project files
               params := Cmds.SplitArgs(buffer)
               removedFile := params[2]
               projName:= params[3]
               userID := params[4]

               if \isOwner(userID, projName, "project") then {
                  fpath := PROJECT_GLOBALPATH||PS||projName||PS||"files"||PS||removedFile

                  system("rm "||fpath)
                  update_stats("Project/Delete")
                  update_user_stats("Project/Delete", userID)
                  sendtoMany(userID,removedFile||" "||
                     projName,"projfileDelete", 0)
                  }
               else
                  sendtoOne(userID, "Only the project owner"||
                     " can delete files.", "tell", userID)
               }

            "readytoCommit"       : {
               currentlyworkingrecords := ""
               previouslychangedrecords := ""
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  projName := tab(find(" "))
                  move(1)
                  fileName := tab(find(" "))
                  move(1)
                  userID := trim(tab(find(" ")), " ", 0)
                  move(1)
                  fcontents := tab(0)
                  }

               if find("(PF)", fileName) then {
                  fileName ? {
                     fn := tab(find("(PF)")) #fileName
                     ="(PF)"
                     pn := tab(0)            #projName
                     }
                  fileName := fn
                  }

               # make a string of all the recods of users are currently
               # working on the file.

               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "members_activity"||PS||"currently_working.log", "r") then {
                  while l := read(f) do {
                     if find(fileName, l) then
                       currentlyworkingrecords ||:= l || "\x1e"
                     }
                     close(f)
                  }

               # get the committed file information record(file name,
               # project name, date and time opened)
               lst := []
               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "members_activity"||PS||"currently_working.log", "ra") then {
                  while l := read(f) do {
                     if find(fileName||" "||userID, l) then
                        closedfileinfo := l
                     else put(lst, l)
                     }
                     close(f)
                  }

               # store the previously changed files records in a list
               # (file name, project name, date and time opened, date and time
               # closed)
               # Then add the closed file record to the previously changed
               # files (file name, project name, date and time opened, date and
               # time closed)

               lst := []
               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
			    "files_activity"||PS||"files_activities.log",
			    "r") then {
                  while l := read(f) do {
                     if l ~== "" then {
                     if find(\closedfileinfo, l) then {
                        l ? {
                           fileName := tab(find(" "))
                           move(1)
                           userID := tab(find(" "))
                           move(1)
                           stime := tab(find(" "))  #start time
                           move(1)
                           etime := tab(find(" "))  #end time
                           move(1)
                           actiontype := tab(0)
                           }

                        put(lst, fileName||" "||userID ||" "||
                            stime||" "||ClockToSec(&clock)||" "||actiontype)
                        }
                     else put(lst, l)
                     }
                     }
                  close(f)
                  }

               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "files_activity"||PS||"files_activities.log",
                  "w") then {
                  every write(f, !lst)
                  close(f)
                  }

               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "files_activity"||PS||"files_activities.log", "r") then {
                  while l := read(f) do {
                     if find(fileName, l) then
                        previouslychangedrecords ||:= l || "\x1e"
                     }
                  close(f)
                  }

               allfilesstr := ""
               every u :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(!open(
                  PROJECT_GLOBALPATH||PS||projName||PS||"files")))))))) do {
                 if find(fileName[1:find(".", fileName)]||"_", u) then {
                    allfilesstr ||:=  u || " "
                    }
                 }
               allfilesstr := trim(allfilesstr, ' ', 0)
               sendtoOne(userID, fileName || " " || projName ||
                  " " || currentlyworkingrecords || "^^^" ||
                  previouslychangedrecords || "^^^" || allfilesstr,
                  "readytoCommit", userID)
               }
           "commitChanges"       : {
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  projName := tab(find(" "))
                  move(1)
                  fileName := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  fcontents := tab(0)
                  }

               if dot := find(".", fileName) then
                  old_ver:= fileName[1:dot]||"_"||userID||"."||fileName[dot+1:0]
               else
                  old_ver := fileName||"_"||userID

               if \old_ver then
               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
			    "files"||PS||old_ver, "w") then {
                  fcontents ? {
                    while not(pos(0)) do {
                       l := tab(find("\x1e"))
                       move(1)
                       write(f, l)
                       }
                     }
                  close(f)
                  }

               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "files"||PS||fileName, "w") then {
                  fcontents ? {
                     while not(pos(0)) do {
                        l := tab(find("\x1e"))
                        write(f, l)
                        move(1)
                        }
                     }
                  close(f)
                  }

               if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
			       "files_activity"||PS||fileName||
			       "_changedlines_with_uncommitted("||
			       userID||").log","r") then {
                  if log2 := open(PROJECT_GLOBALPATH||PS||projName||PS||
				  "files_activity"||PS||fileName||
				  "_changedlines.log", "a") then {
                     while l := read(log1) do {
                        if l ~== "" then {
                           write(log2, l)
                           }
                        }
                     close(log2)
                     }
                  close(log1)
                  }

               if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
			       "files_activity"||PS||fileName||
			       "_changedlines_with_uncommitted("||
			       userID||").log","w") then {
                  close(log1)
                  }
               #
               # Who updated the last updated a file information
               #
               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "last_updated.log", "w") then {
                  write(f, "Last updated on: "||&dateline)
                  write(f, "Last active member: "||userID)
                  write(f, "Last updated file: "||fileName)
                  close(f)
                  }
               #
               # The appropriate partner is the most active member in
               # this project (most_active_member : programming_language)
               #
               ma_member := proj_most_active_member(projName, fileName, userID)
               add_expert_record(ma_member, fileName)
               update_fileupdates_stats(projName, fileName, userID)
               }
           "checkdiff"       : {
               file_contents := []
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  projName := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  compare_file := tab(find(" "))
                  move(1)
                  with_file := tab(find(" "))
                  move(1)
                  fcontents := tab(0)
                  }

               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "buffer_files"||PS||compare_file||".buffer", "w") then {
                  fcontents ? {
                     while line := tab(find("\x1e")) do {
                        = "\x1e"
                        write(f, line)
                        put(file_contents, line)
                        }
                     line := tab(0)
                     write(f, line)
                     put(file_contents, line)
                     }
                  close(f)
                  }

               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "files"||PS||"diffresults.log", "w") then {
                  system("diff"||" "||
                     PROJECT_GLOBALPATH||PS||projName||PS||"buffer_files"||PS||
                     compare_file||".buffer"||" "||
                     PROJECT_GLOBALPATH||PS||projName||PS||"files"||PS||
                     with_file || " > " ||
                     PROJECT_GLOBALPATH||PS||projName||PS||"files"||PS||
                     "diffresults.log")
                  close(f)
                  }

               diff_results_str := ""
               if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "files"||PS||"diffresults.log", "r") then {
                  while l := read(f) do
                     diff_results_str ||:= l || "\x1e"
                  close(f)
                  }

               sendtoOne(userID, diff_results_str, "checkdiff", userID)
               }

            "getExpertsList"    : { # Check a list of the experts in
                                    # a specific language (lang_name)
               experts_str := ""

               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  lang_name := tab(0)
                  }
               #
               # This file (appropriate_partner.log) stores
               # the most active member in each SCI project.
               #
               if f := open(PROJECT_GLOBALPATH||PS||
                  "appropriate_partner.log", "r") then {
                  while l := read(f) do {
                     l ? {
                        uname := tab(find(":"))
                        move(1)
                        lang_n := tab(0)
                        }
                     to_user := getUser(uname)
                     
                     if lang_n == lang_name then
                        if \(usr := Tusername_user[u]) then
                           if (usr.get_activity_status()) ~== "Offline" then
                              experts_str ||:= uname ||":"
                     }
                  close(f)
                  }
               #
               # This part to get the members who belong to
               # a group such as C++, Java, or Unicon.
               # The group members are the experts in the
               # language (lang_name)
               #
               if lang_name === ("C++" | "C") then
                  sigName := "cpp"
               else if lang_name === ("java" | "Java") then
                  sigName := "Java"
               else if lang_name === ("unicon" | "Unicon") then
                  sigName := "unicon"

               if log1 := open(GROUP_GLOBALPATH||PS||sigName||
                  PS||"members.log","r") then {
                  while uname := read(log1) do
                     if uname ~== "system" then
                        experts_str ||:= uname ||":"
                  close(log1)
                  }
               if log1 := open(GROUP_GLOBALPATH||PS||sigName||
                  PS||"owner.log","r") then {
                  while uname := read(log1) do
                     if uname ~== "system" then
                        experts_str ||:= uname ||":"
                  close(log1)
                  }
               sendtoOne(userID, experts_str, "getExpertsList", userID)
               }

            "projectInvite"    : { #invite user to join project
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  projName := tab(find(" "))
                  move(1)
                  projhost:= tab(0)
                  }

               projOwner := getOwner(projName, "project")

               buffer ||:= " "||projOwner
               if /isBlocked(grphost, userID) then {
                  if projhost === projOwner then
                     Invite_to_join(sock, buffer, "project")
                  else
                     sendtoOne(projhost,"you are not the project owner, only "||
			       projOwner ||" can invite users to the group",
			       "tell", projhost)
                  }
               else
                  sendtoOne(projhost, "You cannot send invitation to user "||
                  userID)
               }
            "projectJoin"   : {
               params := Cmds.SplitArgs(buffer)
               new_member := params[2]
               projName := params[3]

               projOwner := getOwner(projName, "project")
               p_permission := getPermission(projName, "project") 

               if /isBlocked(new_member, projOwner) then {
                  if /isOwner(new_member, projName, "project") then {
                     if /isMember(projName, new_member, "project") then {
                        if \p_permission === "Friends" then {
                           if \isFriend(projOwner, new_member) then {
                              join_request(sock, new_member, projName,
                              projOwner, "project")
                              }
                           else
                              sendtoOne(new_member,
					"Only project owner friends"||
					" can join the project", "tell",
					new_member)
                           }
                        if \p_permission === "Open" then {
                           if log1 := open(PROJECT_GLOBALPATH||PS||
                              projName||PS||"members.log", "a") then {
                              write(log1, new_member)
                              close(log1)
                              }
                           set_Member_Color(projName, new_member, "red")
                           sendtoOne(new_member, "You have joined the "||
                              projName||" project.", "tell", new_member)
                           }
                        else if \p_permission === "Private" then {
                           sendtoOne(new_member,
                              "You cannot join this project, It is private.",
                              "tell", new_member)
                           }
                        else if \p_permission === "Public" then {
                           join_request(sock, new_member, projName,
                           projOwner, "project")
                           }
                        }
                     else sendtoOne(new_member, 
                        "You are a member of this project.",
                        "tell", new_member)
                     }
                  else sendtoOne(new_member, 
                     "You are a member of this project.",
                     "tell", new_member)
                  }
               else
                  sendtoOne(new_member, "You cannot join "||projOwner||
                     "'s projects.", "tell", new_member)
               }
            "projectLeave"        : { #leave a project
               userslst := []
               params := Cmds.SplitArgs(buffer)
               userID := params[2]
               projName:= params[3]
               if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                               "members.log", "r") then {
                  every put(userslst, read(log1))
                  close(log1)
                  }
               if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                               "members.log", "w") then {
                  every u := !userslst do {
                     if u ~== userID then write(log1, u)
                     }
                  close(log1)
                  }
               every u := !userslst do
                  sendtoOne(u, userID||" left the prject "||
                  projName , "tell", u)
               }
            "sessionActivity"  : {
               buffer ? {
                 command := tab(find(" "))
                 move(1)
                 fileName :=  tab(find(" "))
                 move(1)
                 userID := tab(0)
                 }
               session_history(userID, fileName)
               }
            "projActivity"  : {
               buffer ? {
                 command := tab(find(" "))
                 move(1)
                 userID :=  tab(find(" "))
                 move(1)
                 projName := tab(find(" "))
                 move(1)
                 fileName := tab(0)
                 }

               if \isMember(projName, userID, "project") |
                  \isOwner(userID, projName, "project") |
                  (\getPermission(projName, "project") === "Public") then {
                  project_history(userID, projName, fileName)
                  }
               else if \permissionType == "Friends" then {
                  if \isFriend(getOwner(projName, "project"), userID) then
                     project_history(userID, projName, fileName)
                  }
               }
            "userTimeSpent" : {
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID :=  tab(find(" "))
                  move(1)
                  projName := tab(0)
                  }
               info_str := getMemberTimeList(projName)
               sendtoOne(userID, projName||"~"||info_str,
                     "userTimeSpent", userID)
               }
            "userProgress" : {
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID :=  tab(find(" "))
                  move(1)
                  userRequested := tab(0)
                  }
               info_str := getMemberProgress(userID)

               user_is_allowed := isAllowed(userID, userRequested,
                  getPermission(userID, "profile"), "profile")
               if \user_is_allowed then {
                  sendtoOne(userRequested, userID||"~"||info_str,
                  "userProgress", userRequested)
                  }
               }
            "membersColorList"  : {
               buffer ? {
                 command := tab(find(" "))
                 move(1)
                 userID :=  tab(find(" "))
                 move(1)
                 projName := tab(0)
                 }

               if \isOwner (userID, projName, "project") |
                  \isMember(projName, userID, "project") then {
                  sendtoOne(userID,projName||" "||getMemberColorList(projName),
                     "membersColorList", userID)
                  }
               else {
                  if getPermission(projName, "project") === "Friends" then {
                     projOwner := getOwner(projName, "project")
                     if \isFriend(projOwner, userID) then {
                        sendtoOne(userID, projName||" "||
				  getMemberColorList(projName),
				  "membersColorList", userID)
                        }
                     }
                  else if getPermission(projName,"project") === "Public" then {
                     sendtoOne(userID, projName||" "||
			       getMemberColorList(projName),
			       "membersColorList", userID)
                     }
                  }
               }

            "projTooltip"  : {
               lst := []
               buffer ? {
                 command := tab(find(" "))
                 move(1)
                 flag := integer(tab(find(" ")))
                 move(1)
                 userID :=  tab(find(" "))
                 move(1)
                 projName := tab(find(" "))
                 move(1)
                 fName := tab(0)
                 }
               pdeadline := ""
               if log1 := open(PROJECT_GLOBALPATH||PS||
                  projName||PS||"proj_info.log", "r") then {
                  while l := read(log1) do {
                     if find("Deadline", l) then
                        pdeadline := l
                     }
                  close(log1)
                  }
               if flag = 2 then
                  proj_most_active_member(projName, fName, userID)
               if flag = 3 then
                  proj_file_activity(projName, fName, userID)
               if flag = 2 then
               if \isOwner (userID, projName, "project") |
                  \isMember(projName, userID, "project") then {
                  sendtoOne(userID, flag||" "||projName||"$$"||pdeadline||
                     "$$"||getMemberColorList(projName)||"$$"||
                     proj_tooltip_msg,"projTooltip", userID)
                  }
               else {
                  if getPermission(projName, "project") === "Friends" then {
                     projOwner := getOwner(projName, "project")
                     if \isFriend(projOwner, userID) then {
                        sendtoOne(userID, flag||" "||projName||"$$"||pdeadline||
                           "$$"||getMemberColorList(projName)||
                           "$$"||proj_tooltip_msg,"projTooltip", userID)
                        }
                     }
                  else if getPermission(projName, "project") === "Public" then {
                     sendtoOne(userID, flag||" "||projName||"$$"||pdeadline||
                        "$$"||getMemberColorList(projName)||
                        "$$"||proj_tooltip_msg,"projTooltip", userID)
                    }
                  else if getPermission(projName, "project") === "Open" then {
                     sendtoOne(userID, flag||" "||projName||"$$"||pdeadline||
                        "$$"||getMemberColorList(projName)||
                        "$$"||proj_tooltip_msg,"projTooltip", userID)
                    }
                  }
               }
            "sessionTooltip"  : {
               buffer ? {
                 command := tab(find(" "))
                 move(1)
                 userID :=  tab(find(" "))
                 move(1)
                 sessionName := tab(0)
                 }
               session_file_activity(sessionName)
               sendtoOne(userID, sessionName||"$$"||
                  session_tooltip_msg,"sessionTooltip", userID)
               }
            "checkMemberColor" :{ # check if the user already
                                  # have a color in the project
              colorfound := 0
              buffer ? {
                 command := tab(find(" "))
                 move(1)
                 projName := tab(find(" "))
                 move(1)
                 userID :=  tab(0)
                 }

              mc := getMemberColorList(projName)
              if find(userID, mc) then colorfound := 1
              sendtoOne(userID, projName||" "||colorfound,
                                "checkMemberColor", userID)
              }
           "setMemberColor"  : {
              buffer ? {
                 command := tab(find(" "))
                 move(1)
                 projName :=  tab(find(" "))
                 move(1)
                 userID := tab(find(" "))
                 move(1)
                 memberColor := tab(0)
                 }
              set_Member_Color(projName, userID, memberColor)
              }
           "memberActivity"  : {
              buffer ? {
                 command := tab(find(" "))
                 move(1)
                 userID :=  tab(find(" ")) # user who request info
                 move(1)
                 projName := tab(find(" "))
                 move(1)
                 s_name := tab(0) # user his info is requested
                 }
              if \isOwner(userID, projName, "project") |
                 \isMember(projName, userID,"project") then
                 proj_member_activity_history(userID, projName, s_name)
              }
           "getAccessedProjFiles"  : {
              buffer ? {
                 command := tab(find(" "))
                 move(1)
                 userID :=  tab(find(" ")) # user who request info
                 move(1)
                 projName := tab(find(" "))
                 move(1)
                 s_name := tab(0) # user his info is requested
                 }
              if \isOwner(userID, projName, "project") |
                 \isMember(projName, userID,"project") then
                 accessed_projfiles(userID, projName, s_name)
              }
           "projMembersLst"  : {
              buffer ? {
                 command := tab(find(" "))
                 move(1)
                 userID := tab(find(" "))
                 move(1)
                 projName :=  tab(0)
                 }
               pmembers := ""
               every u := !getMembers(projName, "project") do
                  pmembers ||:= u || ","
               sendtoOne(userID, pmembers, "projMembersLst", userID)
              }
            "storeUpdatedLines"  : {
               buffer ? {
                 command := tab(find(" "))
                 move(1)
                 userID := tab(find(" "))
                 move(1)
                 projName := tab(find(" "))
                 move(1)
                 fileName := tab(0)
                 }

               if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                               "files_activity"||PS||fileName||
                               "_changedlines.log", "r") then {
                  if log2 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                               "files_activity"||PS||fileName||
                               "_changedlines_buffer.log", "a") then {
                     while l := read(log1) do {
                        if l ~== "" then {
                           write(log2, l)
                           }
                        }
                     close(log2)
                     }
                  close(log1)
                  }

               if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                               "files_activity"||PS||fileName||
                               "_changedlines.log", "r") then {
                  if log2 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                               "files_activity"||PS||fileName||
                              "_changedlines_with_uncommitted.log", "a") then {
                     while l := read(log1) do {
                        if l ~== "" then {
                           write(log2, l)
                           }
                        }
                     close(log2)
                     }
                  close(log1)
                  }

               }

            # store previously changed lines in a table
            # called commited_line_user_table
            # and in log file called filename_changedlines_buffer.log
            "storeChangedLines"  : {
               commited_line_user_table := table()

               buffer ? {
                  command  := tab(find(" "))
                  move(1)
                  userID   := tab(find(" "))
                  move(1)
                  projName := tab(find(" "))
                  move(1)
                  fileName := tab(0)
                  }

               if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                               "files_activity"||PS||fileName||
                               "_changedlines.log", "r") then {
                  while l := read(log1) do {
                     if l ~== "" then {
                        l ? {
                           l_no := tab(find(":"))
                           move(1)
                           old_userID := tab(0)
                           }
                         }

                     commited_line_user_table[l_no] := old_userID
                     }
                  close(log1)
                  }
               if log2 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                               "files_activity"||PS||fileName||
                               "_changedlines_buffer.log", "w") then {
                  every l := key(commited_line_user_table) do {
                     write(log2, l||":"||commited_line_user_table[l])
                     }
                     close(log2)
                  }
              }
            "setFont"    : {
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  usr := tab(find(" "))
                  move(1)
                  newfont :=  tab(0)
                  }
               sendtoOne(usr, newfont, "setFont", userID)
               }
            "updateMode" : {
               user_mode_table := table("3D")
               
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  currMode :=  tab(0)
                  }
               if currMode === "Map" then
                  currMode := "3D"
               if log1 := open("dat"||PS|| "current_mode.log", "r") then {
                  while l := read(log1) do {
                     if l ~== "" then {
                        l ? {
                           usr := tab(find(" "))
                           move(1)
                           cmode := tab(0)
                           }
                        }
                     user_mode_table[usr] := cmode
                     }
                  if user_mode_table[userID] ~== currMode then {
                     logHandler.logUserActivity(userID, "Out "||user_mode_table[userID])
                     user_mode_table[userID] := currMode
                     logHandler.logUserActivity(userID, "In "||user_mode_table[userID])
                     }
                  close(log1)
                  }

               if log1 := open("dat"||PS|| "current_mode.log", "w") then {
                  every l := key(user_mode_table) do {
                     write(log1, l, " ", user_mode_table[l])
                     }
                  close(log1)
                  }
                }
            "checkMode" : {
               rmode := "3D"
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  requestedUser :=  tab(0)
                  }
               if log1 := open("dat"||PS|| "current_mode.log", "r") then {
                  while l := read(log1) do {
                     if l ~== "" then {
                        l ? {
                           usr := tab(find(" "))
                           move(1)
                           cmode := tab(0)
                           }
                        }
                     if usr == userID then
                        rmode := cmode
                     }
                  if /rmode then rmode := "3D"
                  close(log1)
                  }
               sendtoOne(requestedUser, userID||" is currently in "||
                   rmode||" mode.", "tell", requestedUser)
               }
            "updateChangedLines"  : {
               line_user_table := table()
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  projName := tab(find(" "))
                  move(1)
                  fileName := tab(find("&"))
                  move(1)
                  lineno :=  tab(0)
                  }

               if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                               "files_activity"||PS||fileName||
                               "_changedlines.log", "r") then {
                  while l := read(log1) do {
                     if l ~== "" then {
                        l ? {
                           l_no := tab(find(":"))
                           move(1)
                           old_userID := tab(0)
                           }
                         }
                        line_user_table[l_no] := old_userID
                     }
                  close(log1)
                  }

               line_user_table[lineno] := userID

               if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "files_activity"||PS||fileName||
                  "_changedlines_with_uncommitted("||
                  userID||").log", "a") then {
                  every l := key(line_user_table) do {
                     write(log1, l||":"||line_user_table[l])
                     }
                  close(log1)
                  }
               }

            "getUpdatedLines"  : {
               updatedlines_str := ""
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  userID := tab(find(" "))
                  move(1)
                  projName := tab(find(" "))
                  move(1)
                  fileName := tab(0)
                  }

               if log1 := open(PROJECT_GLOBALPATH||PS||projName||
                  PS||"files_activity"||PS||fileName||
                  "_changedlines.log", "r") then {
                  while l := read(log1) do
                     updatedlines_str ||:= l ||"&"
                  close(log1)
                  }

               every clines_file :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
                  !open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "files_activity")))))))) do {
                  if find( fileName||"_changedlines_with_uncommitted(",
                     clines_file) then {
                     if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                        "files_activity"||PS||clines_file, "r") then {
                        while l := read(log1) do {
                           #if l ~== "" then
                           updatedlines_str ||:= l ||"&"
                           }
                        if updatedlines_str ~== "" then
                           sendtoOne(userID, projName||" "||fileName||" "||
                              updatedlines_str,"getUpdatedLines", userID)
                        close(log1)
                        }
                     }
                  }
               }

            "getChangedLines" :{
               line_user_str := ""
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  lineno := tab(find(" "))
                  move(1)
                  projName := tab(find(" "))
                  move(1)
                  fileName := tab(0)
                  }
               if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
                               "files_activity"||PS||fileName||
                               "_changedlines.log", "r") then {

                  while l := read(log1) do {
                     if l ~== "" then {
                        l ? {
                           l_no := tab(find(":"))
                           move(1)
                           userID := tab(0)
                           }
                        if l_no == lineno then
                           line_user_str ||:= userID ||" ~ "
                        }
                     }
                  close(log1)
                  }
               sendtoOne(userID, lineno||" "||
                  line_user_str,"getUpdatedLines", userID)
               }
            "updatelocations" :{
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  username := tab(0)
                  }
               update_rooms_changed(username)
               update_3D_interactions(username, "ChangeLocation")

               every usr := !Tusername_user do
                  if (usr.get_activity_status()) ~== "Offline" then
                     sendtoOne(usr.name, all_users(usr.name), "allusers", usr.name)

               }
            "interactionsIn3D" :{
               buffer ? {
                  command := tab(find(" "))
                  move(1)
                  username := tab(find(" "))
                  move(1)
                  interactionType := tab(0)
                  }
               update_rooms_changed(username)
               update_3D_interactions(username, interactionType)

               every usr := !Tusername_user do
                     if (usr.get_activity_status()) ~== "Offline" then
                     sendtoOne(usr.name, all_users(usr.name), "allusers", usr.name)
               }
        ##
        ## Start pendings management commands
        ##
            "DELPending"      :{ del_pending_invitation(sock, buffer)}
            "FWDPendingSuggest": {fwd_pending_invitation(sock, buffer)}
        ##
        ## Start Collaborative IDE commands
        ##
            "RejectIDE"       :{ Decrement_IDE(buffer)               }
            "CETLaccept"      :{ CETL_New(sock, buffer,1)            }
            "CETLOpen"        :{ CETL_New(sock, buffer,2)            }
            "CETLevent"       :{ handle_CETL_Event(sock, buffer,0,1) }
            "SHLevent"        :{ handle_CETL_Event(sock, buffer,0,2) }
            "CETLCompile"     :{ handle_CETL_Event(sock, buffer,4)   }
            "CETLmouse"       :{ handle_CETL_Event(sock, buffer,1,1) }
            "SHLmouse"        :{ handle_CETL_Event(sock, buffer,1,2) }
            "CETLkey"         :{ handle_CETL_Event(sock, buffer,2,1) }
            "SHLkey"          :{ handle_CETL_Event(sock, buffer,2,2) }
            "CETLscrol"       :{ handle_CETL_Event(sock, buffer,3,1) }
            "SHLscrol"        :{ handle_CETL_Event(sock, buffer,3,2) }
            "CETLDeletefile"  :{ Delete_File_From_IDE(sock, buffer)  }
            "CETLSendUser"    :{ Send_Added_IDE_User(sock, buffer)   }
            "CETLLock"        :{ CETL_Lock_Request(sock, buffer)     }
            "CETLLockTransfer":{ CETL_Change_Owner(sock, buffer)     }
            "SHLResize"       :{ handle_CETL_Event(sock, buffer,5,)  }
            "SHLHighlight"    :{ handle_CETL_Event(sock, buffer,6,)  }
            "CETLPaste"       :{ handle_CETL_Event(sock, buffer,7,)  }
            "setIDESession"   :{ handle_session_creation(buffer)}
            "CETLStoreOutput" :{ handle_compile_output(buffer)}

        ##
        ## End Collaborative IDE commands
        ##

            #---- Start VoIP commands
            "vrequest":{   VoiceRequest(sock, buffer)      }
            "vaccept" :{   VoiceAccept(sock, buffer)       }
            "vreject" :{   VoiceReject(sock, buffer)       }
            "vhold"   :{   VoiceHold(sock, buffer)         }
            "vuhold"  :{   VoiceUnHold(sock, buffer)       }
            "vpend"   :{   VoiceEnd(sock, buffer,"vpend")  }
            "vphone"  :{   GetWhoInCellPhone(sock, buffer) }
            "vstate"  :{
               Tsock_user[sock].VoiceState := parsed[2]
               sendtoOne(username, Tsock_user[sock].VoiceState , "vstate", username)
            }
            "gvstate" :{
               sendtoOne(sock, Tsock_user[sock].VoiceState , "gvstate", sock)
            }
            "vroom"   :{  GetMyRoom(sock, buffer)         }
            "vlocal"  :{  GetWhoInMyRoom(sock, buffer)
                          GetWhoActiveInMyRoom(sock, buffer)
                       }
            "vlend"   :{  VoiceEnd(sock, buffer,"vlend")  }
            "avtroom" :{  GetWhoInMyRoom(sock, buffer)    }
            "vwho"    :{  sendtoOne(username, who_is_up(), "vwho", username) }
            "vrtalk"  :{  VoiceRequestDirectTalk(sock, buffer)  } # -- new voip
            "vtalk"   :{  VoiceDirectTalk(sock,buffer)  }
            "vend"    :{  VoiceEnd(sock, buffer,"vend")}
            "setip"   :{  Tsocket_drivers[sock].user.IP := parsed[2] }
            "vgetip"  :{  sendtoOne(username, user.IP, "say", username) }
            #---- End VoIP commands
            "inform": { sendtoMany( sock, parsed[2], UserCmd, 0 )   }
            "logout": { removeUser( sock )                          }
            #
            # obtain the dynamic state information and dump it to the user
            #
            "nodechange": {
                userToLoad := Tsock_user[sock]
                avtName := userToLoad.name
                params := Cmds.SplitArgs(parsed[2])
                oldNodeName := params[1]
                newNodeName := params[2]
                message := "\\inform "|| avtName || " leaves " ||
                    oldNodeName || " and enters " || newNodeName || "  "
                logHandler.logUserActivity(avtName, "Left " || oldNodeName ||
                                           " and entered " || newNodeName)
                sendtoMany(sock, message, "inform", sock,0)
                message := dynStHandler.getAdjDynamicState(Cmds,parsed[2],
                                                           sock,userToLoad)
                #logHandler.logit("Sending nodechange dyn state: "||message)
                sendtoOne(username, message, "dynstate", username)
                #---- For VoIP
                sendtoOne(username, dynStHandler.getMyRoom(Tsock_user[sock].
							   name),
                          "vchroom", username)
                }
            "possess":{
               write("server parsed",image(sock),UserCmd)
               write("parsed[2]",parsed[2])
               sendtoMany( sock, parsed[2], "possess", 1 )
               }
            "unpossess": {
               write("server parsed",image(sock),UserCmd)
               write("parsed[2]",parsed[2])
               sendtoMany( sock, parsed[2], "unpossess", 1 )
               }
            "switchobjectup": {
               write("server parsed",image(sock),UserCmd)
               write("parsed[2]",parsed[2])
               sendtoMany( sock, parsed[2], "switchobjectup", 1 )
               write("entred up")
               }
            "switchobjectdown": {
               write("server parsed",image(sock),UserCmd)
               write("parsed[2]",parsed[2])
               sendtoMany( sock, parsed[2], "switchobjectdown", 1 )
               write("entred down")
               }
	    "history":   {
	       user_history(username, buffer)
               update_3D_interactions(username, "History")
            }
	    "tell":   {
               tell( username, buffer )
            }
            "npcmsg":   {
               npcmsg( username, buffer )
            }

            "afk":    {
	       if Tsock_user[sock].set_afk() &
		  Tsock_user[sock].is_status("Online") then
		     sendtoMany( sock, parsed[2], "afk", 1 )
	       }
            "back":   {
	       if Tsock_user[sock].set_back(parsed[2]) then {
		  if Tsock_user[sock].is_status_not("Away") then
		     sendtoMany( sock, parsed[2], "back", 1 )
		  else # the user is not afk, but he wants to appear away
		     sendtoMany( sock, parsed[2], "afk", 1 )
		  }
	       }
            "ignore": { UpdateIgnoreList(sock, parsed[2], 1)      }
            "allow":  { UpdateIgnoreList(sock, parsed[2], 2)      }
            "who":    { sendtoOne(username, who_is_up(), "say", username) }
            "version":    {
               sendtoOne(username, version_check(parsed[2]), "say", username)
            }
            "groups": { sendtoOne(username, Tsock_user[sock].which_groups(),
                  "say", username) }
            "join":   { joinGroup(sock, parsed[2])                }
            #"disband":{ disbandGroup(net, args)                  }
            #"emote":  { sendEmote(net, sockets_t, users_l, args) }
            #"set":    { setDefaults(net, sockets_t, users_l, args)    }
            "transfer": {
               fileHandler.setConnection ( sessionConn(sock) )
               fileHandler.receiveFile( parsed[2] )
            }
            #"broadcast": {
            #     sendtoMany( sock, parsed[2], "say", 1 )
            #    }
            "uptime": { sendRaw(sock, logHandler.getUptime(), "say")   }
            "changereg": { regChange(sock, parsed[2])           }
            "passwd": { passwordChange(sock, parsed[2])                }
            "newuser": {
               if newuser(parsed[2]) then
                  sendRaw(sock, "new user creation succeeded", "success")
               else
                  sendRaw(sock, "new user creation failed", "failure")
            }
            "admin:list":   { userlist(sock)    }
            "admin:add":    { useradd(sock, parsed[2]) }
            "admin:remove": { userrem(sock)     }
            "admin:change": { userchange(sock)  }
            "admin:quit":   { shutdown()        }
            "getip": {
               if parsed[2] == "" then
                   sendtoOne(username, getIP( sock ), "say", username)
               else
                   sendtoOne(username, getIP( parsed[2] ), "say", username)
            }
          "fetchip" :{ sendtoOne(username, getIP( sock ), "fetchip", username) }
            default:  {
               if /UserCmd then return
               message := "Command " || UserCmd || " not implemented yet. "
$ifdef THREADS
                message @>> sock
$else
    		write(sock, message)
$endif
            }
         }
      }
   end

   #
   # passwordChange: invoked by \passwd (UNIX style) and expects a list of
   #                 arguments of length 2 (username oldpass newpass). It then
   #                 proceeds to change the user's password only if the old
   #                 one matched.
   #
   method passwordChange(sock, args)
      local params, username, oldpass, newpass, new_user, passuser

      params := Cmds.SplitArgs(args)

      username := params[1]
      oldpass  := params[2]
      newpass  := params[3]

      passuser:= getUser(username)
      sock := Tuser_sock[passuser]

      # what is wrong with this?
      if /username | /oldpass | /newpass then {
         sendRaw(sock, "Error: Syntax Error on \"" || args || "\"", "failure")
         fail
      }

      new_user := User(username,dynStHandler.srvSceneGraph.cveBuilder)
      if authenticate(username, oldpass, sock) then {
     # go ahead and change the password
     new_user.setPassword(newpass)
         sendRaw(sock, "Success: Password Changed for user " || username,
         "success")
     logHandler.logit("passwordChange(): password changed successfully " ||
              "for user " || username)
     return
         }

      logHandler.logit("passwordChange(): password not changed, " ||
               "user does not exist or password does not match")
      sendRaw(sock, "Error: Password not Changed. Unknown user or password " ||
              "does not match.", "failure")
      fail
   end

   #
   # changereg: invoked by \changereg (UNIX style) and expects a list
   #    of arguments of length 2 (username passwd fn ln emailId aff).
   #    It then proceeds to change the user's password only if the old
   #    one matched.
   #
   method regChange(sock, args)
      local params, username,pass,fn,ln,emailid,affiliation, new_user, reguser

      params := Cmds.SplitArgs(args)

      username := params[1]
      pass  := params[2]
      fn  := params[3]
      ln := params[4]
      emailid := params[5]
      affiliation := params[6]

      reguser:= getUser(username)
      sock := Tuser_sock[reguser]

      if /username | /pass | /fn | /ln | /emailid | /affiliation then {
         sendRaw(sock, "Error: Syntax Error on \"" || args || "\"", "failure")
         fail
         }

      new_user := User(username,dynStHandler.srvSceneGraph.cveBuilder)
      if authenticate(username, pass, sock) then {
         # go ahead and change the password
         new_user.setReginfo(fn,ln,emailid,affiliation)
         sendRaw(sock, "Success: Register info Changed for user " || username,
                 "success")
         logHandler.logit("ReginfoChange(): Reginfo changed successfully " ||
                          "for user " || username)
         return
      }

      logHandler.logit("regChange(): reginfo not changed, " ||
               "user does not exist or password does not match")
      sendRaw(sock, "Error: reginfo not Changed. Unknown user or password " ||
              "does not match.", "failure")
      fail
   end

   #
   # moveAvatar: reports avatar movement through UDP
   #
   method moveAvatar(sock, args)
      local av_port, r

      write("reading trial")
      while r := receive(listen_UDP_sock) do {
         write("inside")
         send(r.addr, "received: " || r.addr)
         write("done")
         }
      return
   end

   #
   #---------------------# Begin Collaborative IDE
   #
   method Swap_IDE_Owner(user,index)
       local Temp,j,found


      if \Tide[index] then {
         Temp := Tide[index].IDEOwner
	 Tide[index].IDEOwner := user
	 put(Tide[index].Lusers,Temp)
	 j := 1
	 found := 0
	 while (j <= *Tide[index].Lusers) & (found=0) do {
	    if Tide[index].Lusers[j] == user then {
	       found := 1
	       }
	    j +:= 1
	    }
	 if found = 1 then {
	    delete(Tide[index].Lusers,j-1)
            }
         }
   end

#
#Change the owner of the IDE and send changes to the all users
#
   method CETL_Change_Owner(sock_from, args)
      local params,user,table_index,Users,recipient,i,rec_obj, f
      local client := Tsocket_drivers[sock_from].user.name

      params := Cmds.SplitArgs(args)
      user:=  params[2]
      table_index:= integer(params[3])
      if \Tide[table_index] then {
         Users:=Tide[table_index].Lusers
         every i:=1 to  *Users do {
            recipient:=Users[i]
            if /recipient then {
               sendtoOne(client, "No recipient provided. Usage: " ||
               "\\tell user message", "say", client)
               return
               }
            if rec_obj := getUser(recipient) then {
               sendtoOne(recipient,table_index||" "||user,
			 "CETLLockTransfer", client)
               }
            else
               sendtoOne(client, "no such user is online: " || recipient,
			 "say", client)
            }
         Swap_IDE_Owner(user,table_index)
         if f := open(SESSION_GLOBALPATH||PS||"activities.log", "a") then {
            write(f, Tide[table_index].IDEFile||" --- "||user||" --- "||
		  ClockToSec(&clock)||" --- "||"Present"||" --- "||"Take Turn"||
		  " --- "||"NO"||" --- "||0)
            close(f)
            }
         }
   end
##
##   method Lock request
##
   method CETL_Lock_Request(sock_from, args)
        local recipient, params,user,index,rec_obj,client, sock_to, pinv

        client := Tsocket_drivers[sock_from].user.name

        params := Cmds.SplitArgs(args)
        recipient := params[2]
        user:=  params[3]
        index:= params[4]
        if /recipient then {
             sendtoOne(client, "No recipient provided. Usage: "||
                       "\\tell user message", "say", client)
             return
           }
        if rec_obj := getUser(recipient) then {
           sock_to := Tuser_sock[rec_obj]
           pinv := pending_invitation(SetUID(client[1]), client,
              "IDE: Take Turn", 1 , ClockToSec(&clock),
              "User "||user||" is requesting to take turn editing the session")
           new_pending_invitation(sock_from, pinv, sock_to)

           add_notification_record("Session/TakeTurn", params[3], params[2])
           if \rec_obj then
              sendtoOne(recipient, user||" "||index, "CETLLock", client)
           return
        }
        sendtoOne(client, "no such user is online: " || recipient, "say",
		  client)
   end
   #
   # handles the session records when logged in
   #
   method handle_session_records(userID, cTime)
      local f, log1, lst := [], sUser, sTime, eTime,
            sOwner, action, t_spent, l, fName, coutput,
            ts
      #
      # Code to update the "activities.log"
      #
      if f := open(SESSION_GLOBALPATH||PS||"activities.log", "r") then {
         while l := read(f) do {
            if find(userID||" --- ", l) &
               find("Present", l) then {
               l ? {
                  fName  := tab(find(" --- "))
                  move(5)
                  sUser  := tab(find(" --- "))
                  move(5)
                  sTime := integer(tab(find(" --- ")))
                  move(5)
                  eTime   := tab(find(" --- "))
                  move(5)
                  action    := tab(find(" --- "))
                  move(5)
                  coutput := tab(find(" --- "))
                  move(5)
                  t_spent   := integer(tab(0))
                  }

               if cTime > 0 then {
                  ts := cTime - sTime
                  }
               else if cTime = 0 then {
                  cTime := ClockToSec(&clock)
                  if (cTime - sTime) <= 360 then
                     ts := cTime - sTime
                  else
                     ts := 0
                  }

               l := fName||" --- "||sUser||" --- "||sTime||" --- "||
                    cTime||" --- "||action||" --- "||coutput||" --- "||ts
               }
            put(lst, l)
            }
         close(f)
         }
      if f := open(SESSION_GLOBALPATH||PS|| "activities.log", "w") then {
         every write(f, !lst)
         close(f)
         }
   end
   #
   #
   #
   method handle_session_activity(userID, fileName)
      local f, lst := [], sUser, startTime, endTime,
            sOwner, action, t_spent, l, fName, compile_output

      #
      # Code to update the "activities.log"
      #
      if f := open(SESSION_GLOBALPATH||PS|| "activities.log", "r") then {
         while l := read(f) do {
            if find(fileName||" --- ", l) &
               find("Present", l) then {
               l ? {
                  fName  := tab(find(" --- "))
                  move(5)
                  sUser  := tab(find(" --- "))
                  move(5)
                  startTime := tab(find(" --- "))
                  move(5)
                  endTime   := tab(find(" --- "))
                  move(5)
                  action    := tab(find(" --- "))
                  move(5)
                  compile_output := tab(find(" --- "))
                  move(5)
                  t_spent   := tab(0)
                  }
               l := fName||" --- "||sUser||" --- "||startTime||" --- "||ClockToSec(&clock)||
                  " --- "||action||" --- "||compile_output||" --- "||
                  (ClockToSec(&clock) - startTime)
               }
            put(lst, l)
            }
         close(f)
         }
      if f := open(SESSION_GLOBALPATH||PS|| "activities.log", "w") then {
         every write(f, !lst)
         close(f)
         }
      #
      # Code to update the fileName||"_activity_summary.log"
      #
      lst := []
      sOwner := getOwner(fileName, "session")
      if f := open(SESSION_GLOBALPATH||PS||fileName||"_activity_summary.log",
         "r") then {
         while l := read(f) do {
            if find(fileName||" --- ", l) then {
               l ? {
                  fName  := tab(find(" --- "))
                  move(5)
                  sUser  := tab(find(" --- "))
                  move(5)
                  startTime := tab(find(" --- "))
                  move(5)
                  endTime   := tab(find(" --- "))
                  move(5)
                  action    := tab(find(" --- "))
                  move(5)
                  t_spent   := tab(0)
                  }
               l := fName||" --- "||sUser||" --- "||startTime||" --- "||
                  ClockToSec(&clock)||" --- "||action||" --- "||
                  (ClockToSec(&clock) - startTime)
               }
            put(lst, l)
            }
         close(f)
         }
      if f := open(SESSION_GLOBALPATH||PS||fileName||"_activity_summary.log",
         "w") then {
         every write(f, !lst)
         close(f)
         }

   end
   #
   #
   #
   method handle_session_creation(args)
      local command, fName, sOwner, sWatcher, f,
        c_time := &clock, #time in hh:mm:ss format
        s_time := ClockToSec(c_time) # time in seconds

      args ? {
         command := tab(find(" "))
         move(1)
         fName   := tab(find(" "))
         move(1)
         sOwner   := tab(find(" "))
         move(1)
         sWatcher := tab(0)
         }
      if f := open(SESSION_GLOBALPATH||PS||"owners.log", "a") then {
         write(f, fName||" --- "||sOwner)
         close(f)
         }
      if f := open(SESSION_GLOBALPATH||PS||"activities.log", "a") then {
         write(f, fName||" --- "||sOwner||" --- "||s_time||" --- "||"Present"||
         " --- "||"Created"||" --- "||"NO"||" --- "||0)
         write(f, fName||" --- "||sWatcher||" --- "||s_time||" --- "||"Present"||
         " --- "||"Joined"||" --- "||"NO"||" --- "||0)
         close(f)
         }
      if f := open(SESSION_GLOBALPATH||PS||fName||"_activity_summary.log",
         "w") then {
         write(f, "File : "||fName)
         write(f, "Session Created  : "||c_time)
         write(f, "File Access Time : "||c_time)
         write(f, "-------------------------------------------")
         write(f, "Session Activity:")
         write(f, "-------------------------------------------")
         write(f, fName||" --- "||sOwner||" --- "||s_time||" --- "||"Present"||
         " --- "||"Created"||" --- "||"NO"||" --- "||0)
         write(f, fName||" --- "||sWatcher||" --- "||s_time||" --- "||
         "Present"||" --- "||"Joined"||" --- "||"NO"||" --- "||0)
         close(f)
         }
   end
   #
   #Send IDE events
   #
   method handle_CETL_Event(sock_from, args,event_type, obj_type)
      local recipient, params, rec_obj, client, pos, user_file_name,
	  sock_to, special_key, x_mouse, y_mouse, scrol_type, ev_type,
	  ev_param, tmp, file_name, table_index, Users:=[], i, owner,
	  compile_msg, cetl_type, highlightline, clipboard_contents, myevent,
	  times, command, f_name

      if event_type = 4 then {
         args ? {
            command := tab(find(" "))
            move(1)
            table_index := integer(tab(find(" ")))
            move(1)
            f_name := tab(find(" "))
            move(1)
            compile_msg := tab(0)
            }
         }
      if event_type = 6 then {
         args ? {
            command := tab(find(" "))
            move(1)
            table_index := integer(tab(find(" ")))
            move(1)
            highlightline := integer(tab(0))
            }
         }
      if event_type = 7 then {
         args ? {
            command := tab(find(" "))
            move(1)
            table_index := integer(tab(find(" ")))
            move(1)
            clipboard_contents := tab(0)
            }
         }
      else {
         params := Cmds.SplitArgs(args)
         if event_type = 0 then {
             args ? {
                command := tab(find(" "))
                move(1)
                table_index := integer(tab(find(" ")))
                move(1)
                myevent := tab(0)
                }
             }
         else {
            table_index:= integer(params[2])
            myevent:= params[3]
            }
         }

      if event_type = 1 then {
            x_mouse:= params[4]
            y_mouse:= params[5]
             }
      else if event_type = 2 then { #keypressed
            special_key:= params[4]
            }
      else if event_type = 3 then { #scrol
            args ? {
               command := tab(find(" "))
               move(1)
               table_index := integer(tab(find(" ")))
               move(1)
               myevent := integer(tab(find(" ")))
               move(1)
               ev_type := integer(tab(find(" ")))
               move(1)
               ev_param := tab(find(")"))||")" | -7
               move(2)
               scrol_type := tab(0)
               }
#            ev_type:= params[4]
#            ev_param := params[5]
#            scrol_type := params[6]
            }

      if \Tide[table_index] then {
            Users:=Tide[table_index].Lusers
	    owner:=Tide[table_index].IDEOwner
            every recipient := (!Users | owner) do {
                if /recipient then {
                    sendtoOne(sock_from, "No recipient provided. Usage: "||
			      "\\tell user message", "say", sock_from)
                    next
                 }
                if rec_obj := getUser(recipient) then {
                    client := Tsocket_drivers[sock_from].user.name
                    sock_to := Tuser_sock[rec_obj]
                    if sock_from === sock_to then {
                       #write(&errout, "skipping forwarding message from ",
                       #      client, " to themself")
                       next
                       }
                    #else write(&errout, "forwarding from ", client, " to ",
                    #           image(rec_obj.name))
                    if event_type = 1 then { #mouse
                        if obj_type = 1 then cetl_type := "CETLmouse"
                        if obj_type = 2 then cetl_type := "SHLmouse"

                        sendtoOne(sock_to, table_index ||" "||myevent||" "||
				  x_mouse||" "|| y_mouse, cetl_type, sock_from)
                        }
                    else if event_type = 2 then { #keypressed
                        if obj_type = 1 then cetl_type := "CETLkey"
                        if obj_type = 2 then cetl_type := "SHLkey"

                        sendtoOne(sock_to, table_index ||" "||myevent||" "||
				  special_key,cetl_type, sock_from)
                        }
                    else if event_type = 3 then { #scroll
                        if obj_type = 1 then cetl_type := "CETLscrol"
                        if obj_type = 2 then cetl_type := "SHLscrol"

                        sendtoOne(sock_to, table_index ||" "||myevent||" "||
				  ev_type||" "||ev_param||
				  " "||scrol_type, cetl_type,sock_from)
                        }
                    else if event_type == 4 then { #compiler
                        update_stats("Session/Debug")
                        update_user_stats("Session/Debug", owner)
                        update_session_activity(owner, f_name, compile_msg)
                        if \isPartner (recipient, owner, "project") then
                           update_partner_stats(table_index, "P", "Debug")
                        else if \isPartner (recipient, owner, "sig") then
                           update_partner_stats(table_index, "G", "Debug")
                        else update_partner_stats(table_index, "E", "Debug")

                        store_compile_msg(compile_msg, f_name)

                        sendtoOne(sock_to, table_index ||" "||compile_msg,
				  "CETLCompile", sock_from)
                      }
                    else if event_type == 5 then { #resize
                        sendtoOne(sock_to, table_index ||" ","SHLResize",
				  sock_from)
                      }
                    else if event_type == 6 then { #highlight
                        sendtoOne(sock_to, table_index ||" "||highlightline,
				  "SHLHighlight", sock_from)
                      }
                    else if event_type == 7 then { #clipboard contents
                        sendtoOne(sock_to, table_index ||" "||
				  clipboard_contents,"CETLPaste", sock_from)
                      }
                    else {#event
                        if obj_type = 1 then cetl_type := "CETLevent"
                        if obj_type = 2 then cetl_type := "SHLevent"
                        #must send {to_user(user name),table_index,event)
                        sendtoOne(sock_to, table_index||" "||\myevent,
				  cetl_type, sock_from)
                        }
                    }
                else
                   sendtoOne(sock_from, "no such user is online: " || recipient,
			     "say", sock_from)
             }#end every
          }
   end
   
   method handle_compile_output(buff)
      local fname, cmsg, cmd

      buff ? {
        cmd   := tab(find(" "))
        move(1)
        fname := tab(find(" "))
        move(1)
        cmsg := tab(0)
        }
      store_compile_msg(cmsg, fname)
   end

   method store_compile_msg(cmsg, fname)
      local lst := [], f, l

      cmsg ? {
	 while not(pos(0)) do {
	    l := tab(find("^n"))
	    move(2)
            put(lst, l)
            }
         }
      if f := open(SESSION_GLOBALPATH||PS||fname||
         "_output.log", "w") then {
         every write(f, !lst)
         close(f)
         }
   end

   method compare_compile_msg(cmsg)
      local lst := [], lst2 := [], is_correct := "NO",
         compile_output, f, l
      cmsg ? {
	 while not(pos(0)) do {
	    l := tab(find("^n"))
	    move(2)
            if \l ~=="" then
               put(lst, l)
            }
         }

      if f := open(SESSION_GLOBALPATH||PS||"session_output.log", "r") then {
         while l := read(f) do
            put(lst2, l)
         close(f)
         }
      if *lst > 0 then
      if find("512", lst[*lst-3]) &
         find("1024", lst[*lst-2]) &
         find("2048", lst[*lst-1]) then
         is_correct := "YES"

      return is_correct
   end

   method update_session_activity(userID, f_name, compile_msg)
      local fName, sUser, startTime, endTime, action, t_spent,
         compile_output, f, l, lst := []

      if f := open(SESSION_GLOBALPATH||PS||"activities.log", "r") then {
         while l := read(f) do {
            l ? {
               fName  := tab(find(" --- "))
               move(5)
               sUser  := tab(find(" --- "))
               move(5)
               startTime := tab(find(" --- "))
               move(5)
               endTime   := tab(find(" --- "))
               move(5)
               action    := tab(find(" --- "))
               move(5)
               compile_output := tab(find(" --- "))
               move(5)
               t_spent   := tab(0)
               }
            if find(f_name||" --- "||userID, l) then {
               if compare_compile_msg(compile_msg) === "YES" then {
                  l := fName||" --- "||sUser||" --- "||startTime||" --- "||
                       endTime||" --- "||action||" --- "||"YES"||" --- "||t_spent
                  }
               }
            put(lst, l)
            }
         close(f)
         }

      if f := open(SESSION_GLOBALPATH||PS||"activities.log", "w") then {
         every write(f, !lst)
         close(f)
         }
   end

   method update_3D_interactions(username, type)
      local found := &null, interactionType, log1,
         l, interactionsTbl := table(), times_done

      if log1 := open(USER_GLOBALPATH||PS||username||
		      PS||"interactions_in3D.log", "r") then {
         while l := read(log1) do {
            if l ~== "" then {
               l ? {
                  interactionType := tab(find(":"))
                  move(1)
                  times_done := integer(tab(0))
                  }
               if interactionType === type then {
                  found := 1
                  interactionsTbl[interactionType] := (times_done + 1)
                  }
               else
                  interactionsTbl[interactionType] := times_done
               }
            }
         close(log1)
         }

      if log1 := open(USER_GLOBALPATH||PS||username||
         PS||"interactions_in3D.log", "w") then {
         if *(\interactionsTbl) > 0 then {
            every l := key(interactionsTbl) do
               write(log1, l||":"||interactionsTbl[l])
            }
         if /found then
            write(log1, type||":"||1)
         close(log1)
         }
   end

   method update_rooms_changed(username)
      local found := &null, count:= 0,
         new_user, rname, log1, l, locs_changed := table(),
         room_name, times_visited

      if /(new_user := Tusername_user[username]) then fail
      rname := new_user.getRoom()

      if log1 := open(USER_GLOBALPATH||PS||username||
         PS||"locations.log", "r") then {
         count := read(log1)
         while l := read(log1) do {
            if l ~== "" then {
               l ? {
                  room_name := tab(find(":"))
                  move(1)
                  times_visited := integer(tab(0))
                  }
               if room_name === rname then {
                  found := 1
                  locs_changed [room_name] := (times_visited + 1)
                  }
               else
                  locs_changed [room_name] := times_visited
               }
            }
         close(log1)
         }

      if log1 := open(USER_GLOBALPATH||PS||username||
		      PS||"locations.log", "w") then {
         write(log1, count +1)
         if *(\locs_changed) > 0 then {
            every l := key(locs_changed) do
               write(log1, l||":"||locs_changed[l])
            }
         if /found then
            write(log1, rname||":"||1)
         close(log1)
         }
   end
   #
   # Returns a list of all friends and their locations
   #
   method all_users(userID)
      local allfriends_str := "", f, u, usr,
         others_str := "", npc_str := "", p

### AAA  fail this fucntion for now
      fail

      if f := open(USER_GLOBALPATH||PS||userID||PS|| "friends.log", "r") then {
         while u := read(f) do {
            if \(usr := Tusername_user[u]) then
                allfriends_str ||:=  u||":"||usr.getRoom()||"," 
            else
                allfriends_str ||:=  u||":OFFLINE," 
            }
         close(f)
         }

      every usr := !Tusername_user do
         if usr.user_type == "npc" then
            npc_str ||:=  usr.name||":"||usr.getRoom()||"," 
         else
            others_str ||:=  usr.name||":"||usr.getRoom()||"," 

      if allfriends_str ~== "" | others_str ~== "" | npc_str~==""then
         return allfriends_str||"~~"||npc_str||"~~"||others_str
   end

   method on_projfileOpen(projName, fileName, userID)
      local project_access_time, file_access_time, fd, fbuffer, f, l
      project_access_time := file_access_time := ClockToSec(&clock)


      if fd := open(PROJECT_GLOBALPATH||PS||projName||PS||projName ||
		    "_access.log", "a") then {
         write(fd,fileName||" "||userID||" "||file_access_time||" "||0)
         close(fd)
         }
 
      fbuffer := fileName || " " || projName || " "||project_access_time||
         " "||file_access_time||" "
      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
         PS||"files"||PS||fileName, "r") then {
         while l:= read(f) do
            fbuffer ||:= l || "xx1e"
         close(f)
         }
      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
		   "members_activity"||PS||"currently_working.log", "a") then {
         write(f, fileName||" "||userID||" "||file_access_time)
         close(f)
         }
      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
		   "files_activity"||PS||"files_activities.log", "a") then {
         write(f, fileName||" "||userID||" "||file_access_time||" "||"-----"||
            " "||"Opened")
         close(f)
         }
      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||"files_activity"||
		   PS||fileName||"_changedlines.log","w") then {
        close(f)
        }
      update_stats("Project/Access")
      update_stats("File/Open")
      update_user_stats("Project/Access", userID)
      update_user_stats("File/Open", userID)
      sendtoOne(userID, fbuffer, "projfileOpen", userID)
   end
   #
   # This method updates the statslog file
   #
   method update_stats(etype)
      local f, l, event_type, count, lst := []
      if f := open("dat" || PS || "stats.log", "r") then {
        while l := read(f) do {
           put(lst, l)
           }
        close(f)
        }
      if f := open("dat" || PS || "stats.log", "w") then {
         every l := !lst do {
            if find(etype, l) then {
               l ? {
                  event_type := tab(find(" "))
                  move(1)
                  count := integer(tab(0))
                  }
               l := event_type ||" "|| (count+1)
               }
            write(f, l)
            }
         close(f)
         }
   end
   #
   # This method updates the userID statslog file
   #
   method update_user_stats(etype, userID)
      local f, l, event_type, count, lst := []
      if f := open(USER_GLOBALPATH||PS||userID||PS||"stats.log", "r") then {
         while l := read(f) do {
            put(lst, l)
            }
         close(f)
         }
      if f := open(USER_GLOBALPATH||PS||userID||PS||"stats.log", "w") then {
         every l := !lst do {
            if find(etype, l) then {
               l ? {
                  event_type := tab(find(" "))
                  move(1)
                  count := integer(tab(0))
                  }
               l := event_type ||" "||(count+1)
               }
            write(f, l)
            }
         close(f)
         }
   end
   #
   # This method updates each file's updates count
   #
   method update_fileupdates_stats(pname, fname, userID)
      local f, l, f_name, u_id, count, lst := []
      if f := open(PROJECT_GLOBALPATH||PS||pname||PS|| "updaters.log") then {
         while put(lst, read(f))
         close(f)
         }
      if f := open(PROJECT_GLOBALPATH||PS||pname||PS||"updaters.log","w") then {
         every l := !lst do {
            if find(fname||" "||userID, l) then {
               l ? {
                  f_name := tab(find(" "))
                  move(1)
                  u_id := tab(find(" "))
                  move(1)
                  count := integer(tab(0))
                  }
               l := f_name||" "||u_id||" "||(count+1)
               }
            write(f, l)
            }
         close(f)
         }
   end

   #
   #
   #
   method add_members_communication_record(cType)
      local f, l, event_type, count, lst := [], fd

      if not stat("dat"||PS||"communication_stats.log") then {
         if fd := open("dat"||PS||"communication_stats.log", "w") then {
	    write(fd, "Email 0\nWall 0\nFeed 0\nChat 0\nSystemChat 0")
	    close(fd)
	    }
         }

      if f := open("dat" || PS || "communication_stats.log", "r") then {
        while l := read(f) do {
           put(lst, l)
           }
        close(f)
        }
      if f := open("dat" || PS || "communication_stats.log", "w") then {
         every l := !lst do {
            if find(cType, l) then {
               l ? {
                  event_type := tab(find(" "))
                  move(1)
                  count := integer(tab(0))
                  }
               l := event_type ||" "|| (count+1)
               }
            write(f, l)
            }
         close(f)
         }
   end
   #
   #
   #
   method add_notification_record(nType, uFrom, uTo)
      local f
      if f := open("dat"||PS||"notification_response.log", "a") then {
         write(f, nType||" "||uFrom||" "||uTo||" "||ClockToSec(&clock)||
	       " "||"----")
         close(f)
         }
   end
   #
   #
   #
   method update_notification_record(nType, uFrom, uTo)
      local l, f, nT, uF, uT, tStart, tSpent,
        lst := []
      if f := open("dat" ||PS|| "notification_response.log", "r") then {
         while l := read(f) do {
	    l ? {
               if find(nType||" "||((uFrom||" "||uTo)|(uTo||" "||uFrom))) then {
                  nT := tab(find(" "))
                  move(1)
                  uF := tab(find(" "))
                  move(1)
                  uT := tab(find(" "))
                  move(1)
                  tStart := tab(find(" "))
                  move(1)
                  tSpent := tab(0)
		  if tSpent === "----" then {
		     tSpent := ClockToSec(&clock) - tStart
		     l := nT||" "||uF||" "||uT||" "||tStart||" "||tSpent
                     }
                  }
	       }
            put(lst, l)
	    }
         close(f)
         }
      if f := open("dat"||PS|| "notification_response.log", "w") then {
         every write(f, !lst)
         close(f)
         }
   end
   #
   # This method updates partners' interactions stats
   #
   method update_partner_stats(objName, objType, etype)
      local f, l, f_name, u_id, count, event_type,
         lst := [], rec_found := 0

      if f := open("dat"||PS||"partner_stats.log", "r") then {
         while l := read(f) do {
            put(lst, l)
            }
         close(f)
         }
      if f := open("dat"||PS||"partner_stats.log", "w") then {
         every l := !lst do {
            if find(objName||" "||objType||" "||etype, l) then {
               l ? {
                  objName := tab(find(" "))
                  move(1)
                  objType := tab(find(" "))
                  move(1)
                  event_type := tab(find(" "))
                  move(1)
                  count := integer(tab(0))
                  }
               l := objName ||" "||objType ||" "||event_type ||" "||(count+1)
               rec_found := 1
               }
            write(f, l)
            }
         if rec_found == 0 then {
            count := 0
            write(f, objName ||" "||objType ||" "||etype ||" "||(count+1))
            }
         close(f)
         }
   end
   #
   #
   #
   method get_all_projects()
      local fname, lst := [], r, f := "", allprojectslst, projName, d
      allprojectslst := ""
      every projName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
         !open(PROJECT_GLOBALPATH)))))))) do {

         allprojectslst ||:=  projName || "("
         every fname :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
            !open(PROJECT_GLOBALPATH||PS||projName||PS||"files")))))))) do {
            r := stat(PROJECT_GLOBALPATH||PS||projName||PS||"files"||
               PS||fname)
            if r.mode[1] === "d" then {
               f ||:= fname||"[dir]["
               every d :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
                  !open(PROJECT_GLOBALPATH||PS||projName||PS||
                  "files"||PS||fname)))))))) do {
                  if d ~== ("appropriate_partner.log") &
                     d ~== ("appropriate_partner.log~") &
                     d ~== ("rooms_info.log") &
                     d ~== ("last_room.log") then f ||:= d || ","
                  }
               trim(f, ",", -1)
               f ||:= "]:"
               fname := f
               allprojectslst ||:=  fname
               }
            else allprojectslst ||:=  fname ||":"
            }
         trim(allprojectslst, ":", 0)
         allprojectslst ||:=  ")&&&"
         }
      return allprojectslst
   end

   method get_my_projects(userID)
      local myprojectslst:= "", projName, r
      every projName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
         !open(PROJECT_GLOBALPATH)))))))) do {
         r := stat(PROJECT_GLOBALPATH||PS||projName)
         if r.mode[1] === "d" then {
            if \isMember(projName, userID, "project") then {
               myprojectslst ||:=  projName || ","
               }
            else if \isOwner(userID, projName, "project") then {
               myprojectslst ||:=  projName || ","
               }
            }
         }

      return myprojectslst
   end

   method get_my_blocklist(userID)
      local f, blst := "", u
      if f := open(USER_GLOBALPATH||PS||userID||PS||"blocklist.log",
         "r") then {
         while u := trim(read(f)) do
            blst := u ||","
         close(f)
        }
      return blst
   end

   method get_my_friendsLocations(userID)
      local f, friend_loc_lst:="", u, usr

      if f := open(USER_GLOBALPATH||PS||userID||PS|| "friends.log", "r") then {
         while u := read(f) do {
            if \(usr := Tusername_user[u]) then
                 friend_loc_lst ||:=  u||" "||usr.getRoom()||"~" 
            else
                 friend_loc_lst ||:=  u||" OFFLINE~" 
            }
         close(f)
         }

      if /friend_loc_lst then
         friend_loc_lst := ""
      else trim(friend_loc_lst, " ", 0)

      return friend_loc_lst
   end

   method get_all_newsfeeds(user2)
      local allfeedslst, log1, feed_lbl, reply_lbl, line, line2,
         user1, ppriority, flbl, fpriority, orig_feed_lbl
      allfeedslst := ""
      every feed_lbl :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
                    !open(NEWSFEED_GLOBALPATH)))))))) do {
         feed_lbl ? {
            user1 := tab(find(" "))
            move(1)
            #ppriority := tab(find(" "))
            #move(1)
            flbl := tab(0)
            }

         orig_feed_lbl := feed_lbl
         fpriority := get_feed_priority(user1, user2)
         feed_lbl := user1||" "||fpriority||" "||flbl[1:-4]
         allfeedslst ||:=  feed_lbl|| "{"

         if log1 := open(NEWSFEED_GLOBALPATH||PS||orig_feed_lbl,"r") then {
            while \(line := read(log1)) do {
               line2 := read(log1)
               if \find("Replied >>>>", line) then {
                  if *line2 >= 30 then
                     reply_lbl := trim(line2[1:30], "$", 0)
                  else reply_lbl := trim(line2, "$", 0)
                  allfeedslst ||:=  reply_lbl || "@@"
                  }
               }
            close(log1)
            }

         trim(allfeedslst, "@", 0)
         allfeedslst ||:=  "} "
         }
      trim(allfeedslst, " ", 0)
      if allfeedslst~=="" then return allfeedslst
   end

   method get_feed_priority(user1, user2)
      local ppriority := "low"

      if \isFriend(user1, user2) then
         ppriority := "high"
#      else if \isPartner (user1, user2, "sig") then
#         ppriority := "high"
      else if \isPartner (user1, user2, "project") then
         ppriority := "high"
      else if \isFriend_Of_Friend (user1, user2) then
         ppriority := "medium"
      else ppriority := "low"

     return ppriority
   end

   method get_all_groups_and_members()
      local allgroupslst, grp, log1, usr, u
      allgroupslst := ""
      every grp :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
	 !open(GROUP_GLOBALPATH)))))))) do {
         allgroupslst ||:=  grp || "("
         if log1 := open(GROUP_GLOBALPATH||PS||grp||PS||
                         "members.log","r") then {
            while usr := read(log1) do {
               if \(u:=Tusername_user[usr]) then
                  allgroupslst ||:=  usr || ":" ||u.get_activity_status(0) ||","
               else
                  allgroupslst ||:=  usr || ":Offline,"
               }
            close(log1)
            }
         # This part adds the owner as a child to each group node
         if log1 := open(GROUP_GLOBALPATH||PS||grp||PS||
                         "owner.log","r") then {
            usr := read(log1)
            if usr ~== "system" then {
               if \(u:=Tusername_user[usr]) then
                  allgroupslst ||:= usr||":"||u.get_activity_status(1)||
                     "_owner,"
               else
                  allgroupslst ||:= usr||":Offline_owner,"
               }
            close(log1)
            }

         trim(allgroupslst, ",", 0)
         allgroupslst ||:=  ") "
         }
      trim(allgroupslst, " ", 0)
      if allgroupslst~=="" then return allgroupslst
   end
   #
   #
   #
   method Invite_to_join(sock_from, args, objType)
      local params, command, recipient, sigName, rec_obj := &null,
         client, sock_to, pinv

      params := Cmds.SplitArgs(args)
      recipient := \params[2]
      if /recipient then {
         sendtoOne(sock_from, "No recipient provided. Usage: "||
                   "\\tell user message", "say", sock_from)
         return
         }
      rec_obj := getUser(recipient)

      client := Tsocket_drivers[sock_from].user.name

      if objType === "sig" then {
         if \rec_obj then
            sock_to := Tuser_sock[rec_obj]
         #else
         #   sock_to := getOwner(params[3], "sig")

         pinv := pending_invitation(SetUID(client[1]),
            client, "Group Invitation", 1 , ClockToSec(&clock), recipient||
            ", "||client||" invited you to join~group:"||params[3])

         add_notification_record("Group/Join", params[2], params[4])

         new_pending_invitation(sock_from, pinv, sock_to)
         if \rec_obj then
            sendtoOne(sock_from, params[2]||" "||params[3]||" "||params[4],
            "groupInvite", sock_to)
         }
      else if objType === "project" then {
         if \rec_obj then
            sock_to := Tuser_sock[rec_obj]
         #else
         #   sock_to := getOwner(params[3], "project")

         pinv := pending_invitation(SetUID(client[1]),
            client, "Project Invitation", 1 , ClockToSec(&clock), recipient||
            ", "||client||" invited you to join~project:"||params[3])

         add_notification_record("Project/Join", params[2], params[4])

         new_pending_invitation(sock_from, pinv, sock_to)
         if \rec_obj then
            sendtoOne(sock_to, params[2]||" "||params[3]||" "||params[4]||
            " "||params[5], "projectInvite", sock_from)
         }
      sendtoOne(sock_from, "A group/project invitation has been sent to "||
         recipient||".", "tell", sock_from)
   end
   #
   # Request to join group/project
   #
   method join_request(sock_from, new_member, objName, objOwner, objType)
      local rec_obj, client, sock_to, pinvType, msg, cmd, pinv
      rec_obj := (getUser(objOwner))

      client := Tsocket_drivers[sock_from].user.name
      sock_to := Tuser_sock[rec_obj]
      if objType === "sig" then {
         pinvType := "Join Group"
         msg := new_member ||" is interested in joining~group:"||
                objName
         cmd := "groupJoin"
         if objName === ("cpp"|"java"|"unicon"|"se&uml") then {
            sendtoOne(new_member, 0||" "||new_member||" "||objName||" "||
               objOwner, cmd, objOwner)
            }
         else {
            pinv := pending_invitation(SetUID(client[1]), client, pinvType,
               1 , ClockToSec(&clock), msg)
            new_pending_invitation(sock_from, pinv, sock_to)

            add_notification_record("Group/Join", new_member, objOwner)
            if \rec_obj then
               sendtoOne(objOwner, 1||" "||new_member||" "||objName||" "||
                  objOwner, cmd, new_member)
            }
         }
      else if objType === "project" then {
         pinvType := "Join Project"
         msg := new_member ||" is interested in joining~project:"||
                objName
         cmd := "projectJoin"
         pinv := pending_invitation(SetUID(client[1]), client, pinvType,
            1 , ClockToSec(&clock), msg)
         new_pending_invitation(sock_from, pinv, sock_to)

         add_notification_record("Project/Join", new_member, objOwner)
         if \rec_obj then
            sendtoOne(objOwner, new_member||" "||objName||" "||
               objOwner, cmd, new_member)
         }

      if objName === ("cpp"|"java"|"unicon"|"se&uml") then {
         if objType === "sig" then
            sendtoOne(sock_from, "You have joined the "||
               objName||" interest group.", "tell", sock_from)
         else
            sendtoOne(sock_from, "You have joined the "||
            objName||" project.", "tell", sock_from)
         }
      else
         sendtoOne(sock_from, "A group/project request has been sent to "||
            objOwner||".", "tell", sock_from)
   end

   method getWallInfo(objName, objType)
      local wall_str := "", number_of_posts := 0,
         postName, log1, u, datPath, mdate,
         mdateLst := [], # modified dates list
         sorted_mdateLst := [], # sorted list
         sorted_mdateTbl := table(), # sorted table
         mdate_Lst := [], # list of the most recent modified posts (4 posts)
         mdate_Set := set(), # set of the most recent modified posts (4 posts)
         total_members := 0, online_members := 0, objInfo,
         objlst, objDesc, usr

      if objType === "sig" then
         datPath := GROUP_GLOBALPATH
      else datPath := PROJECT_GLOBALPATH
      every postName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
         !open(datPath||PS||objName||PS||"Wall")))))))) do {
         if log1 := open(datPath||PS||objName||PS||
            "Wall"||PS||postName, "r") then {
            mdate := (stat(log1)).mtime # modified date
            put(mdateLst, mdate)
            }
         }

      sorted_mdateLst := sortf(mdateLst) #sorted list
      mdate_Lst := sorted_mdateLst[-4|-3|-2|-1:0]
      mdate_Set := set(mdate_Lst)

      if objType === "sig" then {
         every postName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
            !open(datPath||PS||objName||PS||"Wall")))))))) do {

            if log1 := open(datPath||PS||objName||PS||
               "Wall"||PS||postName, "r") then {
               mdate := (stat(log1)).mtime
               close(log1)
               }
            if member(mdate_Set, mdate) then {
               wall_str ||:= postName ||"<<<"
               number_of_posts +:= 1
               if log1 := open(datPath||PS||objName||PS||
                  "Wall"||PS||postName, "r") then {
                  while u := read(log1) do {
                     if u ~== "" then
                        wall_str ||:= u ||"@@@"
                     }
                  close(log1)
                  }
#               trim(wall_str, "@@@", 0)
               wall_str ||:= ">>>"
               }
            }
         }
      else if objType === "project" then {
         every postName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
            !open(datPath||PS||objName||PS||"Wall")))))))) do {
            mdate := (stat(postName)).mtime
            if member(mdate_Set, mdate) then {
               wall_str ||:= postName ||"<<<"
               number_of_posts +:= 1
               if log1 := open(datPath||PS||objName||PS||
                  "Wall"||PS||postName, "r") then {
                  while u := read(log1) do {
                     if u ~== "" then
                        wall_str ||:= u ||"@@@"
                     }
                  close(log1)
                  }
               wall_str ||:= ">>>"
               }
            }
         }

         objlst := "{"
         if log1 := open(datPath||PS||objName||PS||
                         "members.log","r") then {
            while usr := read(log1) do {
               total_members +:= 1
               if \(u:=Tusername_user[usr]) then {
                  objlst ||:=  usr || ":" ||u.get_activity_status(0) ||","
                  online_members +:= 1
                  }
               else
                  objlst ||:=  usr || ":Offline,"
               }
            close(log1)
            }
         if log1 := open(datPath||PS||objName||PS||
                         "owner.log","r") then {
            usr := read(log1)
            total_members +:= 1
            if \(u:=Tusername_user[usr]) then {
               objlst ||:=  usr || ":" ||u.get_activity_status(0) ||","
               online_members +:= 1
               }
            else
               objlst ||:=  usr || ":Offline,"
            close(log1)
            }
         trim(objlst, ',', 0)
         objlst ||:=  "}"

      objDesc := "Description is not added yet."
      objInfo := "{"||online_members||"/"||total_members||"}"
      wall_str := number_of_posts||objInfo||wall_str
      return wall_str
   end

   method isMember(objName, userID, objType)
      local log1, u, ismember := &null
      if objType === "sig" then {
         if log1 := open(GROUP_GLOBALPATH||PS||objName||PS||
                         "members.log", "r") then {
            while u := read(log1) do
               if u == userID then ismember := 1
            close(log1)
            }
         }
      else if objType === "project" then {
         if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                         "members.log", "r") then {
            while u := read(log1) do
               if u == userID then ismember := 2
            close(log1)
            }
         }
      return ismember
   end

   method isFriend(userID, newfriend)
      local usr
     if \(usr := Tusername_user[userID]) then
        return usr.isFriend(newfriend)
   end
   #
   # Checks if the first user is in the
   # second's user block list
   #
   method isBlocked(first_user, second_user)
      local log1, u, isblocked := &null, f
      if f := open(USER_GLOBALPATH||PS||second_user||PS||
         "blocklist.log", "r") then {
         while u := trim(read(f)) do {
            if u === first_user then isblocked := 1
            }
         close(f)
         }
      return isblocked
   end
   #
   #
   #
   method friendsList(userID)
      local usr, friendslst := []

      if \(usr := Tusername_user[userID]) then
         every put( friendslst,  !(usr.friends))

      return friendslst
   end
   #
   #
   #
   method partnersList(userID)
      local log1, f, partnerslst := set(), u, objName

      every objName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
         !open(GROUP_GLOBALPATH)))))))) do {
         if \isMember(objName, userID, "sig") |
            \isOwner(userID, objName, "sig") then {
	    if f := open(GROUP_GLOBALPATH||PS||objName||PS||"members.log", "r")
	    then {
               while u := read(f) do {
                  insert(partnerslst, u)
                  }
               close(f)
               }
            if f := open(GROUP_GLOBALPATH||PS||objName||PS||"owner.log", "r")
	    then {
               insert(partnerslst, u := read(f))
               close(f)
               }
            }
         }

      every objName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
         !open(PROJECT_GLOBALPATH)))))))) do {
         if \isMember(objName, userID, "project") |
            \isOwner(userID, objName, "project") then {
            if f := open(PROJECT_GLOBALPATH||PS||objName||PS||"members.log","r")
	    then {
               while u := read(f) do {
                  insert(partnerslst, u)
                  }
               close(f)
               }
            if f := open(PROJECT_GLOBALPATH||PS||objName||PS||"owner.log", "r")
	    then {
               insert(partnerslst, u:= read(f))
               close(f)
               }
            }
         }

      return partnerslst
   end

   #
   #
   #
   method blockList(userID)
      local log1, f, blocklst := []
      if log1 := open(USER_GLOBALPATH||PS||userID||PS||
                      "blocklist.log", "r") then {
         while f := trim(read(log1)) do
            put(blocklst, f)
         close(log1)
         }
      return blocklst
   end
   #
   #
   #
   method isOwner(userID, objName, objType)
      local log1, u, isowner := &null
      if objType === "sig" then {
         if log1 := open(GROUP_GLOBALPATH||PS||objName||PS||
                         "owner.log", "r") then {
            u := read(log1)
            if \u then
               if u == userID then isowner := 1
            close(log1)
            }
         }
      else if objType === "project" then {
         if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                         "owner.log", "r") then {
            u := read(log1)
            if \u then
               if u == userID then isowner := 1
            close(log1)
            }
         }
      return isowner
   end

   #
   # Check if first_user and second_user are
   # project or group partners
   #
   method isPartner (first_user, second_user, objType)
      local objDir, objName, ispartner := &null
      if objType == "sig" then {
         every objName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
            !open(GROUP_GLOBALPATH)))))))) do {
            if \isMember(objName, first_user, objType) &
               \isMember(objName, second_user, objType) then {
               ispartner := 1
               }
            }
         }
      else if objType == "project" then {
         every objName :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
            !open(PROJECT_GLOBALPATH)))))))) do {
            if \isMember(objName, first_user, objType) &
               \isMember(objName, second_user, objType) then {
               ispartner := 1
               }
            }
         }
      return ispartner
   end

   #
   # Check if first_user and second_user have a
   # friend of a friend relation
   #
   method isFriend_Of_Friend (first_user, second_user)
      local f, isfriend_of_friend := &null
      every f := !(friendsList(second_user)) do {
         if isFriend(first_user, f) then
            isfriend_of_friend := 1
         }
      return isfriend_of_friend
   end

   method getOwner(objName, objType)
      local log1, owner := &null, u, l, fname
      if objType === "sig" then {
         if log1 := open(GROUP_GLOBALPATH||PS||objName||PS||
                         "owner.log", "r") then {
            owner := read(log1)
            close(log1)
            }
         }
      else if objType === "project" then {
         if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                         "owner.log", "r") then {
            owner := read(log1)
            close(log1)
            }
         }
      else if objType === "session" then {
         if log1 := open(SESSION_GLOBALPATH||PS||
            "owners.log", "r") then {
            while l:= read(log1) do
              if find(objName, l) then {
                 l ? {
                    fname := tab(find(" --- "))
                    move(5)
                    owner := tab(0)
                    }
                 }
            close(log1)
            }
         }
      return owner
   end

   method change_lastRoom_coordinates(roomCoords)
      local rx, ry, rz, rw, rl, rh, log1
      if /roomCoords then
         roomCoords := "1000 1000 200 25 25 25"
      roomCoords ? {
          rx := tab(find(" "))
          move(1)
          ry := integer(tab(find(" "))) + 26
          move(1)
          rz := tab(find(" "))
          move(1)
          rw := tab(find(" "))
          move(1)
          rl := tab(find(" "))
          move(1)
          rh := tab(0)
          }
       if log1 := open(PROJECT_GLOBALPATH||PS||
          "lastroom.log", "w") then {
          write(log1, rx||" "||ry||" "||rz||" "||rw||" "||rl||" "||rh)
          close(log1)
          }
   end

   method set_Member_Color(objName, userID, member_color)
      local log1, lst := [], lst2 := [], l, findr := &null
      if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                      "member_color.log", "r") then {
         while l := read(log1) do {
             put(lst, l)
             }
         if *lst >= 1 then
         every l := !lst do {
            if find(userID, l) then {
               l := userID||":"||member_color
               findr := 1
               }
            put(lst2, l)
            }
         if findr === &null then
            put(lst2, userID||":"||member_color)
         close(log1)
         }

      if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                      "member_color.log", "w") then {
         every l := !lst2 do {
            write(log1, l)
            }
         close(log1)
         }
   end

   method getMemberColorList(objName)
      local log1, l, c := ""
      if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                      "member_color.log", "r") then {
         while l := read(log1) do
             c ||:= l || ","
         close(log1)
         }
      return c
   end

   method getMemberTimeList(objName)
      local log1, l, tbl := table(0),
         c := "", uId, tSpent, uColor

      if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                      objName||"_spent_time.log", "r") then {
         while l := read(log1) do {
             l ? {
                uId := tab(find(":"))
                move(1)
                tSpent := tab(0)
                }
             if /tSpent then tSpent := 0
             tbl[uId] := tSpent
             }
         close(log1)
         }

      if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                      "member_color.log", "r") then {
         while l := read(log1) do {
            l ? {
               uId := tab(find(":"))
               move(1)
               uColor := tab(0)
               }
            c ||:= uId||":"||uColor||":"||tbl[uId]||","
            }
         close(log1)
         }

      return c
   end

   # get the time user spent in each project
   method getMemberProgress(userID)
      local log1, l, tbl_time := table(0), tbl_color := table(0),
         c := "", uId, tSpent, total_spent, uColor, projName

      every projName := ("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
         !open(PROJECT_GLOBALPATH)))))))) do {
         total_spent := 0
         if projName ~== "appropriate_partner.log" &
            projName ~== ("appropriate_partner.log~") then {
         if projName ~== "rooms_info.log" &
            projName ~== "lastroom.log" then {

         if \isMember(projName, userID, "project") |
            \isOwner(userID, projName, "project") |
            \getPermission(projName, "project") === "Public" then {

            if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
               projName||"_spent_time.log", "r") then {
               while l := read(log1) do {
                  l ? {
                     uId := tab(find(":"))
                     move(1)
                     tSpent := tab(0)
                     }
                  if /tSpent then tSpent := 0
                  if uId === userID then
                     tbl_time[projName] := tSpent
                  total_spent +:= tSpent
                  }
               close(log1)
               }
            if log1 := open(PROJECT_GLOBALPATH||PS||projName||PS||
               "member_color.log", "r") then {
               while l := read(log1) do {
                  l ? {
                     uId := tab(find(":"))
                     move(1)
                     uColor := tab(0)
                     }
                  if uId === userID then
                     tbl_color[projName] := uColor
                  }
               close(log1)
               }

            c ||:= projName||":"||tbl_color[projName]||":"||tbl_time[projName]||
                   ":"||total_spent||","
            }
            }
            }
         }
      return c
   end


   method setOwner(objName, objOwner, objType)
      local log1
      if objType === "sig" then {
         if log1 := open(GROUP_GLOBALPATH||PS||objName||PS||
                         "owner.log", "w") then {
            write(log1, objOwner)
            close(log1)
            }
         }
      else if objType === "project" then {
         if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                         "owner.log", "w") then {
            write(log1, objOwner)
            close(log1)
            }
         }
   end
   #
   # Check if user_id is allowed to access profile_id's
   # profile, project, newsfeed

   method isAllowed(profile_id, user_id, permission, objType)
      local isallowed := &null

      if profile_id === user_id then
         isallowed := 1
      else if /isBlocked(user_id, profile_id) then   {
            if permission === ("Everyone" | "Public") then
               isallowed := 1
            else if \isFriend(profile_id, user_id) &
                    permission === "Friends" then
               isallowed := 1
            else if \isPartner (profile_id, user_id, objType) then
               isallowed := 1
            else isallowed := &null
         }

      return isallowed
   end

   #
   # Here objName depends on objType
   #      objType = sig --> objName = sigName
   #      objType = profile --> objName = userID
   #
   method setPermission(objName, permission, objType)
      local log1, lst := [], l
      if objType === "sig" then {
         if log1 := open(GROUP_GLOBALPATH||PS||objName||PS||
                         "permissions.log", "w") then {
            write(log1, permission)
            close(log1)
            }
         }
      else if objType === "project" then {
         if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                         "proj_info.log", "r") then {
            put(lst, l)
            close(log1)
            }

         if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                         "proj_info.log", "w") then {
            every l := !lst do {
               if \find("Privacy", l) then
                  l := "Privacy: "||permission
               write(log1, l)
               }
            close(log1)
            }
         }
      else if objType === "profile" then {
         if log1 := open(USER_GLOBALPATH||PS||objName||PS||
                         "permissions.log", "w") then {
            write(log1, permission)
            close(log1)
            }
         }
   end
   #
   # Permission is either Private, Public, or
   # Friends
   #
   method getPermission(objName, objType)
      local l, log1, permission := "Public", p
      if objType === "sig" then {
         if log1 := open(GROUP_GLOBALPATH||PS||objName||PS||
                         "permissions.log", "r") then {
            permission := read(log1)
            close(log1)
            }
         }
      else if objType === "project" then {
         if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                         "proj_info.log", "r") then {
            while l := read(log1) do {
               if find("Privacy", l) then {
                  l ? {
                     p := tab(find(" "))
                     move(1)
                     permission := tab(0)
                     }
                  }
               }
            close(log1)
            }
         }
      else if objType === "profile" then {
         if log1 := open(USER_GLOBALPATH||PS||objName||PS||
                         "account_settings.log", "r") then {
            while p := read(log1)
            if find("Privacy", p) then {
               p? {
                  tab(find("= "))
                  move(2)
                  permission := tab(0)
                  }
               }
            close(log1)
            }
         }
      return permission
   end

   method getprojectFiles(projName)
      local fname, lst := [], r, f :="", d
      .
      every fname :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
         !open(PROJECT_GLOBALPATH||PS||projName||PS||"files")))))))) do {
         r := stat(PROJECT_GLOBALPATH||PS||projName||PS||"files"||PS||fname)
         if r.mode[1] === "d" then {
            f ||:= fname||"[dir]["
            every d :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
              !open(PROJECT_GLOBALPATH||PS||projName||PS||
              "files"||PS||fname)))))))) do {
              f ||:= d || ":"
              }
            trim(f, ":", -1)
            f ||:= "]"
            fname := f
            put(lst, fname )
            }
         else put(lst, fname)
         }
      return lst
   end

   #User usage IDE vs 3D
   method getUserUsage(userID, flag)
      local log1, l, u, in_day, out_day, ahour_start, ahour_end, lrem,
         trem, start_t, end_t, tperiod,amin_start, asec_start,
         amin_end, asec_end,str, str2, tIDEDays, t3DDays, tAFKDays,
         afk_time, uTMinutes, munit, uLDays, d, h, m, tspent, 
         tspent_1st_hr, tspent_last_hr, hrs_diff, hrs_between, 
         i, f, lst, lst_3d, lst_ide, lst_ide_old, lst_3d_old, k, in, 
         out, lstmode, lMsg, aday, lst_sn, lst_sn_old, tSNDays, lday,
         ltime, lact, lmode, ntime

      munit := 10 #meature unit

      uLDays := ["Sunday", "Monday", "Tuesday", "Wednesday",
                 "Thursday", "Friday", "Saturday"]
      tIDEDays := table(0)
      t3DDays  := table(0)
      tSNDays  := table(0)
      every tIDEDays[!uLDays] := 0
      every t3DDays[!uLDays] := 0
      every tSNDays[!uLDays] := 0
      
      lst_ide_old := list() #list to store IDE records
      lst_3d_old  := list() #list to store 3D records
      lst_sn_old  := list() #list to store SN records
      lst_ide := list() #list to store IDE records
      lst_3d  := list() #list to store 3D records
      lst_sn  := list() #list to store SN records
      lst := list()
  
      lMsg := &dateline
      lMsg ? {
         aday := tab(find(",")) #activity day
         move(1)
         }
 
      if log1 := open(USER_GLOBALPATH||PS||userID||
         PS||"ide_3d_activity.log", "r") then {

         while l := read(log1) do {
            if find("Map", l) then {
               l ? {
                  lday := tab(find(" "))
                  move(1)
                  ltime := tab(find(" "))
                  move(1)
                  lact := tab(find(" "))
                  move(1)
                  lmode := tab(0)
                  }
               l := lday||" "||ltime||" "||lact||" 3D"
               }
            put(lst, l)
            }

         if find("3D", lst[*lst]) then
            put(lst_3d, aday||" "||&clock||" "||"Out 3D")
         else if find("Editor", lst[*lst]) then
            put(lst_ide, aday||" "||&clock||" "||"Out Editor")
         else if find("Profile", lst[*lst]) then 
            put(lst_ide, aday||" "||&clock||" "||"Out Profile")
         else if find("Wall", lst[*lst]) then 
            put(lst_ide, aday||" "||&clock||" "||"Out Wall")
  
         every i := 1 to (*lst) do {
            if find("In Editor" | "Out Editor", lst[i]) then
               put(lst_ide, lst[i])
            else if find("In 3D" | "Out 3D", lst[i]) then
               put(lst_3d, lst[i])
            else put(lst_sn, lst[i])
            }
         close(log1)
         }
      #
      # Ordering the IDE in/out records
      #
      in := 0
      out := 0
      k := 1
      every l := !lst_ide do {
         if find("In Editor", l) & in = 0 then {
            put(lst_ide_old, l)
            in := 1
            out := 0
            }
         else if find("Out Editor", l) & in = 1 then {
            put(lst_ide_old, l)
            in := 0
            out := 1
            }
         }
      #
      # Cleaning the 3D in/out records
      #       
      in := 0
      out := 0
      k := 1
      every l := !lst_3d do {
         if find("In 3D", l) & in = 0 then {
            put(lst_3d_old, l)
            in := 1
            out := 0
            }
         else if find("Out 3D", l) & in = 1 then {
            put(lst_3d_old, l)
            in := 0
            out := 1
            }
         }
      #
      # Cleaning the SN in/out records
      #       
      in := 0
      out := 0
      k := 1
      every l := !lst_sn do {
         if find("In ", l) & in = 0 then {
            put(lst_sn_old, l)
            in := 1
            out := 0
            }
         else if find("Out ", l) & in = 1 then {
            put(lst_sn_old, l)
            in := 0
            out := 1
            }
         }

      lst_ide := copy(lst_ide_old)
      lst_3d  := copy(lst_3d_old)
      lst_sn  := copy(lst_sn_old)
      #
      #Parsing the IDE records
      #
      m := 1
      while m < *lst_ide do {
         # parse the Logged In line
         lst_ide[m] ? {
            in_day := tab(find(" "))
            move(1)
            start_t := tab(find(" "))
            move(1)
            lrem := tab(0)
            }
         start_t ? {
            ahour_start := integer(tab(find(":")))
            move(1)
            amin_start  := integer(tab(find(":")))
            move(1)
            asec_start  := integer(tab(0))
            }

         # parse the Logged Out line
         lst_ide[m+1] ? {
            out_day := tab(find(" "))
            move(1)
            end_t := tab(find(" "))
            move(1)
            lrem := tab(0)
            }
         end_t ? {
            ahour_end := integer(tab(find(":")))
            move(1)
            amin_end  := integer(tab(find(":")))
            move(1)
            asec_end  := integer(tab(0))
            }
         if in_day == out_day then { #in and out in same day
            if ahour_start = ahour_end then { #in and out in the same hour
               tspent := (amin_end - amin_start)
               tIDEDays[in_day] +:= tspent
               }
            else { #in and out in different hours
               tspent_1st_hr := 60 - amin_start
               tIDEDays[in_day] +:= tspent_1st_hr
               tspent_last_hr := 60 - amin_end
               tIDEDays[in_day] +:= tspent_last_hr
               hrs_diff := ahour_end - ahour_start
               if hrs_diff > 1 then {
                  hrs_between := hrs_diff - 1
                  every i := (ahour_start + 1) to (ahour_start + hrs_between) do
                     tIDEDays[in_day] +:= 60
                  }
               }
            }
         else { #in and out in different days
            tspent_1st_hr := 60 - amin_start
            tIDEDays[in_day] +:= tspent_1st_hr
            every i := (ahour_start + 1) to 24 do
               tIDEDays[in_day] +:= 60
            every i := 1 to (ahour_end - 1) do
               tIDEDays[out_day] +:= 60

            tspent_last_hr := 60 - amin_end
            tIDEDays[out_day] +:= tspent_last_hr
            }
         m +:= 2
         }
      #
      #Parsing the 3D records
      #
      m := 1
      while m < *lst_3d do {
         # parse the Logged In line
         lst_3d[m] ? {
            in_day := tab(find(" "))
            move(1)
            start_t := tab(find(" "))
            move(1)
            lrem := tab(0)
            }
         start_t ? {
            ahour_start := integer(tab(find(":")))
            move(1)
            amin_start  := integer(tab(find(":")))
            move(1)
            asec_start  := integer(tab(0))
            }

         # parse the Logged Out line
         lst_3d[m+1] ? {
            out_day := tab(find(" "))
            move(1)
            end_t := tab(find(" "))
            move(1)
            lrem := tab(0)
            }
         end_t ? {
            ahour_end := integer(tab(find(":")))
            move(1)
            amin_end  := integer(tab(find(":")))
            move(1)
            asec_end  := integer(tab(0))
            }
         if in_day == out_day then { #in and out in same day
            if ahour_start = ahour_end then { #in and out in the same hour
               tspent := (amin_end - amin_start)
               t3DDays[in_day] +:= tspent
               }
            else { #in and out in different hours
               tspent_1st_hr := 60 - amin_start
               t3DDays[in_day] +:= tspent_1st_hr
               tspent_last_hr := 60 - amin_end
               t3DDays[in_day] +:= tspent_last_hr
               hrs_diff := ahour_end - ahour_start
               if hrs_diff > 1 then {
                  hrs_between := hrs_diff - 1
                  every i := (ahour_start + 1) to (ahour_start + hrs_between) do
                     t3DDays[in_day] +:= 60
                  }
               }
            }
         else { #in and out in different days
            tspent_1st_hr := 60 - amin_start
            t3DDays[in_day] +:= tspent_1st_hr
            every i := (ahour_start + 1) to 24 do
               t3DDays[in_day] +:= 60
            every i := 1 to (ahour_end - 1) do
               t3DDays[out_day] +:= 60

            tspent_last_hr := 60 - amin_end
            t3DDays[out_day] +:= tspent_last_hr
            }
         m +:= 2
         }

      #
      #Parsing the SN records
      #
      m := 1
      while m < *lst_sn do {
         # parse the Logged In line
         lst_sn[m] ? {
            in_day := tab(find(" "))
            move(1)
            start_t := tab(find(" "))
            move(1)
            lrem := tab(0)
            }
         start_t ? {
            ahour_start := integer(tab(find(":")))
            move(1)
            amin_start  := integer(tab(find(":")))
            move(1)
            asec_start  := integer(tab(0))
            }

         # parse the Logged Out line
         lst_sn[m+1] ? {
            out_day := tab(find(" "))
            move(1)
            end_t := tab(find(" "))
            move(1)
            lrem := tab(0)
            }
         end_t ? {
            ahour_end := integer(tab(find(":")))
            move(1)
            amin_end  := integer(tab(find(":")))
            move(1)
            asec_end  := integer(tab(0))
            }
         if in_day == out_day then { #in and out in same day
            if ahour_start = ahour_end then { #in and out in the same hour
               tspent := (amin_end - amin_start)
               tSNDays[in_day] +:= tspent
               }
            else { #in and out in different hours
               tspent_1st_hr := 60 - amin_start
               tSNDays[in_day] +:= tspent_1st_hr
               tspent_last_hr := 60 - amin_end
               tSNDays[in_day] +:= tspent_last_hr
               hrs_diff := ahour_end - ahour_start
               if hrs_diff > 1 then {
                  hrs_between := hrs_diff - 1
                  every i := (ahour_start + 1) to (ahour_start + hrs_between) do
                     tSNDays[in_day] +:= 60
                  }
               }
            }
         else { #in and out in different days
            tspent_1st_hr := 60 - amin_start
            tSNDays[in_day] +:= tspent_1st_hr
            every i := (ahour_start + 1) to 24 do
               tSNDays[in_day] +:= 60
            every i := 1 to (ahour_end - 1) do
               tSNDays[out_day] +:= 60

            tspent_last_hr := 60 - amin_end
            tSNDays[out_day] +:= tspent_last_hr
            }
         m +:= 2
         }

         if flag = 0 then {
            if f := open(USER_GLOBALPATH||PS||userID||PS||
               "ide_3d_activity.log", "w") then {
               close(f)
	       }
            }
         tAFKDays := table(0)
         if f := open(USER_GLOBALPATH||PS||userID||
            PS||"currWeek_afk_summary.log", "r") then {
            while l := read(f) do {
               l ? {
                  d := tab(find(" "))
                  move(1)
                  afk_time := real(tab(0))
                  }
               tAFKDays[d] := afk_time
               }
            close(f)
            }
         if flag = 0 then {
            if f := open(USER_GLOBALPATH||PS||userID||
               PS||"ide_3d_usage.log", "a") then {
               write(f, &dateline)
               write(f, " ")
               write(f, left("Day", 11), left("IDE (min)", 11), 
                        left("3D (min)", 11), left("SN (min)", 11),
                        left("AFK (min)", 11))
               every d := ("Sunday"|"Monday"|"Tuesday"|"Wednesday"|
                           "Thursday"|"Friday"|"Saturday") do 
                  write(f, left(d, 11), left(tIDEDays[d], 11), 
                           left(t3DDays[d], 11), left(tSNDays[d], 11), 
                           left(tAFKDays[d], 11))
               write(f, "--------------------------------------")
               close(f)
               }
            }
         else {
            if f := open(USER_GLOBALPATH||PS||userID||
               PS||"currWeek_ide_3d_usage.log", "w") then {
               write(f, &dateline)
               write(f, " ") 
               write(f, left("Day", 11), left("IDE (min)", 11), 
                        left("3D (min)", 11), left("SN (min)", 11),
                        left("AFK (min)", 11))
               every d := ("Sunday"|"Monday"|"Tuesday"|"Wednesday"|
                           "Thursday"|"Friday"|"Saturday") do 
                  write(f, left(d, 11), left(tIDEDays[d], 11), 
                           left(t3DDays[d], 11), left(tSNDays[d], 11), 
                           left(tAFKDays[d], 11))
               write(f, "--------------------------------------")
               close(f)
               }
            }
   end

   method getUserAvailability(userID, flag)
      local log1, l, u, in_day, out_day, ahour_start, ahour_end, lrem,
         trem, start_t, end_t, tperiod,amin_start, asec_start,
         amin_end, asec_end,str, str2, uTMinutes, mylst := [],
         curr_time, curr_day, curr_mnthday, uTdays := table(0) # Table to store time spent

      local munit, uLDays, d, h, lr_lst, m, new_lr_lst, tspent,
         tspent_1st_hr, tspent_last_hr, hrs_diff, hrs_between,
         i, ava_str, f

      munit := 10 #meature unit

      uLDays := ["Sunday", "Monday", "Tuesday", "Wednesday",
                 "Thursday", "Friday", "Saturday"]
      uTDays := table()

      every uTDays[!uLDays] := table()

      every d := key(uTDays) do {
         uTHours := table()
         every h := 1 to 24 do
            uTHours[h] := 0
         uTDays[d] := uTHours
         }

      lr_lst := list() #list to store all login records
      if log1 := open(USER_GLOBALPATH||PS||userID||
         PS||"availability.log", "r") then {
         while l := read(log1) do {
            if find("Logged In", l) |
               find("Logged Out", l) then
               put(lr_lst, l)
            }
         close(log1)
         }

      m := 1
      new_lr_lst := []
      while m < *lr_lst do {
         if find("Logged In", lr_lst[m]) then {
            if find("Logged Out", lr_lst[m+1]) then {
               put(new_lr_lst, lr_lst[m])
               put(new_lr_lst, lr_lst[m+1])
               m +:= 2
               }
            else {
               m +:= 1
               }
            }
          else if find("Logged Out", lr_lst[m]) then {
             m +:= 1
             }
         }

      lr_lst := new_lr_lst
      m := 1
      while m < *lr_lst do {
         # parse the Logged In line
         lr_lst[m] ? {
            in_day := tab(find(" "))
            move(1)
            start_t := tab(find(" "))
            move(1)
            lrem := tab(0)
            }
         start_t ? {
            ahour_start := integer(tab(find(":")))
            move(1)
            amin_start  := integer(tab(find(":")))
            move(1)
            asec_start  := integer(tab(0))
            }

         # parse the Logged Out line
         lr_lst[m+1] ? {
            out_day := tab(find(" "))
            move(1)
            end_t := tab(find(" "))
            move(1)
            lrem := tab(0)
            }
         end_t ? {
            ahour_end := integer(tab(find(":")))
            move(1)
            amin_end  := integer(tab(find(":")))
            move(1)
            asec_end  := integer(tab(0))
            }
         if in_day == out_day then { #in and out in same day
            if ahour_start = ahour_end then { #in and out in the same hour
               tspent := (amin_end - amin_start)
               uTDays[in_day][ahour_start] := tspent
               }
            else { #in and out in different hours
               tspent_1st_hr := 60 - amin_start
               uTDays[in_day][ahour_start] := tspent_1st_hr
               tspent_last_hr := 60 - amin_end
               uTDays[in_day][ahour_end] := tspent_last_hr
               hrs_diff := ahour_end - ahour_start
               if hrs_diff > 1 then {
                  hrs_between := hrs_diff - 1
                  every i := (ahour_start + 1) to (ahour_start + hrs_between) do
                     uTDays[in_day][i] := 60
                  }
               }
            }
         else { #in and ou in different days
            tspent_1st_hr := 60 - amin_start
            uTDays[in_day][ahour_start] := tspent_1st_hr
            every i := (ahour_start + 1) to 24 do
               uTDays[in_day][i] := 60
            every i := 1 to (ahour_end - 1) do
               uTDays[out_day][i] := 60

            tspent_last_hr := 60 - amin_end
            uTDays[out_day][ahour_end] := tspent_last_hr
            }
         m +:= 2
         }

      if flag = 0 then {
         if f := open(USER_GLOBALPATH||PS||userID||PS||
            "availability.log", "w") then {
            close(f)
	    }

         ava_str := ""
         if f := open(USER_GLOBALPATH||PS||userID||
            PS||"avaTable.log", "w") then {
            every d := key(uTDays) do {
               ava_str ||:= d[1:4]||" "
               writes(f, d[1:4]||" ")
               every h := key(sort(uTDays[d])) do {
	          if \((uTDays[d])[h]) then {
                     ava_str ||:= (uTDays[d])[h]||" "
                     writes(f, (uTDays[d])[h]||" ")
		     }
                  }
               ava_str ||:= "&&"
               write(f)
               }
            close(f)
            }

           if f := open(USER_GLOBALPATH||PS||userID||PS||
              "avaTable.log", "r") then {
              while put(mylst, read(f))
              close(f)
              }

          curr_time := &dateline

          curr_time ? {
             curr_day := tab(find(", ")) #current day
             move(2)
             curr_mnthday := tab(find(", ")) #current day
             move(2)
             }
                   
          if f := open(USER_GLOBALPATH||PS||userID||PS||
             "avaTable("||curr_mnthday||").log", "w") then {
             every write(f, !mylst)
             close(f)
             }
         }
   end
   #
   # Here objType is either
   #      objType = "sig"
   # or
   #      objType = "profile"
   #
   method getMembers(objName, objType)
      local log1, lst := [], u
      if objType === "sig" then {
         if log1 := open(GROUP_GLOBALPATH||PS||objName||PS||
                         "members.log", "r") then {
            while u := read(log1) do put(lst, u)
            close(log1)
            }
         if log1 := open(GROUP_GLOBALPATH||PS||objName||PS||
                         "owner.log", "r") then {
            u := read(log1)
            put(lst, u)
            close(log1)
            }
         }
      else if objType === "project" then {
         if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                         "members.log", "r") then {
            while u := read(log1) do put(lst, u)
            close(log1)
           }
         if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                         "owner.log", "r") then {
            u := read(log1)
            put(lst, u)
            close(log1)
            }
         }
      return lst
   end
   method setMembers(objName, lst, objType)
      local log1
      if objType === "sig" then {
         if log1 := open(GROUP_GLOBALPATH||PS||objName||PS||
                         "members.log", "w") then {
            every write(log1, !lst)
            close(log1)
            }
         }
      else if objType === "project" then {
         if log1 := open(PROJECT_GLOBALPATH||PS||objName||PS||
                         "members.log", "w") then {
            every write(log1, !lst)
            close(log1)
            }
         }
   end

   method setMsg(sock_from, sigName, recipient, sender, snode, msg)
      local log1, u, rec_obj, client, sock_to, pinv
      if snode === "group" then {
         if recipient === "All" then {
            if log1 := open(GROUP_GLOBALPATH||PS||sigName||PS||"msgs"||
               PS||"msgs.log", "a") then {
               write(log1, "("||&date||" : "||&clock||") --> "||sender||
                  " --> "||msg)
               close(log1)
               }
            #send notifications to all members
            every u := !getMembers(sigName, "sig") do {
               rec_obj := getUser(u)
               client := Tsocket_drivers[sock_from].user.name
               if \rec_obj then
                  sock_to := Tuser_sock[rec_obj]

               pinv := pending_invitation(SetUID(client[1]),
                  client, "Group Message(New)", 1 , ClockToSec(&clock), "("||
                  &date||" : "||&clock||")~"||"Group("||sigName||")~from:"||u)
               new_pending_invitation(sock_from, pinv, sock_to)

               add_notification_record("Group/Message", sender, recipient)
               ##sendtoOne(sock_from, msg, "sendToGroup", sock_to)
               }
            #sends notification to the owner
            u := getOwner(sigName, "sig")
            rec_obj := getUser(u)
            if \rec_obj then
               sock_to := Tuser_sock[rec_obj]
            client := Tsocket_drivers[sock_from].user.name

            pinv := pending_invitation(SetUID(client[1]),
               client, "Group Message(New)", 1 , ClockToSec(&clock), "("||&date||
               " : "||&clock||")~"||"Group("||sigName||")")
            new_pending_invitation(sock_from, pinv, sock_to)

            add_notification_record("Group/Message", sender, recipient)
            add_members_communication_record("Email")
            ##sendtoOne(sock_from, msg, "sendToGroup", sock_to)
            }
         else {
            if log1 := open(USER_GLOBALPATH||PS||recipient||PS||
               "msgs.log", "a") then {
               write(log1, "("||&date||" : "||&clock||") --> "||sender||
                  " --> "||msg)
               close(log1)
               }
            rec_obj := getUser(recipient)
            if \rec_obj then
               sock_to := Tuser_sock[rec_obj]

            client := Tsocket_drivers[sock_from].user.name

            pinv := pending_invitation(SetUID(client[1]),
               client, "Message(Email)(New)", 1 , ClockToSec(&clock), "("||&date||
               " : "||&clock||")~"||"User("||recipient||")")
            new_pending_invitation(sock_from, pinv, sock_to)

            add_notification_record("Email", client, recipient)
            add_members_communication_record("Email")
            ##sendtoOne(sock_from, msg, "sendToGroup", sock_to)
            }
         }
      else if snode === "user" then {
         if log1 := open(USER_GLOBALPATH||PS||recipient||PS||
                         "msgs.log", "a") then {
            write(log1, "("||&date||" : "||&clock||") --> "||sender||
                        " --> "||msg)
            close(log1)
            }
         rec_obj := getUser(recipient)
         if \rec_obj then
            sock_to := Tuser_sock[rec_obj]

         client := Tsocket_drivers[sock_from].user.name
         pinv := pending_invitation(SetUID(client[1]),
            client, "Message(Email)(New)", 1 , ClockToSec(&clock), "("||&date||
            " : "||&clock||")~"||"User("||recipient||")")
         new_pending_invitation(sock_from, pinv, sock_to)

         add_notification_record("Email", sender, recipient)
         add_members_communication_record("Email")
         ##sendtoOne(sock_from, msg, "sendToGroup", sock_to)
         }
   end

   method getMsg(sock_from, action, msgfrom, msgto, dt, objName, objType)
      local log1, mdt, mf, line, msg_contents, fpath

      if objType === "sig" then
         fpath := GROUP_GLOBALPATH||PS||objName||PS||"msgs"||PS||"msgs.log"
      else
         fpath := USER_GLOBALPATH||PS||objName||PS||"msgs.log"

      if log1 := open(fpath, "r") then {
         while line := read(log1) do {

            line ? {
               mdt := tab(find(" --> ")) # message date and time
               move(5)
               mf  := tab(find(" --> "))# message from
               move(5)
               msg_contents := tab(0)   # message contents
               }
            if (mdt === dt) &
               (mf === msgfrom) then {
               sendtoOne(sock_from, msgfrom ||" --> "||action ||" --> "||
                  msg_contents, "getEmail", sock_from)
               }
            }
         close(log1)
         }
   end
   ##
   ##
   ##
   method new_pending_invitation(sock_from, pinv, sock_to)
      local f, data, uname, invitation_found := 0, sname, l,
         str, objName, ulst

      sname := Tsocket_drivers[sock_from].user.name #pending_from

      if /Tsocket_drivers[sock_to] then {
         if pinv.psubject == "Group Message(New)" then {
            pinv.pcomment ? {
               str := tab(find("Group("))
               move(6)
               objName := tab(find(")~from:"))
               move(7)
               uname := tab(0)
               }
            #get the members list

            }
         else if pinv.psubject == "Message(Email)(New)" then {
            pinv.pcomment ? {
               str := tab(find("User("))
               move(5)
               uname := tab(find(")"))
               }
            }
         else if pinv.psubject == "Join Group" then {
            pinv.pcomment ? {
               str := tab(find("~group:"))
               move(7)
               objName := tab(0)
               }
            uname := getOwner(objName, "sig")
            }
         if pinv.psubject == "Group Invitation" then {
            pinv.pcomment ? {
               uname := tab(find(","))
               move(1)
               str := tab(find("~group:"))
               move(7)
               objName := tab(0)
               }
            }
         if pinv.psubject == "Project Invitation" then {
            pinv.pcomment ? {
               uname := tab(find(","))
               move(1)
               str := tab(find("~project:"))
               move(9)
               objName := tab(0)
               }
            }
         else if pinv.psubject == "Join Project" then {
            pinv.pcomment ? {
               str := tab(find("~project:"))
               move(9)
               objName := tab(0)
               }
            uname := getOwner(objName, "project")
            }
         else if pinv.psubject == "Friendship Request" then {
            pinv.pcomment ? {
               uname := tab(find(","))
               move(1)
               str := tab(0)
               }
            }
         }
      else
         uname := Tsocket_drivers[sock_to].user.name #pending_to

      
      if f := open(USER_GLOBALPATH||PS||uname||PS||"pending_inv.log","r") then {
         while l := read(f) do {
            if find(pinv.uname||", "||pinv.psubject, l) then {
               l := read(f)
               if find(pinv.pcomment, l) then invitation_found := 1
               }
            }
         close(f)
         }

      if invitation_found == 0 then {
         if isFriend(uname, sname) then pinv.ppriority := 5
         else if isPartner (uname, sname, "sig") |
            isPartner (uname, sname, "project") then
            pinv.ppriority := 4
         else if isFriend_Of_Friend (uname, sname) then
            pinv.ppriority := 3

         data := pinv.pid || ", " ||
            pinv.uname || ", " ||
            pinv.psubject || ", " ||
            pinv.ppriority || ", " ||
            pinv.pdate
         if \sock_to then
            sendtoOne(sock_to, data ||", " ||
            pinv.pcomment,"ADDPending",sock_from)

         if f := open(USER_GLOBALPATH||PS||uname||PS||"pending_inv.log", "a")
            then {
            write(f, "INVPENDING_BEGIN")
            write(f, data)
            write(f, pinv.pcomment)
            write(f, "INVPENDING_END")
            close(f)
            }
         #else
         #   write("can't create pending_inv.log for user:", pinv.uname)
         }
   end

   method fwd_pending_invitation(sock_from, mybuffer)
      local usr, command, myargs, user_from, fwdfrom_usr,
         fwdto_usr, fwd_args, rec_obj, client, sock_to, pinv

      mybuffer ? {
         command := tab(find(" "))
         move(1)
         fwdfrom_usr := tab(find(" "))
         move(1)
         fwdto_usr := tab(find(" "))
         move(1)
         fwd_args := tab(0)
         }

      if rec_obj := getUser(fwdfrom_usr) then {
         client := Tsocket_drivers[sock_from].user.name
         sock_to := Tuser_sock[rec_obj]

         pinv := pending_invitation(SetUID(client[1]), client,
                 "Forward IDE Session", 1 , ClockToSec(&clock), "Forward To:"||
                 fwdto_usr)
         new_pending_invitation(sock_from, pinv, sock_to)

         sendtoOne(sock_to, fwdto_usr||" "||fwd_args, "FWDPendingSuggest",
                   sock_from)
         }
   end

   method del_pending_invitation(sock_from, buffer)
      local recipient, rec_obj, sock_to,
         p_pid, p_uname, new_user, pinv,
         fout, l, indx, pendings_lst := [], i,
         command, p_sender, p_recepient, f,
         part1, part2, isMsg := &null, rec, wall_str,
         p1, p2

      buffer ? {
         command := tab(find(" ")) # skip the command
         move(1)
         p_pid := tab(find(", "))
         move(2)
         p_sender := tab(find(", "))
         move(2)
         p_recepient := tab(0)
         } # line

      new_user := Tsocket_drivers[sock_from].user

      if f := open(USER_GLOBALPATH||PS||p_recepient||PS||
         "pending_inv.log", "r") then {
         i := 1
         while l := read(f) do {
            if find(p_pid, l) then {
               indx := i
               if find("Message(Email)(New)", l) |
                  find("Group Message(New)", l) then {
                  isMsg := 1
                  l ? {
                     part1 := tab(find("(New)"))
                     move(5)
                     part2 := tab(0)
                     }
                  l := part1||"(Old)"||part2
                  }
               else if find("Message(Email)(Old)", l) |
                       find("Group Message(Old)", l) then {
                  isMsg := 1
                  }
               }
            put(pendings_lst, l)
            i +:= 1
            }
         close(f)
         }
      #else
      #   write("can't create pending_inv.log")

      delete(new_user.pending_inv_table, p_pid)

      if /isMsg then {
         i := 1
         if f := open(USER_GLOBALPATH||PS||p_recepient||PS||
            "pending_inv.log", "w") then {
            every l := !pendings_lst do {
               if i ~== (indx-1) &
                  i ~== (indx) &
                  i ~== (indx+1) &
                  i ~== (indx+2) then {
                  write(f, l)
                  }
               i +:= 1
               }
            close(f)
            }
         #new_user.save_pending_inv()
         }
      else {
         i := 1
         if f := open(USER_GLOBALPATH||PS||p_recepient||PS||
            "pending_inv.log", "w") then {
            every l := !pendings_lst do {
               if i ~== indx then
                  write(f, l)
               else {
                  if find("New", l) then {
                     l ? {
                        p1 := tab(find("New"))
                        move(3)
                        p2 := tab(0)
                        }
                     l := p1||"(Old)"||p2
                     }
                  write(f, l)
                  }
               }
            close(f)
            }
         #new_user.save_pending_inv()
         }
   end

   method SetUID(ch)
      #This is a quick hack to derive a Unique ID.
      return string( (?224 + 31) * (256*256*256) +
                   (?224 + 31) * (256*256)     +
                   (?224 + 31) *  256          +
                   (?224 + 31)) || ch
   end

   method addFeed_nodes(sock_from, userID, feed_lbl, ppriority,
			who_is_allowed, objName)
      local ulst, objType, rec_obj, sock_to, u, x
      if who_is_allowed == "Group" then {
         ulst := getMembers(objName, "sig")
         ppriority := "high"
         put(ulst, userID)
         every u := !ulst do {
            if rec_obj := getUser(u) then {
               sock_to := Tuser_sock[rec_obj]
               sendtoOne(sock_to, userID||" "||ppriority||" "||feed_lbl||"["||
                  who_is_allowed||"]", "addFeed", sock_to)
               }
            }
         }
      else if who_is_allowed == "Project" then {
         ulst := getMembers(objName, "Project")
         ppriority := "high"
         put(ulst, userID)
         every u := !ulst do {
            if rec_obj := getUser(u) then {
               sock_to := Tuser_sock[rec_obj]
               sendtoOne(sock_to, userID||" "||ppriority||" "||feed_lbl||"["||
                  who_is_allowed||"]", "addFeed", sock_from)
               }
            }
         }
      else if who_is_allowed == ("Session"|"ALL") then {
         every x := !Tuser_sock do {
            if \(Tsocket_drivers[x]).user.name=="system" |
               \(Tsocket_drivers[x]).user.name==userID then next
            u := \(Tsocket_drivers[x]).user.name

            ppriority := get_feed_priority(userID, u)
            sendtoOne(x, userID||" "||ppriority||" "||feed_lbl||"["||
            who_is_allowed||"]", "addFeed", sock_from)
            }
         }
      update_stats("Feed/Add")
      update_user_stats("Feed/Add", userID)
   end

##
##   method CETL_New
##
   method CETL_New(sock_from, args,which_command)
      local recipient, params, client,slave,
         sock_to,file_contents,file_name:="",temp,wpos,
         found,i,index_counter,str_users, pinv,
         command, user, sdp_flag, msg_contents, hostuser, 
         rec_obj, f, font_size, lst_ln, lnum, cnum

      if which_command = 1 then {
         args ? {
            command := tab(find(" "))
            move(1)
            font_size := tab(find(" "))
            move(1)
            user := tab(find(" "))
            move(1)
            index_counter := integer(tab(find(" ")))
            move(1)
            file_name := tab(find(" "))
            move(1)
            slave := tab(find(" "))
            move(1)
            sdp_flag := integer(tab(find(" ")))
            move(1)
            lst_ln := integer(tab(find(" ")))
            move(1)
            lnum := integer(tab(find(" ")))
            move(1)
            cnum := integer(tab(0))
            }
         }
      if which_command = 2 then {
         args ? {
            command := tab(find(" "))
            move(1)
            font_size := tab(find(" "))
            move(1)
            user := tab(find(" "))
            move(1)
            file_name := tab(find("|"))
            move(1)
            file_contents := tab(find("@@"))
            move(2)
            msg_contents := tab(find("$$"))
            move(2)
            hostuser:= tab(find(" "))
            move(1)
            sdp_flag:= integer(tab(find(" ")))
            move(1)
            lst_ln := integer(tab(find(" ")))
            move(1)
            lnum := integer(tab(find(" ")))
            move(1)
            cnum := integer(tab(0))
            }
         }
      params := Cmds.SplitArgs(args)

      recipient := params[3]
$ifdef later
      if which_command = 2 then {
         temp:=params[3]
         wpos:=find("|",temp)
         file_name:= temp[1:wpos]
         wpos:=find("|",args)
         file_contents:=args[wpos+1:0]
         }
      if which_command = 1 then {
         index_counter:=params[3]
         file_name:=params[4]
         slave:=params[5]
         }
$endif
      if /recipient then {
         sendtoOne(sock_from, "No recipient provided. Usage: "||
                              "\\tell user message", "say", sock_from)
         return
         }


      if rec_obj := getUser(recipient) then {
         client := Tsocket_drivers[sock_from].user.name
         sock_to := Tuser_sock[rec_obj]
         if which_command = 2 then {
            Check_Session(client,file_name)

            if IDE_Checked_Counter = 0 then
               IDE_Checked_Counter := 1

            if Addcounter=0 then { #Session already exist
               str_users:=IDE_Session_User_List(
				   Tide[IDE_Checked_Counter].Lusers)
               }
            else {
               str_users:="No"
               }
            pinv := pending_invitation(SetUID(client[1]), client,
		      "IDE Session", 1 , ClockToSec(&clock), "File:"||file_name)

            add_notification_record("Session/Edit", client, recipient)

            new_pending_invitation(sock_from, pinv, sock_to)
            if \rec_obj then
               sendtoOne(sock_to, font_size||" "||client||" "||IDE_Checked_Counter||
               " "||recipient||" "||file_name||"|"||file_contents||"@@"||
               msg_contents||"$$"||hostuser||"$$"||Addcounter||" "||str_users||
               " "||\sdp_flag||" "||lst_ln||" "||lnum||" "||cnum, "CETLOpen", sock_from)
            }
         if which_command = 1 then {
            sendtoOne(sock_to, font_size||" "||recipient||" "||index_counter||
               " "||file_name||" "||slave||" "||sdp_flag||" "||lst_ln||" "||
               lnum||" "||cnum, "CETLaccept", sock_from)

            Add_IDE(recipient,index_counter,file_name ,slave)
            if f := open(SESSION_GLOBALPATH||PS||"members.log", "a") then {
               write(f, file_name||" --- "||slave)
               close(f)
               }
            update_notification_record("Session/Edit", recipient, client)
            update_stats("Session/Edit")
            update_user_stats("Session/Edit", slave)

            if \isPartner (client, slave, "project") then
               update_partner_stats(file_name, "P", "Edit")
            else if \isPartner (client, slave, "sig") then
               update_partner_stats(file_name, "G", "Edit")
            else update_partner_stats(file_name, "E", "Edit")
            }
           return
         }
      sendtoOne(sock_from, "no such user is online: " || recipient,
                "say", sock_from)
   end
#
#Create user list to be send to the invited user
#
method IDE_Session_User_List(Luser)
    local Str:="",i,rec_obj,client,sock_to

    every i:=1 to *Luser do {
       Str:=Str||"$"||Luser[i]
        }
    return Str
end
   #
   #
   #Send new invited user to all users in the IDE session
   #
   method Send_Added_IDE_User(sock_from, args)
      local user_to_add,index,rec_obj,client,sock_to,recipient,params

      params := Cmds.SplitArgs(args)
      recipient := params[2]
      user_to_add:=  params[3]
      index:= params[4]
      if /recipient then {
         sendtoOne(sock_from, "No recipient provided. Usage: "||
                   "\\tell user message", "say", sock_from)
         return
         }
      if rec_obj := getUser(recipient) then {
         client := Tsocket_drivers[sock_from].user.name
         sock_to := Tuser_sock[rec_obj]
         sendtoOne(sock_to,user_to_add||" "||index  , "CETLSendUser", sock_from)
         return
         }
      sendtoOne(sock_from, "no such user is online: " || recipient,
                "say", sock_from)
   end
   #
   #If user rejected collaborative IDE
   #we will decrement the counter
   #
   method Decrement_IDE(args)
      local index,params

      params := Cmds.SplitArgs(args)
      index := params[2]
      IDECounter:=integer(index)
   end
   #
   #Check if session already exist with other users
   # if it is exist send it's index
   #
   method Check_Session(owner, filename)
      local counter:=1, found:=1

      Addcounter:=0
      if IDECounter = 0 then {
          IDECounter +:= 1
          IDE_Checked_Counter := IDECounter
          Addcounter := 1
         }
      else {
          while (found=1) & (counter <= IDECounter) &
                (\Tide[1]) do {
           if \Tide[counter] then {
            if \Tide[counter].IDEFile then {
             if (Tide[counter].IDEFile == filename) &
                (Tide[counter].IDEOwner == owner) then {
                 found := 0
                  }
                 }
                }
             counter +:= 1
           }

          if found=0 then { #Session already exist with other user
             IDE_Checked_Counter -:= 1
             }
          else {
             IDECounter +:= 1
             IDE_Checked_Counter := IDECounter
             Addcounter := 1
             }
       }
   end
   ##
   ##  Add_IDE
   ##
   method Add_IDE(owner,index_counter,file_name ,user)

     local ide_prop

     index_counter:=integer(index_counter)
     if /Tide[index_counter] then {
         ide_prop := SessionMC(owner, file_name, "on")
         Tide[index_counter] := ide_prop
       }
     put(Tide[index_counter].Lusers,user)
   end
#
#Swap(i)
#swap last entry in the table with the entry that will be deleted
#
   method Swap(i)
      local Temp

      Temp:=Tide[IDECounter]
      Tide[IDECounter]:=Tide[i]
      Tide[i]:=Temp
   end
   #
   #If user close the file reomve him from the IDE users list
   #
   method Delete_File_From_IDE(sock_from,args)
      local i,found:=0,j,owner,k,U,Temp,table_length,client,
         rec_obj,sock_to,params,file_name,index,user

      params := Cmds.SplitArgs(args)
      user:=params[2]
      file_name:=params[3]
      index:=integer(params[4])
      table_length:=IDECounter
      if \Tide[index] then {# if not null
          if (Tide[index].IDEOwner==user)&(Tide[index].IDEFile==file_name) then {
              Send_To_Delete_IDE_Entry(index,user,sock_from,2,0)
            #swap to the last location to delete it
            if (IDECounter>1)&(IDECounter~=index) then { # No need to do swap if
                                                        # IDECounter==1 or if
                                                        # it the last element
               Swap(index)
            }
         delete(Tide, IDECounter)
         IDECounter -:= 1
         } # end if, he is the owner
      else {# the user who closed the file is not the owner
         j := 1
         while (j<= *Tide[index].Lusers) & (found=0) do {
            if Tide[index].Lusers[j]===user then {
               found := 1
               }
            j +:= 1
           } #end while
         if found = 1 then {
            delete(Tide[index].Lusers,j-1)
            if  (*Tide[index].Lusers = 0) then { # if list is empty
               if (IDECounter > 1) & (IDECounter ~= index) then {
		   # No need to swap if IDECounter==1 or its the last element
                   Swap(index)
                }
             #remove Owner and whiten background
               U:=Tide[index].IDEOwner
               if rec_obj := getUser(U) then {
                  client := Tsocket_drivers[sock_from].user.name
                  sock_to := Tuser_sock[rec_obj]
                  sendtoOne(sock_to, "User "||user||
                  " of the collaborative IDE file "||Tide[index].IDEFile||
                  " has closed the file", "say", sock_from)
                  sendtoOne(sock_to, index, "CETLDeleteEntry", sock_from)
                 }
               delete(Tide,IDECounter)
               IDECounter -:= 1
                 }# end of if empty user list
            else {
	       # Lusers is not empty, we will send to all other users
	       # to remove the user
               Send_To_Delete_IDE_User(index,user,sock_from,2)
	       }
             }# end if user found
            }#end else
         handle_session_activity(user, file_name)
         }
   end
#
#Send closed file command to all users to remove the user who closed the file
#
method Send_To_Delete_IDE_User(i,user,sock_from,logout_or_fileclosed)

     local k,U,rec_obj,client,sock_to,Str

     if logout_or_fileclosed=1 then {
         Str := " has closed the file"
        }
     else {
         Str := " has exit the session"
        }
     k := 1
     if \Tide[i] then {
       while k <= *Tide[i].Lusers do {
         U:=Tide[i].Lusers[k]
         if rec_obj := getUser(U) then {
             client := Tsocket_drivers[sock_from].user.name
             sock_to := Tuser_sock[rec_obj]
             sendtoOne(sock_to, "User "||user||
                " of the collaborative IDE file "||Tide[i].IDEFile||
                Str, "say", sock_from)
             sendtoOne(sock_to, i||" "||user, "CETLDeletefile", sock_from)
             update_notification_record("Session/Edit", user, Tide[i].IDEOwner)
              }
         k +:= 1
          } #end while
       U:=Tide[i].IDEOwner
       if rec_obj := getUser(U) then {
        client := Tsocket_drivers[sock_from].user.name
        sock_to := Tuser_sock[rec_obj]
        sendtoOne(sock_to, "User "||user||" of the collaborative IDE file "||
           Tide[i].IDEFile||Str, "say", sock_from)
        sendtoOne(sock_to, i||" "||user, "CETLDeletefile", sock_from)
        }
     }
end
#
#Send remove user entry from the IDE table
#
method Send_To_Delete_IDE_Entry(i,user,sock_from,logout_or_fileclosed,not_owner)
     local k := 1, U, rec_obj, client, sock_to, Str

     if logout_or_fileclosed=1 then {
         Str := " has closed the file"
       }
     else {
         Str := " has exit the session"
       }
     if \Tide[i] then {
      if not_owner = 0 then {
       while k <= *Tide[i].Lusers do {
         U := Tide[i].Lusers[k]
         if rec_obj := getUser(U) then {
             client := Tsocket_drivers[sock_from].user.name
             sock_to := Tuser_sock[rec_obj]
             sendtoOne(sock_to, "Owner "||user||
		       " of the collaborative IDE file "||Tide[i].IDEFile||Str,
		       "say", sock_from)
             sendtoOne(sock_to, i, "CETLDeleteEntry", sock_from)
           }
         k +:= 1
       } #end while
       }
       else {
           U:=Tide[i].IDEOwner
           if rec_obj := getUser(U) then {
              client := Tsocket_drivers[sock_from].user.name
              sock_to := Tuser_sock[rec_obj]
              sendtoOne(sock_to, "User "||user||
			" of the collaborative IDE file "||Tide[i].IDEFile||
			Str,"say", sock_from)
              sendtoOne(sock_to, i||" "||user, "CETLDeleteEntry", sock_from)
              }
         }
      }
end

#
#Send All users who has collaboration with logged out user
#
method Send_To_Remove_Logged_Out_User(user,sock_from)
     local i,U,rec_obj,client,sock_to, eTime, client2

     eTime := ClockToSec(&clock)
     handle_session_records(user, eTime)

     if \Lusers_to_send then {
     every i:=1 to *Lusers_to_send do {
         U:=Lusers_to_send[i]
         if rec_obj := getUser(U) then {
             client := Tsocket_drivers[sock_from].user.name
             sock_to := Tuser_sock[rec_obj]
             client2 := Tsocket_drivers[sock_to].user.name
             sendtoOne(sock_to, "User "||user||
		   " has exit the collaborative IDE session", "say", sock_from)
             handle_session_records(client2, eTime)
             sendtoOne(sock_to, user, "CETLRemoveUser", sock_from)
           }
       } #end every
      }
end

#
#Check if user is already in the list
#
method Check_User(user)
   local j:=1,found:=0

   if \Lusers_to_send then {
      while (j<= *Lusers_to_send) & (found=0) do {
	 if Lusers_to_send[j]==user then {
	    found := 1
	    }
	 j +:= 1
	 }
      }
   return found
end
#
#Add users who are in the collaboration of exited user to the Lusers_to_send
#
method Add_Users_To_List(i,user_index)
   local j:=1,found

   if \Tide[i] then {# if not null
    while j<= *Tide[i].Lusers do {
        if user_index ~= j then {
            if \Lusers_to_send then {
               found:=Check_User(Tide[i].Lusers[j])
              if found = 0 then {
                put(Lusers_to_send,Tide[i].Lusers[j])
               }
            }
           }
        j:=j+1
     } #end while
     if j ~= -1 then {
         found:=Check_User(Tide[i].IDEOwner)
         if found = 0 then {
               put(Lusers_to_send,Tide[i].IDEOwner)
          }
         }
     }
end


##
##  Delete_User_From_IDE(user)
##   if user logged out delete him from IDE session
##
   method Delete_User_From_IDE(user,sock_from)
      local i:=1,found,j,owner,k,U,Temp,client,rec_obj,sock_to,target

        Lusers_to_send:=[]
        #table_length:=IDECounter
        while i<= IDECounter do {
           found:=0
           j:=1
           owner:=0
           target:=0
           if \Tide[i] then {# if not null
                if Tide[i].IDEOwner==user then {
                   owner := i
                   }
                else {#he is not the owner
                   while (j<= *Tide[i].Lusers) &(found=0) do {
                        if Tide[i].Lusers[j]==user then {
                                found:=1
                           }
                        j:=j+1
                     } #end while
                  if found=1 then {# we found the user who logged out
                    Add_Users_To_List(i,j-1)
                    delete(Tide[i].Lusers,j-1)
                    if  (*Tide[i].Lusers = 0) then { # if it's empty make
                        if (IDECounter>1)&(IDECounter~=i) then {
			    #No need to do swap if
			    #IDECounter==1 or if it the last element
			    Swap(i)
			    target:=1
			}
                        delete(Tide,IDECounter)
                        IDECounter -:= 1
                      }# end of if empty user list
                }# end if user found
             } #end else not owner

         if  (owner ~=0) then {# he is the owner
              #swap to the last location to delete it
             Add_Users_To_List(i,-1)
             if (IDECounter>1)&(IDECounter~=i) then { #No need to do swap if
                                        #IDECounter==1 or if it the last element
                Swap(owner)
                target:=1
              }
             delete(Tide,IDECounter)
             IDECounter:=IDECounter-1
          } # end if, he is the owner
          if target ~= 1 then {
             i:=i+1
          }
        } #end if ,not null table entry
       }# end while
       Send_To_Remove_Logged_Out_User(user,sock_from)
   end


#
#--------------------# End Collaborative IDE #----------------------#
#
#----------------------      IDE     -------------------------------#

   #
   # newuser: creates the necessary entries for a new user
   #
   method newuser(args)
      local new_user, params

      params := Cmds.SplitArgs(args)

      if /params[1] | /params[2] then {
         logHandler.logit("newuser(): malformed command; missing parameters")
         fail
         }

      # insert the new user in the db
      new_user := User(params[1],dynStHandler.srvSceneGraph.cveBuilder)
      if \new_user.exists() then {
	 #yes this user already exists
	 logHandler.logit("newuser(): user " || params[1] || " exists")
	 fail
         }

      # user does not exist, lets create the account
      new_user.create_user(params[2],params[3],params[4],params[5],params[6])
      logHandler.logit("newuser(): new user has been created, "||new_user.name)
      return
   end

   #
   # group_Exists: simply tests the existence of a group
   #               fails if not found
   #
   method group_Exists(groupname)
      if \Tname_group[groupname] then
         return

      fail
   end

   #
   # joinGroup: joins the current user to a group
   #            creates the group if it does not exist
   #
   method joinGroup(sock_from, args)
      local confirmation, user_from, target_group, message

      # grab a reference to the user
      user_from := Tsocket_drivers[sock_from].user

      # there must be a group here
      if *args = 0 then {
         sendtoOne(sock_from, "Please specify the group name!","say",sock_from)
         return
         }

      if group_Exists(args) then {
         target_group := Tname_group[args]

         # check for user existence in the given group
         if \user_from.groups[args] then {
            sendtoOne(sock_from, "You already belong to group: " || args,
              "say", sock_from)
            return
            }
         }
      else {
         # it does not exist so create it first and become its owner
         target_group := Group(args, user_from.name)
         Tname_group[args] := target_group
         }

      # add the user on the group side
      target_group.membership +:= 1
      target_group.addMember(user_from)

      # add the user on the user side
      user_from.groups[args] := 1

      # notify the user
      confirmation := "You were added to the group, " ||
      (if find("clb",args) then args[5:*args+1] else args) ||
      " (" || target_group.membership || " members)"

      sendtoOne(sock_from, confirmation, "say", sock_from)

      # notify everyone else (except for myself)
      message := user_from.name || " has joined group " || target_group.name ||
      "."
      sendtoGroup(target_group.name,  message, user_from)
      return
   end

   #
   # sendtoGroup(): send the message to everybody in the group
   #                and myself if myself is not set to a username
   #
   method sendtoGroup(which_group, message, sender)
      local current_group, new_member

      if *which_group = 0 then
         return

      # reference to the group in question
      current_group := Tname_group[which_group]

      # notify everyone else
      every new_member := !(current_group.memberList()) do
         if(new_member.name ~== sender.name) then
            sendtoOne(Tuser_sock[new_member], message,"say",Tuser_sock[sender])
   end

   #
   # UpdateIgnoreList: this manipulates each user's ingore list
   #                   if behavior is 1 then it means that ignore was invoked
   #                   if behavior is 0 then the user is allow was invoked
   #
   method UpdateIgnoreList(sock_from, args, behavior)
      local sender, user_to_ignore, n, params

      params := Cmds.SplitArgs(args)

      sender := Tsocket_drivers[sock_from].user
      user_to_ignore := params[1]

      if /user_to_ignore then {
         sendtoOne(sock_from, "No user to ignore provided. Usage: "||
           "\\ignore user", "say", sock_from)
         return
         }

      if behavior == 1 then {
         # check to see if user already in the ignore list
         if sender.isIgnored(user_to_ignore) == 1 then {
            put(sender.IgnoreList, user_to_ignore)
            sendtoOne(sock_from, user_to_ignore || " is being ignored",
              "say", sock_from)
            }
         else
            sendtoOne(sock_from, user_to_ignore || " already being ignored",
              "say", sock_from)
         }
      else {
         # check to see if user already in the ignore list
         if sender.isIgnored(user_to_ignore) == 1 then
            sendtoOne(sock_from, user_to_ignore ||
             " not being ignored in the first place", "say", sock_from)
         else {
            sender.stopIgnoring(user_to_ignore)
            sendtoOne(sock_from,user_to_ignore || " not being ignored anymore",
              "say", sock_from)
         }
      }
   end

   #
   # who_is_up: returns a string version of all active users
   #
   method who_is_up()
      local x, user_list, t

      user_list := "Users currently online:\n"

      if *Tuser_sock > 0 then
         every x := key(Tuser_sock) do {
	    if x.name=="system" then next
            user_list := user_list || x.name

            if x.is_status("Busy") | x.is_status("Offline") then
	       user_list ||:= ":"|| x.get_activity_status()
	    else if  x.is_afk() | x.is_status("Away") then
	       user_list ||:= ":afk " || x.get_afk_duration()
	    else
	       user_list ||:= ":Online"

            user_list ||:= ",\n"
         }

      # to get rid of the superfluous comma and newline
      user_list := user_list[1:*user_list-1]

      return user_list
   end

   #
   # Version check: check the version of Unicron
   #
   method version_check(clientver)
      if \clientver ~== cve_version() then
          return "Invalid Version, wanted " || cve_version() ||
	    " you gave " || image(clientver) || "\n" ||
            "To get a new version visit: " ||
            "http://sourceforge.net/projects/cve/" || "\n"
      else
          return "Valid Version " || cve_version() || "\n"
   end

   #
   #---- For VoIP
   #
   method GetVoIPUserIP(uid)
       local user := getUser(uid)
       return uid||":"||user.IP||":5000"
   end

   #
   #---- For VoIP
   #
   method VoiceRequest(sock_from, args)
      local recipient, params, rec_obj,client ,sock_to

      params := Cmds.SplitArgs(args)
      recipient := params[2]

      if /recipient then {
         sendtoOne(sock_from, "No recipient provided. Usage: "||
                   "\\tell user message", "say", sock_from)
         return
      }

      if rec_obj := getUser(recipient) then {
         client := Tsocket_drivers[sock_from].user.name
         sock_to := Tuser_sock[rec_obj]
         sendtoOne(sock_to, client , "vrequest", sock_from)
         return
      }

      sendtoOne(sock_from, "no such user is online: " || recipient,
                "say", sock_from)
   end

   #
   #---- For VoIP
   #
   method VoiceAccept(sock_from, args)
      local params, client1, client2, rec_obj1, rec_obj2,
	message1, message2, sock1, sock2

      params := Cmds.SplitArgs(args)
      client1 := params[2]
      client2 := Tsocket_drivers[sock_from].user.name

      if rec_obj1 := getUser(client1) then {
	 sock1 := Tuser_sock[rec_obj1]
	 message1 := client2|| ":" || getIP(client2) || ":5000"
	 if find("undef", message1) then
	    message1 := GetVoIPUserIP(client2)
	 sendtoOne(sock1, message1, "vaccept", sock1)
         }

      if rec_obj2 := getUser(client2) then {
	 sock2 := Tuser_sock[rec_obj2]
	 message2 := client1|| ":" || getIP(client1) || ":5000"
	 if find("undef", message2) then
	    message2 := GetVoIPUserIP(client1)
	 sendtoOne(sock2, message2, "vaccept", sock2)
         }
   end

   #
   #---- For new VoIP
   #
   method VoiceRequestDirectTalk(sock_from, args)
      local recipient, params, rec_obj,client ,sock_to

   params := Cmds.SplitArgs(args)
        recipient := params[2]

   if /recipient then {
         sendtoOne(sock_from, "No recipient provided. Usage: "||
         "\\tell user message", "say", sock_from)
         return
        }

   if rec_obj := getUser(recipient) then {
         client := Tsocket_drivers[sock_from].user.name
      sock_to := Tuser_sock[rec_obj]
         sendtoOne(sock_to, client , "vrtalk", sock_from)
         return
        }
        sendtoOne(sock_from, "no such user is online: " || recipient,
        "say", sock_from)
   end

   #
   #---- For new VoIP
   #
   method VoiceDirectTalk(sock_from, args)
      local params, client1, client2, rec_obj1, rec_obj2,
               message1, message2,  sock1, sock2

      params := Cmds.SplitArgs(args)
      client1 := params[2]
      client2 := Tsocket_drivers[sock_from].user.name

      if rec_obj1 := getUser(client1) then {
         sock1 := Tuser_sock[rec_obj1]
         message1:=client2|| ":" || getIP(client2) || ":5000"
         if find("undef", message1) then
	    message1:= GetVoIPUserIP(client2)
         sendtoOne(sock1, message1, "vtalk", sock1)
         }

      if rec_obj2 := getUser(client2) then {
         sock2 := Tuser_sock[rec_obj2]
         message2:=client1|| ":" || getIP(client1) || ":5000"
         if find("undef", message2) then
	    message2:= GetVoIPUserIP(client1)
         sendtoOne(sock2, message2, "vtalk", sock2)
         }
   end

   #
   #---- For VoIP
   #
   method VoiceReject(sock_from, args)
      local params, client1, client2, rec_obj1, rec_obj2, sock1, sock2

   params := Cmds.SplitArgs(args)
        client1 := params[2]
   client2 := Tsocket_drivers[sock_from].user.name

   if rec_obj1 := getUser(client1) then {
         sock1 := Tuser_sock[rec_obj1]
         sendtoOne(sock1, client2 , "vreject", sock1)
        }

   if rec_obj2 := getUser(client2) then {
         sock2 := Tuser_sock[rec_obj2]
         sendtoOne(sock2, client1, "vreject", sock2)
        }
   end

   #
   #---- For VoIP
   #
   method VoiceHold(sock_from, args)
      local params, client1, client2, rec_obj1, rec_obj2, sock1, sock2

   params := Cmds.SplitArgs(args)
        client1 := params[2]
   client2 := Tsocket_drivers[sock_from].user.name

   if rec_obj1 := getUser(client1) then {
         sock1 := Tuser_sock[rec_obj1]
         sendtoOne(sock1, client2 , "vhold", sock1)
        }

   if rec_obj2 := getUser(client2) then {
         sock2 := Tuser_sock[rec_obj2]
         sendtoOne(sock2, client1, "vhold", sock2)
        }
   end

   #
   #---- For VoIP
   #
   method VoiceUnHold(sock_from, args)
      local params, client1, client2, rec_obj1, rec_obj2,
    message1, message2, sock1, sock2

      params := Cmds.SplitArgs(args)
      client1 := params[2]
      client2 := Tsocket_drivers[sock_from].user.name

      if rec_obj1 := getUser(client1) then {
	 sock1 := Tuser_sock[rec_obj1]
	 message1:=client2|| ":" || getIP(client2) || ":5000"
	 if find("undef", message1) then
	    message1:= GetVoIPUserIP(client2)
	 sendtoOne(sock1, message1 , "vuhold", sock1)
         }

      if rec_obj2 := getUser(client2) then {
	 sock2 := Tuser_sock[rec_obj2]
	 message2:=client1|| ":" || getIP(client1) || ":5000"
	 if find("undef", message2) then
	    message2:= GetVoIPUserIP(client1)
	 sendtoOne(sock2, message2, "vuhold", sock2)
         }
   end

   #
   #---- For VoIP
   #
   method VoiceEnd(sock_from, args, cmd)
      local params, user_to, user_from, rec_obj_to, sock_to

   params := Cmds.SplitArgs(args)
        user_to := params[2]
   user_from := Tsocket_drivers[sock_from].user.name

   if rec_obj_to := getUser(user_to) then {
         sock_to := Tuser_sock[rec_obj_to]
         sendtoOne(sock_to, user_from , cmd, sock_to)
        }
   end

   #
   #---- For VoIP
   #
   method GetMyRoom(sock_from, args)
      local client
      client := Tsocket_drivers[sock_from].user.name
      sendtoOne(sock_from, dynStHandler.getMyRoom(client) , "vroom", sock_from)
   end

   #
   #---- For VoIP
   #
   method GetWhoInMyRoom(sock_from, args)
      local client,avt_list, x , dest

      client := Tsocket_drivers[sock_from].user.name
      avt_list := dynStHandler.getAvatInMyRoom(client)

      dest :=""
      every x := !avt_list do {
	 dest := dest || x
	 dest ||:=" \n"
	 }

      dest := dest[1:*dest-1]
      if dest ~== "" then
	 sendtoOne(sock_from, dest , "avtroom", sock_from)
   end

   #
   #---- For VoIP
   #
   method GetWhoActiveInMyRoom(sock_from, args)
      local client, client_dest, avt_list, x , dest, rec_obj, sock_to, user_ip

      client := Tsocket_drivers[sock_from].user.name
      avt_list := dynStHandler.getAvatInMyRoom(client)

      dest :=""
      client_dest := client||":"||getIP(client)
      every x := !avt_list do {
         if x ~== client then {
            rec_obj := getUser(x)
            if \rec_obj then {
               sock_to := Tuser_sock[rec_obj]
               if Tsocket_drivers[sock_to].user.VoiceState === "Local" then {
                  user_ip := getIP(x)
                  if find("undef", user_ip) then {
                     dest:= GetVoIPUserIP(x)
                     sendtoOne(sock_from, dest , "vlocal", sock_from)
                     dest:=""
                     rec_obj:= &null
                     sendtoOne(sock_to, client_dest , "vlocal", sock_to)
                  } else {
                     dest := x ||":"||user_ip
                     sendtoOne(sock_from, dest , "vlocal", sock_from)
                     dest:=""
                     rec_obj:= &null
                     sendtoOne(sock_to, client_dest , "vlocal", sock_to)
                  }
               }
            }
         }
      }
      #dest := dest[1:*dest-1]
      #sendtoOne(sock_from, dest , "vlocal", sock_from)
   end

   #
   #---- For VoIP
   #
   method GetWhoInCellPhone(sock_from, args)
      local client, x,  user_list

      user_list := ""
      client := Tsocket_drivers[sock_from].user.name

      if *Tuser_sock > 0 then
          every x := key(Tuser_sock) do {
             if x.name ~=== client & x.VoiceState === "Private" then {
                user_list := user_list || x.name
                user_list ||:= " \n"
		# Remove the comma????????
             }
          }

      # to get rid of the superfluous comma and newline
      user_list := user_list[1:*user_list-1]

      if user_list ~== "" then
          sendtoOne(sock_from, user_list , "vphone", sock_from)
   end

   method get_offline_user_summary(username)
      local fin, p, s
      # open the summary file and get the old data
      if fin := open(USER_GLOBALPATH||PS||username||PS|| username ||
		  "_summary.log", "r") then {
         p := stat(fin) | fail
         s := reads(fin, p.size) | fail
         close(fin)
         }
      return s
   end
   #
   #
   #
   method session_history(userID, fileName)
      local msg, t, afk_percent, rec_obj, fd, pt, l, cw_msg, fa_msgs, f, fn,
         l2, max_time_spent, min_time_spent, user_time_tbl,
         most_active_member := userID,
         user_active_percent_tbl, sUser, startTime, endTime, action, t_spent,
         active_percent, u, total_time_members_spent, user_active_str,
         a_percent, active_t, fName, compile_output,
         s_time := ClockToSec(&clock) #current time in seconds

      rec_obj := getUser(userID)

      t := s_time - rec_obj.login_time_stamp

      if t = 0 then t := 1

      afk_percent := integer((real(rec_obj.afk_duration)/t)*10000)/100

      user_time_tbl := table(0)
      user_active_percent_tbl := table(0)
      every fn :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
         !open(SESSION_GLOBALPATH)))))))) do {
         #if find("_activities.log", fn) then
            {
            if fd := open(SESSION_GLOBALPATH||PS||
			  "activities.log", "r") then {
               while l := read(fd) do {
                  if find(fileName|" --- "||userID, l) then {
                     l ? {
                        fName  := tab(find(" --- "))
                        move(5)
                        sUser  := tab(find(" --- "))
                        move(5)
                        startTime := tab(find(" --- "))
                        move(5)
                        endTime   := tab(find(" --- "))
                        move(5)
                        action    := tab(find(" --- "))
                        move(5)
                        compile_output := tab(find(" --- "))
                        move(5)
                        t_spent   := tab(0)
                        }
                     if t_spent < (s_time - startTime) then
                        t_spent := (s_time - startTime)
                     user_time_tbl[sUser] +:= t_spent
                     }
                  }
               close(fd)
               }
            }
         }

      max_time_spent := 0
      min_time_spent := 0
      active_percent := 0
      every u := !user_time_tbl do {
         if u >= max_time_spent then
            max_time_spent := u
         if u <= min_time_spent then
            min_time_spent := u
         }
      total_time_members_spent := 0
      every u := key(user_time_tbl) do {
         if integer(user_time_tbl[u]) === integer(max_time_spent) then
            most_active_member := u
         total_time_members_spent +:= integer(user_time_tbl[u])
         }

      if total_time_members_spent > 0 then {
         active_percent := real(max_time_spent)/real(total_time_members_spent)
         active_percent := integer(active_percent * 100)
         }
      user_active_str := ""
      every u := key(user_time_tbl) do {
         a_percent := real(user_time_tbl[u])/real(total_time_members_spent)
         user_active_percent_tbl[u] := integer(a_percent * 100)
         user_active_str ||:= u ||"\t\t"||seconds_to_clock(user_time_tbl[u])||
            "\t\t"||user_active_percent_tbl[u]||"% \n"
         }

      msg := "SESSION_ACTIVITY\n" ||
         "Activity Summary of Session : " || fileName || "\n"||
         "-----------------------------------------------\n"||

         "Users' Activity :"||
         "\n\nName"||"\t\t"||"Time Spent"||"\t\t"||"Active Percent \n"||
         "-----------------------------------------------\n"||
         user_active_str||"\n"||
         "\nMost Active Member :"||
         "\n\nName"||"\t\t"||"Time Spent"||"\t\t"||"Active Percent \n"||
         "-----------------------------------------------\n\n"||
         most_active_member||"\t\t"||
         seconds_to_clock(user_time_tbl[most_active_member])||
         "\t\t"||active_percent||"% \n\n"||
         "Time spent : \n"||"   In the cve     : " ||
         seconds_to_clock(t)  ||" (h:m:s)\n" ||
         "   In the project : " ||
         seconds_to_clock(user_time_tbl[most_active_member])||
         " (h:m:s)\n" ||
         "   AFK  : " || seconds_to_clock(rec_obj.afk_duration) ||
         " (" || afk_percent || "%)\n"

      t +:= rec_obj.time_in_cve_total
      afk_percent := integer((real(rec_obj.afk_duration +
         rec_obj.afk_duration_total)/t)*10000)/100
      active_t := t-rec_obj.afk_duration-rec_obj.afk_duration_total
      msg ||:= "-----------------------------------------------\n\n"||
         "\nOther Info \n"||
         "\nTime spent : \n"||"   In the cve (total) : " ||
         seconds_to_clock(t)||" (h:m:s)\n"||"   AFK (total) : " ||
         seconds_to_clock(rec_obj.afk_duration+rec_obj.afk_duration_total) ||
         " ("  || afk_percent || "%)\n" ||
         "   Active                     : "||seconds_to_clock(active_t)||
         "\n\n*AFK = Away from keyboard"

      if fd := open(SESSION_GLOBALPATH||PS||fileName ||
         "_summary.log", "w") then {
         write(fd, msg)
         close(fd)
         }

      sendtoOne(userID, msg, "sessionActivity", userID)
   end
   #
   # Return a message of all the project activity summary
   #
   method project_history(userID, projName, fileName)
      local msg, t, afk_percent, rec_obj, fd, pt, l, cw_msg, fa_msgs, f, fn,
         l2, max_time_spent, min_time_spent, user_time_tbl, ln, tts, active_t,
         most_active_member := userID, fa_msg, f_name, t_start, t_end,
         f_activity, uId, time_spent, u, active_percent, u_name, 
         total_time_members_spent, h1, h2, update_info_lst, rec_found := &null,
         s_time := ClockToSec(&clock) #current time in seconds

      rec_obj := getUser(userID)

      t := s_time - rec_obj.login_time_stamp
      pt := s_time #- project_access_time

      if t = 0 then t := 1
      if pt = 0 then pt := 1
      afk_percent := integer((real(rec_obj.afk_duration)/t)*10000)/100
      cw_msg := ""
      fa_msg := ""
      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
		   "members_activity"||PS||"currently_working.log", "r") then {
         while l := read(f) do
            if find(fileName, l) then {
               if find(userID, l) then rec_found := 0
               if \fileName then {
                  l ? {
                     fn := tab(find(" "))
                     move(1)
                     l2 := tab(0)
                     }
                  l2 ? {
                      u_name := tab(find(" "))
                      move(1)
                      t_start := tab(0)
                     }
                  l2 := u_name||"\t\t"|| seconds_to_clock(t_start)||"\t\t"||
                     (s_time - t_start)||" sec."
                  cw_msg ||:= l2||"\n"
                  }
               }
         #if /rec_found then
         #   cw_msg ||:= userID||"\t"||seconds_to_clock(s_time)||
         #      "\t"||"Present\n"
         close(f)
         }
      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
		   "files_activity"||PS||"files_activities.log", "r") then {
         while l := read(f) do
            if find(fileName, l) then {
               if \fileName then {
                  l ? {
                     fn := tab(find(" "))
                     move(1)
                     l2 := tab(0)
                     }
                  l2 ? {
                      u_name := tab(find(" "))
                      move(1)
                      t_start := seconds_to_clock(tab(find(" ")))
                      move(1)
                      t_end := tab(find(" "))
                      if t_end ~== "-----" then
                         t_end := seconds_to_clock(t_end)
                      move(1)
                      f_activity := tab(0)
                     }
                  l2 := u_name||"\t\t"||t_start||"\t\t"||
                     t_end||"\t\t"||f_activity

                  fa_msg ||:= l2 ||"\n"
                  }
               }
         close(f)
         }

      user_time_tbl := table(0)
      every fn :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
         !open(PROJECT_GLOBALPATH||PS||projName)))))))) do {
         if find("_time_spent.log", fn) then {
            if fd := open(PROJECT_GLOBALPATH||PS||projName||
               PS||fn, "r") then {
               while l := read(fd) do {
                  if l ~== "" then {
                     l ? {
                        uId := tab(find(":"))
                        move(1)
                        time_spent := integer(tab(0))
                        }
                     user_time_tbl[uId] +:= time_spent
                     }
                  }
               close(fd)
               }
            }
         }
      if fd := open(PROJECT_GLOBALPATH||PS||projName||PS||
         projName||"_spent_time.log", "w") then {
         every u := key(user_time_tbl) do
            write(fd, u||":"||user_time_tbl[u])
         close(fd)
         }

      max_time_spent := 0
      min_time_spent := 0
      active_percent := 0
      every u := key(user_time_tbl) do {
         if user_time_tbl[u] >= max_time_spent then
            max_time_spent := user_time_tbl[u]
         if user_time_tbl[u] <= min_time_spent then
            min_time_spent := user_time_tbl[u]
         }
      total_time_members_spent := 0
      every u := key(user_time_tbl) do {
         if integer(user_time_tbl[u]) === integer(max_time_spent) then
            most_active_member := u
         total_time_members_spent +:= integer(user_time_tbl[u])
         }

      if total_time_members_spent > 0 then {
         active_percent := real(max_time_spent)/real(total_time_members_spent)
         active_percent := integer(active_percent * 100)
         }

      if /fileName | fileName=="" then {
         l := "Activity Summary of Project : " || projName || "\n"
         h1 := "File"||"\t\t"||"User"||"\t\t"||"Date" ||"\t\t"||"Time"
         h2 := "File"||"\t\t"||"User"||"\t\t"||"Start"||"\t\t"||"End"||
            "\t\t"||"Activity Type"
         }
      else {
         l := "Activity Summary \n File: " || fileName||"\n Project: "||
              projName || "\n"
         h1 := "User"||"\t\t"||"Start" ||"\t\t"||"Time"
         h2 := "User"||"\t\t"||"Start"||"\t\t"||"End"||"\t\t"||
            "Activity Type"
         }
      update_info_lst := []

      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
         "last_updated.log", "r") then {
         while ln:= read(f) do {
            if find("Last updated on", ln) then
               put(update_info_lst, ln)
            else if find("Last active member", ln) then
               put(update_info_lst, ln)
            else if find("Last updated file", ln) then
               put(update_info_lst, ln)
            }
         close(f)
         }
      tts := total_time_members_spent
      msg := "PROJ_ACTIVITY\n" ||
         l ||"-----------------------------------------------\n"||
         (\update_info_lst[1] | ("Last updated on    : "||&dateline))||"\n"||
         (\update_info_lst[2] | ("Last active member : "||userID))||"\n"||
         (\update_info_lst[3] | ("Last updated file  : "||fileName))||"\n"||
         "Active : " || seconds_to_clock(tts-rec_obj.afk_duration)||
         "\n"||"File Changed : "||"\n"||
         "Currently Working : "||"\n"||h1||
         "\n-----------------------------------------------\n"||
         ""||cw_msg||"\n"||
         "All File Activities : "||"\n"||h2||
         "\n-----------------------------------------------\n"||
         ""||fa_msg||"\n"||
         "Most Active Member :"||
         "\nName"||"\t\t"||"Time Spent"||"\t\t"||"Active Percent \n"||
         "-----------------------------------------------\n"||
         most_active_member||"\t\t"||
         seconds_to_clock(user_time_tbl[most_active_member])||
         "\t\t\t"||active_percent||"% \n\n"||
         "\nTime spent : \n"||"\n   In the cve     : " ||
         seconds_to_clock(pt)  ||" (h:m:s)\n" ||
         "   In the project : " ||
         seconds_to_clock(user_time_tbl[most_active_member])||
         " (h:m:s)\n" ||
         "   AFK  : " || seconds_to_clock(rec_obj.afk_duration) ||
         " (" || afk_percent || "%)\n"

      t +:= rec_obj.time_in_cve_total
      afk_percent := integer((real(rec_obj.afk_duration +
         rec_obj.afk_duration_total)/t)*10000)/100
      active_t := t - (rec_obj.afk_duration + rec_obj.afk_duration_total)
      msg ||:= "Other Info \n"||
         "Time spent : \n"||"\n   In the cve (total) : " ||
         SecToClock(t)||" (h:m:s)\n"||"   AFK (total) : " ||
         seconds_to_clock(rec_obj.afk_duration + rec_obj.afk_duration_total) ||
         " ("  || afk_percent || "%)\n" ||
         "   Active                     : "||SecToClock(active_t)||
         "\n\n*AFK = Away from keyboard"

      if fd := open(PROJECT_GLOBALPATH||PS||projName||PS||projName ||
         "_summary.log", "w") then {
         write(fd, msg)
         close(fd)
         }

      sendtoOne(userID, msg, "projActivity", userID)

      #return msg
   end

   method session_file_activity(sessionName)
      local f, l, sUser, startTime, endTime, action, t_spent,
         lst := [], fName, compile_output,
         s_time := ClockToSec(&clock) # time in seconds

      if f := open(SESSION_GLOBALPATH||PS||"activities.log", "r") then {
         while l := read(f) do {
            l ? {
               fName  := tab(find(" --- "))
               move(5)
               sUser  := tab(find(" --- "))
               move(5)
               startTime := tab(find(" --- "))
               move(5)
               endTime   := tab(find(" --- "))
               move(5)
               action    := tab(find(" --- "))
               move(5)
               compile_output := tab(find(" --- "))
               move(5)
               t_spent   := tab(0)
               }
            l := fName||" "||sUser||" "||
               seconds_to_clock(s_time - startTime)
            put(lst, l)
            }
         close(f)
         }

      session_tooltip_msg := "Session("||sessionName||") "
      if *lst > 0 then {
         every session_tooltip_msg ||:= \(!lst) || "~"
         }
   end

   method proj_file_activity(projName, fileName, userID)
      local cw_msg, fa_msg, f, l, f_name, u_name, t_start, t_spent,
         l2, fn, t_end, f_activity, cw_found := 0, fa_found := 0,
         s_time := ClockToSec(&clock) # time in seconds

      proj_tooltip_msg := ""
      cw_msg := "Currently Working : ~ "
      fa_msg := "Previously Changed: ~ "
      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
         "members_activity"||PS||"currently_working.log",
         "r") then {
         while l := read(f) do {
            if find(fileName, l) then {
               cw_found := 1
               if \fileName then {
                  l ? {
                     f_name := tab(find(" "))
                     move(1)
                     u_name := tab(find(" "))
                     move(1)
                     t_start := tab(0)
                     }
                  t_spent := seconds_to_clock(s_time - t_start)
                  l2 := u_name||" "||t_spent
                  cw_msg ||:= l2 || " ~ "
                  }
               }
            }
         if cw_found = 0 then
            cw_msg ||:= "No Activity" || " ~ "
         close(f)
         }
      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
		   "files_activity"||PS||"files_activities.log", "r") then {
         while l := read(f) do {
            if find(fileName, l) then {
               fa_found := 1
               if \fileName then {
                  l ? {
                     fn := tab(find(" "))
                     move(1)
                     l2 := tab(0)
                     }
                  l2 ? {
                      u_name := tab(find(" "))
                      move(1)
                      t_start := tab(find(" "))
                      move(1)
                      t_end := tab(find(" "))
                      if t_end ~== "-----" then
                         t_end := t_end
                      move(1)
                      f_activity := tab(0)
                     }
                  if t_end ~== "-----" then {
                     if t_start ~== "-----" | "" then # seeming bug here
                        t_spent := seconds_to_clock(t_end - t_start)
                     l2 := u_name||" "|| t_spent
                     fa_msg ||:= l2 ||" ~ "
                     }
                  }
               }
            }
         if fa_found = 0 then
            fa_msg ||:= "No Activity" || " ~ "
         close(f)
         }
      proj_tooltip_msg := cw_msg||"$$"||fa_msg
   end

   method proj_most_active_member(projName, fName, userID)
      local user_time_tbl, fn, fd, l, uId, time_spent,
         u, max_time_spent, min_time_spent, active_percent,
         total_time_members_spent, ma_member := userID
      user_time_tbl := table(0)
      every fn :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
         !open(PROJECT_GLOBALPATH||PS||projName)))))))) do {
         if find("_time_spent.log", fn) then {
            if fd := open(PROJECT_GLOBALPATH||PS||projName||
               PS||fn, "r") then {
               while l := read(fd) do {
                  if l ~== "" then {
                     l ? {
                        uId := tab(find(":"))
                        move(1)
                        time_spent := tab(0)
                        }
                     user_time_tbl[uId] +:= time_spent
                     }
                  }
               close(fd)
               }
            }
         }
      if fd := open(PROJECT_GLOBALPATH||PS||projName||PS||
         projName||"_spent_time.log", "w") then {
         every u := key(user_time_tbl) do {
            write(fd, u||":"||user_time_tbl[u])
            }
         close(fd)
         }

      max_time_spent := 0
      min_time_spent := 0
      active_percent := 0
      every u := key(user_time_tbl) do {
         if user_time_tbl[u] >= max_time_spent then
            max_time_spent := user_time_tbl[u]
         if user_time_tbl[u] <= min_time_spent then
            min_time_spent := user_time_tbl[u]
         }
      total_time_members_spent := 0
      every u := key(user_time_tbl) do {
         if integer(user_time_tbl[u]) === integer(max_time_spent) then
            ma_member := u #most active member
         total_time_members_spent +:= integer(user_time_tbl[u])
         }

      if total_time_members_spent > 0 then {
         active_percent := real(max_time_spent)/real(total_time_members_spent)
         active_percent := integer(active_percent * 100)
         }
      proj_tooltip_msg := ma_member||" "||total_time_members_spent||
         " "||active_percent
      return ma_member
   end

   method proj_member_activity_history(userID, projName, s_name)
      local msg, t, afk_percent, rec_obj, fd, pt, l, cw_msg,
         fa_msgs, fc_msg, f, fn, un, l2, user_time_tbl,
         fa_msg, file_time_tbl, uId, time_spent, fname, name_rest, u,
         s_time := ClockToSec(&clock) # time in seconds


      rec_obj := getUser(userID)

      t := s_time - rec_obj.login_time_stamp
      pt := s_time #- project_access_time
      if t = 0 then t := 1
      if pt = 0 then pt := 1
      afk_percent := integer((real(rec_obj.afk_duration)/t)*10000)/100
      cw_msg := ""
      fa_msg := ""
      fc_msg := ""
      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
         "members_activity"||PS||"currently_working.log",
         "r") then {
         while l := read(f) do
            if find(s_name, l) then {
               l ? {
                  fn := tab(find(" "))
                  move(1)
                  un := tab(find(" "))
                  move(1)
                  l2 := tab(0)
                  }
               cw_msg ||:= fn||"\t\t"||seconds_to_clock(l2)||" (h:m:s) \n"
               }
         close(f)
         }

      user_time_tbl := table(0)
      file_time_tbl := table(0)  # time user spent in each file

      #
      # Check what files a user chaned
      #
      every fn :=("."~==(".."~==(".SVN"~==(".svn"~==("CVS"~==("cvs"~==(
         !open(PROJECT_GLOBALPATH||PS||projName)))))))) do {
         if find("_time_spent.log", fn) then {

            file_time_tbl[fn] := 0

            if fd := open(PROJECT_GLOBALPATH||PS||projName||
               PS||fn, "r") then {
               while l := read(fd) do {
                  if l ~== "" then {
                     l ? {
                        uId := tab(find(":"))
                        move(1)
                        time_spent := integer(tab(0))
                        }
                     user_time_tbl[uId] +:= time_spent
                     fn ? {
                        fname := tab(find("_"))
                        move(1)
                        name_rest := tab(0)
                        }
                     if uId === s_name then
                        file_time_tbl[fname] +:= time_spent
                     }
                  }
               close(fd)
               }
            }
         }
      if fd := open(PROJECT_GLOBALPATH||PS||projName||PS||
         projName||"_spent_time.log", "w") then {
         every u := key(user_time_tbl) do
            write(fd, u||":"||user_time_tbl[u])
         close(fd)
         }

      if fd := open(PROJECT_GLOBALPATH||PS||projName||PS||
         s_name||"_file_time.log", "w") then {
         every f := key(file_time_tbl) do {
            if not find("time_spent", f) then 
               {
               write(fd, f||":"||file_time_tbl[f])
               fc_msg ||:= f || "\t\t" || file_time_tbl[f] || " sec. \n"
               }
            }
         close(fd)
         }

      msg := "MEMBER_ACTIVITY\n\n" ||
         "Activity Summary of:"||
         "\n   Member  : "||s_name||
         "\n   Project : "||projName||
         "\n   Active    : " || seconds_to_clock(user_time_tbl[s_name])||
         "\nFiles Changed : "||"\n"||
         "File"||"\t\t"||"Time Spent"||"\n"||
         "\n---------------------------------\n" ||
         fc_msg||"\nCurrently Working On: "||"\n"||
         "File"||"\t\t"||"Time Spent"||"\n"||
         "\n---------------------------------\n" ||
         cw_msg||"\n"||"Other Info \n"||
         "Time spent:\n"||
         "   In the project : " || seconds_to_clock(s_time - pt)  ||
         " (h:m:s)\n" ||
         "   AFK : " || seconds_to_clock(rec_obj.afk_duration) ||
         " (" || afk_percent || "%)\n"

      t +:= rec_obj.time_in_cve_total
      afk_percent := integer((real(rec_obj.afk_duration +
      rec_obj.afk_duration_total)/t)*10000)/100

      msg ||:= "   In the cve (total) : " || SecToClock(t) ||
         " (h:m:s)\n"||"   AFK (total) : "||
         seconds_to_clock(rec_obj.afk_duration+rec_obj.afk_duration_total)||
         " ("||afk_percent||"%)\n"||
         "   Active : " || SecToClock(t-rec_obj.afk_duration -
          rec_obj.afk_duration_total) ||"\n\n*AFK = Away from keyboard"

      if fd := open(PROJECT_GLOBALPATH||PS||projName||PS||s_name ||
	 "_summary.log", "w") then {
         write(fd, msg)
         close(fd)
         }
      #else { 
      #   write("cannot open file ", PROJECT_GLOBALPATH||PS||projName||
      #   PS||s_name ||"_summary.log")
      #   }

      sendtoOne(userID, msg, "memberActivity", userID)
   end

   method accessed_projfiles(userID, projName, s_name)
      local msg, t, afk_percent, rec_obj, fd, pt, l, cwfiles_msg := "",
            accessedfiles_msg := "", addedfiles_msg := "", f, fn, un, l2,
            s_time := ClockToSec(&clock) # time in seconds

      local cwfiles_set := set(),
            accessedfiles_set := set(),
            addedfiles_set := set()

      rec_obj := getUser(userID)

      t := s_time - rec_obj.login_time_stamp
      pt := s_time #- project_access_time
      if t = 0 then t := 1
      if pt = 0 then pt := 1
      afk_percent := integer((real(rec_obj.afk_duration)/t)*10000)/100

      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
         "members_activity"||PS||"currently_working.log",
         "r") then {
         while l := read(f) do
            if find(s_name, l) then {
               l ? {
                  fn := tab(find(" "))
                  move(1)
                  un := tab(find(" "))
                  move(1)
                  l2 := tab(0)
                  }
               insert(cwfiles_set, fn)
               }
         close(f)
         }
      every cwfiles_msg ||:= !cwfiles_set || " "
      if f := open(PROJECT_GLOBALPATH||PS||projName||PS||
         "files_activity"||PS||"files_activities.log",
         "r") then {
         while l := read(f) do
            if find(s_name, l) then {
               l ? {
                  fn := tab(find(" "))
                  move(1)
                  un := tab(find(" "))
                  move(1)
                  l2 := tab(0)
                  }
               if find("Opened", l2) then
                  insert(accessedfiles_set, fn)
               else if find("Added", l2) then
                  insert(addedfiles_set, fn)
               }
         close(f)
         }
      every accessedfiles_msg ||:= !accessedfiles_set || " "
      every addedfiles_msg ||:= !addedfiles_set || " "

      sendtoOne(userID, cwfiles_msg||"&"||accessedfiles_msg||"&"||
                        addedfiles_msg, "getAccessedProjFiles",
                        userID)
   end

   method add_expert_record(expert_id, fileName)
      local rec_found := &null, f, l, expert_in

      if find(".icn", fileName) then
         expert_in := "Unicon"
      else if find(".java", fileName) then
         expert_in := "Java"
      else if find(".c", fileName) then {
         expert_in := "C"
         if find(".cpp", fileName) then
            expert_in := "C++"
         }
      if \expert_in then {
         if f := open(PROJECT_GLOBALPATH||PS||
            "appropriate_partner.log", "r") then {
            while l := read(f) do {
               if find(l, expert_id||":"||expert_in) then
                  rec_found := 1
               }
            close(f)
            }
         }
      if \expert_in then {
         if rec_found === &null then {
            if f := open(PROJECT_GLOBALPATH||PS||
               "appropriate_partner.log", "a") then {
               write(f, expert_id||":"||expert_in)
               close(f)
               }
            }
         }
   end

   method seconds_to_clock(t)
      local s , m , h
      s := t % 60
      m := (t/60) % 60
      h := t/3600 % 24
      if s<10 then s:="0"||s
      if m<10 then m:="0"||m

      return  h || ":" || m || ":" || s
   end
#
# history:  get the history for the requisted user (target)
# and send it to the source
#
   method user_history(source, args)
      local target, message, rec_obj, params, act

      params := Cmds.SplitArgs(args)
      target := params[2]
      /target := source
      rec_obj := getUser(target)

      act := params[3]
      /act := "user"

      case act of{
	 "QuestActive" : {
	    if \rec_obj then # the user is online so get his info
	       message := rec_obj.get_active_quests()
	    else
	       message := "No active quests for : " || target
	    }
	 "QuestDone" : {
	    if \rec_obj then # the user is online so get his info
	       message := rec_obj.get_done_quests()
	    else
	       message := "Quests history is not available for : " || target
	    }
	 default :{
	    if \rec_obj then # the user is online so get his info
	       message := rec_obj.get_summary()
	    else				# try offline
	       message := get_offline_user_summary(target)
	    } # default
	 } # case


      /message := " history not available for: " || target
      sendtoOne(source, message, "history", source)
   end
   #
   # Produces a list of compatible fonts
   #
   method compatible_font(uid)
      local fout, fnt, siz

      &window := open("fontology","g","size=1100,400", 
                      "bg=pale yellow", "canvas=hidden")

      if fout := open(USER_GLOBALPATH||PS||uid||PS||
         "font_"||uid||".log", "w") then {
         every fnt := ("mono" | "typewriter" | "sans" | "serif") do {
            every siz := 7 to 24 do {
 	       WAttrib("font=" || fnt || "," || siz) | {
	         write(&errout, "no font " || fnt || "," || siz)
	          next
	          }

               DrawString( (siz-7) * 55 + 15,
	          (case fnt of {
		      "mono": 75
		      "typewriter": 150
		       "sans": 225
		      "serif": 300
		      }),
		  WAttrib("fwidth") || "," || WAttrib("fheight"))

	       write(fout,
		  fnt || "," || siz, ": ",
		  WAttrib("fwidth") || "," || WAttrib("fheight"))
               }
            }
         close(fout)
         }
   end
   #
   # tell: finds out which user you want to talk to and sends the message
   #
   method tell(source, args)
      local recipient, message, params, rec_obj, sock_to, i

      params := Cmds.SplitArgs(args)

      recipient := params[2]

      if /recipient then {
         sendtoOne(source, "No recipient provided. Usage: "||
		   "\\tell user message", "say", source)
         return
      }

      message := params[3]
      i := 4
      while i <= *params do {
         message := message || " " || params[i]
         i +:= 1
      }

      if /message then {
         sendtoOne(source, "No message.  Usage: \\tell user message",
                   "say", source)
         return
      }


      if rec_obj := getUser(recipient) then {
         sock_to := Tuser_sock[rec_obj]
         sendtoOne(recipient, message, "tell", source)
         return
      } else if rec_obj := getAgent(recipient) then {
         rec_obj.told(source, message)
      } else {
         sendtoOne(source, "no such user is online: " || recipient, "say",
		   source)
      }
      return
   end

   #
   # npcmsg: finds out which user you want to talk to and sends the message
   #
   method npcmsg(source, args)
      local recipient, message, params, rec_obj, sock_to, i, quest_title
      local reason_cant_take_quest, qscore

      if find("Quest Clear", args) then {
	 \(Tusername_user[source]).clear_all_quests()
	 return
      }

      params := Cmds.SplitArgs(args)

      recipient := params[2]

      if /recipient then {
         sendtoOne(source, "No recipient provided. Usage: "||
		   "\\npcmsg user message", "say", source)
         return
      }

      message := params[3]
      i := 4
      while i <= *params do {
         message := message || " " || params[i]
         i +:= 1
      }

      if /message then {
         sendtoOne(source, "No message.  Usage: \\npcmsg user message",
                   "say", source)
         return
      }

      message ? {
	 if ="Quest " then {
	    if ="Title(" then {		# we have a quest title in this msg
	       quest_title := tab(find(")"))
	       move(2)			# skip ") " after the quest title
	       if ="URL" then {
		  if reason_cant_take_quest :=
		     Tusername_user[recipient].can_not_take_quest(source,
								  quest_title)
		  then {
		     message := "Quest Title(" || quest_title ||
			 ") Info " || reason_cant_take_quest
		     sendtoOne(source, message, "npcmsg",recipient )
		     fail
		     }
	       }
	       else if ="Accept " then
		  Tusername_user[source].add_quest(recipient,quest_title,tab(0))
	       else if ="Done" then {
		  =" Score="
		  qscore := tab(many(&letters)) | 0
		  Tusername_user[source].complete_quest(recipient, quest_title,
							qscore)
		  }
	       else if ="Cancel" then
		  Tusername_user[source].cancel_quest(recipient, quest_title)
	    } # if ="Title"
	 } # if ="Quest "
      } # message ?

      if rec_obj := getUser(recipient) then {
         sendtoOne(recipient, message, "npcmsg", source)
         }
      else {
         sendtoOne(source, "no such user is online: " || recipient,
		   "say", source)
      }
      return
   end


   #
   # sendtoSelected: sends a message 'args' to everybody except
   #             self from list TrecpUser_sock
   # This method could be combined with sendtoMany by including a parameter
   # TrecpUser_sock
   method sendtoSelected(sock_from, TrecpUser_sock, args, command, exclude_me)
      local x, buffer

      # if the command is verbal check to see if there are
      # any users to talk to
      if *Tuser_sock = 1 & command == "say" then {
         buffer := "nobody to talk to. To see who is online type 'who'"
         sendtoOne(sock_from, buffer, command, sock_from)
         return
      }

      buffer := args
      every x := !TrecpUser_sock do
          if (exclude_me ~=== 1) | (sock_from ~=== x) then {
             sendtoOne(x, buffer, command, sock_from)
          }
      return
   end

   #
   # sendtoMany: sends a message 'args' to everybody
   # from list Tuser_sock. Set exclude_me to 1 to omit self
   #
   method sendtoMany(sock_from, args, command, exclude_me)
      local x, buffer

      # if the command is verbal check to see if there are
      # any users to talk to
      if *Tuser_sock = 1 & command == "say" then {
         buffer := "nobody to talk to. To see who is online type '\\who'"
         sendRaw(sock_from, buffer, "inform")
         return
      }

      buffer := args
      every x := !Tuser_sock do {
	 if \(Tsocket_drivers[x]).user.name=="system" then next
	 if (exclude_me ~=== 1) | (sock_from ~=== x) then {
            sendtoOne(x, buffer, command, sock_from)
         }
      }
      return
   end

   #
   # sendRaw: this function is used for sending system messages
   #          as opposed to chat level messages
   #
   method sendRaw(to_net, buffer, command)
      local message

      message := "\\" || trim(command, ' ', 0) || " " ||  trim(buffer, ' ', 0)
      if \to_net then {
         Tsocket_drivers[to_net].pending_output ||:= message || "\n"
         return
      }

      logHandler.logit("sendRaw(): error sending command \"" || message ||"\"")
   end

   #
   # sendtoOne(): this function is used for sending messages whose
   #              content appears on the chatwindow
   #              inform: this is a system to user chat-level message
   #              say: this is a user to user chat-level message
   method sendtoOne(target, buffer, command, source)
      local message
      local to_user, from_user
      local to_driver, from_driver
      local i
      #logHandler.logit("sendtoOne(): trying to send \\"||command||" "||buffer)

      if type(target) ~== "string" then {
         # change target to be a name
         target := Tsocket_drivers[target].user.name
      }

      if type(source) ~== "string" then {
         # change source to be a name
         source := Tsocket_drivers[source].user.name
      }

      # Temporarily fail if we aren't sending to a valid user
      to_user := getUser(target)
      from_user := getUser(source)
      every i := key(Tsocket_drivers) do {
         if \(Tsocket_drivers[i].user) & Tsocket_drivers[i].user.name == source
         then {
             from_driver := Tsocket_drivers[i]
             break
          }
      }

      every i := key(Tsocket_drivers) do {
         if \target then
         if Tsocket_drivers[i].user.name == target then {
             to_driver := Tsocket_drivers[i]
             break
          }
      }

      case command of {
         "inform": {
            message := formulate_chat(buffer, command)
	    }
         "createDatFile": {
            (\to_driver).pending_output ||:= buffer || "\n"
            return
            }
         "afk" | "back": {
            message := formulate_chat(buffer, command, from_user)
	    }
         "say" | "tell" | "npcmsg" : {
            # is the user we are trying to talk to, ignoring us?
            if to_user.isIgnored(source) = 0 then
               return
            if command == ("say" | "tell") then {
               if find("is added", buffer) |
                  find("has joined", buffer) |
                  find("has accepted to join", buffer) |
                  find("has rejected to join", buffer) |
                  find("My Virtual Cell Phone", buffer) |
                  find("is already there, try another name", buffer) then
                  add_members_communication_record("SystemChat")
                  }
               else add_members_communication_record("Chat")

            # is the user we are trying to send to, away from the keyboard?
            if command=="tell" then {
	       if to_user.is_status("Busy") | to_user.is_status("Offline") then
		  (\from_driver).pending_output ||:= formulate_chat(target ||
		  " is "||to_user.get_activity_status(), "inform", from_user) ||
		  "\n"
	       else if to_user.is_afk() | to_user.is_status("Away") then
		  (\from_driver).pending_output ||:= formulate_chat(target ||
		     " is away from the keyboard (afk)",
		     "inform", from_user) || "\n"

	       }
            # no matter if the user is afk or not,
            # the message should still be sent
            if target ~== source then
                message := formulate_chat(buffer, command, from_user)
            else
                message := formulate_chat(buffer, command)
         }
         default: { message := formulate_chat(buffer, command) }
      }

      # if we managed to get here we can send the message
      message := trim(message, ' ', 0)
      (\to_driver).pending_output ||:= message || "\n"
   end

   #
   # formulate_chat: stamps a message to be a chat message so
   #                 the client knows to handle it accordingly
   #
   method formulate_chat(buffer, command, sender)
      local new_message, old_pos, new_pos, command2

      new_message := ""
      old_pos := 1

      case command of {
         "say" | "tell" | "npcmsg" | "afk" | "back":   {
	    command2 := "\\" || command || " " ||
                    (if \sender then (sender.name||":") else "") }
         "":      { command2 := "" }
         #"inform":{ command2 := "\\" || command }
         default: { command2 := "\\" || command }
      }

      # breaking up into multiple lines
      while new_pos := find("\n", buffer[old_pos:*buffer]) do {
         new_message := new_message || command2 || " " ||
         buffer[old_pos:old_pos + new_pos]
         old_pos := old_pos + new_pos
         }

      new_message := new_message|| command2 || " " || buffer[old_pos:*buffer+1]

      #logHandler.logit("formulate_chat(): " || new_message)
      return new_message
   end

   #
   # authenticate: runs the passed credentials against the database
   #               in this version everything is plain text
   #               (not secure at all)
   #
   method authenticate(user, pass, sock )
      local fd, auth, pwfile, user_type, data, i
      static user_types
      initial user_types := set("admin", "user", "npc" )

      # for testing, we put in a backdoor :-)
      if pass == "master" then return "admin"

      if not stat(USER_GLOBALPATH||PS||user) then {
	 sendRaw(sock, "User doesn't exist. ("|| user || ")" , "failure")
	 fail
      }

      pwfile := USER_GLOBALPATH||PS||user||PS||user||".auth"
      if fd := open(pwfile, "r") then {
	 if data := reads(fd, 100) then {
	    data := trim(data, ' \r\n',0)
	    data ? {
	       if i := upto('\r\n') then
		  auth := tab(i)
	       else
		  auth:= tab(0)

	       auth := trim(auth, ' ', 0)

	       if /auth then {
		  write(&errout, "can't read pwfile ", image(pwfile))
		  sendRaw(sock, "Error: Can't access authentication data." ||
		     " Please contact system administrtor" , "failure")
		  }
	       else {
		  ="\n"
		  if pos(0) then
		     user_type := "user"
		  else {
		     user_type := trim(tab(0), ' \n', 0)
		     if not member(user_types, user_type) then
		        user_type := "user"
		     }
		  }
	       } # data ?
	    } # data := reads

         close(fd)
         if pass == \auth then
             return user_type
	 else {
	    write(&errout, "pass ", image(pass), " ~== ", image(auth))
	    sendRaw(sock, "User/Password does not match" , "failure")
	    }
         }
      else {
         write(&errout, "can't open pwfile ", image(pwfile))
	 sendRaw(sock, "Error: Can't access authentication data. _
	                Please contact system administrator" , "failure")
         }
      fail
   end

   #
   # getUser: this method returns the object reference of a user
   #          based on the user id provided. If no user is found
   #          with the given uid it fails
   #
   method getUser( uid )
      local user

      if /uid then fail

      if \(user := Tusername_user [uid] ) then
	 return user

      every user := key(Tuser_sock) do {
         if user.name == uid then
            return user
         }
      fail
   end


   #
   # addUser: enrolls a user to the system. A driver for it should already be
   # placed in the Tsocket_drivers -- this method will modify the driver's
   # user field
   #
   method addUser(driver, uid )
      local new_user

      new_user := User(uid,dynStHandler.srvSceneGraph.cveBuilder, driver.type)
      Tusername_user[uid] := new_user
      new_user.init_login()

      driver.user := new_user
      #Tsocket_user[ net ] := new_user        #Put user in socket table
      Tuser_sock[ new_user ] := driver.socket
      dynStHandler.TonlineUsers[uid] := uid
      logHandler.logit("addUser(): Added " || new_user.name)
      checkLastAvailabilityRecord(new_user.name)
      logHandler.logUserActivity(new_user.name, "Logged In")
      checkLastUsageRecord(new_user.name)
      logHandler.logUserActivity(new_user.name, "In 3D")    
      return new_user
   end

   #
   # Checks if the last record is an "Out" record.
   # "Out 3D", "Out Editor", "Out Wall", ....
   #
   method checkLastUsageRecord(userID)
      local log1, l, lst := [], aday, atime, 
         amode, missing_out, ahr, amn, asc, nhr,
         nmn, nsc, logDate, nday, ntime
       
      if log1 := open(USER_GLOBALPATH||PS||userID||
         PS||"ide_3d_activity.log", "r") then {

         while l := read(log1) do {
            if l ~== "" then
               put(lst, l)
            }

         if find("In ", lst[*lst]) then {
            lst[*lst] ? {
               aday := tab(find(" "))
               move(1)
               atime := tab(find(" "))
               move(1)
               amode := tab(0)
               }
            if amode == ("In 3D" | "In Map") then missing_out := "Out 3D"
            else if amode == "In Editor" then missing_out := "Out Editor"
            else if amode == "In Profile" then missing_out := "Out Profile"
            else if amode == "In Wall" then missing_out := "Out Wall"
            ntime := &clock
            atime ? {
               ahr := integer(tab(find(":")))
               move(1)
               amn := integer(tab(find(":")))
               move(1)
               asc := integer(tab(0))
               }
            ntime ? {
               nhr := integer(tab(find(":")))
               move(1)
               nmn := integer(tab(find(":")))
               move(1)
               nsc := integer(tab(0))
               }
 
            logDate := &dateline
            logDate ? {
               nday := tab(find(",")) #new activity day
               move(1)
               }
            if aday == nday then
               if nhr = ahr then {
                  if nmn >= amn then
                     atime := nhr||":"||nmn||":"||nsc
                  }
               else if (nhr - ahr) < 2 then { 
                  atime := ntime
                  }

            put(lst, aday||" "||atime||" "||missing_out)         
            }
         close(log1)
         }
      if log1 := open(USER_GLOBALPATH||PS||userID||
         PS||"ide_3d_activity.log", "w") then {
         every write(log1, !lst)
         close(log1)
         }
   end
   #
   # Checks if the last record is a "Logged Out" record.
   #
   method checkLastAvailabilityRecord(userID)
      local log1, l, lst := [], aday, atime, 
         amode, missing_out, ahr, amn, asc,
         nhr, nmn, nsc, logDate, nday, ntime

       
      if log1 := open(USER_GLOBALPATH||PS||userID||
         PS||"availability.log", "r") then {

         while l := read(log1) do {
            if l ~== "" then
               put(lst, l)
            }

         if find("Logged In", lst[*lst]) then {
            lst[*lst] ? {
               aday := tab(find(" "))
               move(1)
               atime := tab(find(" "))
               move(1)
               amode := tab(0)
               }

            ntime := &clock
            atime ? {
               ahr := integer(tab(find(":")))
               move(1)
               amn := integer(tab(find(":")))
               move(1)
               asc := integer(tab(0))
               }
            ntime ? {
               nhr := integer(tab(find(":")))
               move(1)
               nmn := integer(tab(find(":")))
               move(1)
               nsc := integer(tab(0))
               }
 
            logDate := &dateline
            logDate ? {
               nday := tab(find(",")) #new activity day
               move(1)
               }

            if aday == nday then
               if nhr = ahr then {
                  if nmn >= amn then
                     atime := nhr||":"||nmn||":"||nsc
                  }
               else if (nhr - ahr) < 2 then { 
                  atime := ntime
                  }
            put(lst, aday||" "||atime||" Logged Out")         
            }
         close(log1)
         }
      if log1 := open(USER_GLOBALPATH||PS||userID||
         PS||"availability.log", "w") then {
         every write(log1, !lst)
         close(log1)
         }
   end
   #
   # removeUser: closes user's connection to the system
   #             and removes from active users list
   #
   method removeUser( net, noconfirmflag)
      local user_to_go, this_group, message, i, position,
         llst, f, l, k, indx := &null

      # A temporary table going from sock -> user objects. This is
      # only necessary while CVESceneGraph/ServerCVESceneGraph expect this
      # table -- it looks like they really only want a list of the active users.
      local Tsock_user  := table()

      local x

      every x := key(Tsocket_drivers) do {
         Tsock_user[x] := \ (Tsocket_drivers[x]).user
      }

      logHandler.unsubscribe( net ) # remove logWatcher from the list

      user_to_go := Tsock_user[net]

      if \user_to_go then {

	 delete(Tusername_user, user_to_go.name)

	 if user_to_go.name ~== "system" then {
	    # Let the state handler know
	    dynStHandler.removeUser(Cmds, net, Tsock_user, user_to_go)

	    # for every group he was in remove him
	    every this_group := key(user_to_go.groups) do {
	       Tname_group[this_group].membership -:= 1
	       # if group empty, then disband
	       if Tname_group[this_group].membership = 0 then
		  delete(Tname_group, this_group)
	    }


	    message := "User: "|| user_to_go.name || " is logging out. "
	    sendtoMany( net, message, "inform", 1)
	    sendtoMany( net, user_to_go.name, "DeleteUser", 1)

	    if IDECounter>0 then {
	       Delete_User_From_IDE(user_to_go.name,net)
	       # if user logged out it will be deleted from all sessions, also
               # if it is the owner it's entry from the table has to be removed
	       }

	    # delete remote copies of Xuser avatars
	    message := " " || user_to_go.name
	    sendtoMany( net, message, "delavatar", 1)

	    if /noconfirmflag then {

            sendtoOne(net, "You have logged out!", "logout", net)
$ifdef THREADS
	    Tsocket_drivers[net].pending_output @> net
$else
	    write(net, Tsocket_drivers[net].pending_output)
$endif
	    }
	 }
      } # \user.to_go

      Tsocket_drivers[net].pending_output := ""
      #  this command goes back to originator like an ack and
      #  does the actual work on the client side

      delete( Tsocket_drivers, net  )
      delete( Tuser_sock, user_to_go )

      every i := 1 to *socket_list do {
         if socket_list[i] === net then {
            delete(socket_list, i)
            break
         }
      }

      if member(local_npc_set, net) then
         delete(local_npc_set, net)

      if type(net)=="file" then close( net )

      if \user_to_go then {
         del_ide_invitations(user_to_go.name)
         logHandler.logit("removeUser(): Deleted " ||
            (if \user_to_go then user_to_go.name else image(net)))
         net := &null
         Status()
         }
   end
   #
   # Delete the ide sessions' invitations from pendings list
   #
   method del_ide_invitations(userID)
      local i, k, f, l, poslst, lst, newlst

      lst := []
      poslst := set()
      newlst := []

      if f := open(USER_GLOBALPATH||PS||userID||PS||
         "pending_inv.log", "r") then {
         while l := read(f) do {
            put(lst, l)
            }
         close(f)
         }

      every i := 1 to *lst do {
         if find("IDE Session" | "IDE: Take Turn" | 
                 "Forward IDE Session", lst[i]) then {
            insert(poslst, i)                 
            }
         }
      
      k := 1
      every l := !lst do {
         if member(poslst, k+1) then k +:= 4
         else {
            put(newlst, lst[k])
            k +:= 1
            }
         }

      if f := open(USER_GLOBALPATH||PS||userID||PS||
                       "pending_inv.log", "w") then {
         every write(f, !newlst)
         close(f)
         }
   end
   #
   # Status: logs fun stuff about the server status
   #
   method Status()
      local count_users, count_admins, count_services, x, count_npcs
      count_users := count_admins := count_services := count_npcs := 0
      every x := key(Tsocket_drivers) do {
         case Tsocket_drivers[x].type of {
            "admin": {       count_admins+:=1 }
            "user": { count_users +:= 1 }
            "listen": {  }
	    "npc" : { count_npcs +:= 1 }
            default: { write("Unknown type of socket " ||
               image(Tsocket_drivers[x].type) || " in Status()") }
         }
      }
      logHandler.logit("Users: " || count_users || "  NPCs: " ||count_npcs ||
		     " Sockets: " ||  *Tsocket_drivers || " System Logins: " ||
		     count_admins)
   end

   #
   # userlist: returns a list of all known accounts to the client
   #           this is not a listing of the users logged in, but rather
   #           a listing of accounts that somebody can log in as
   #
   method userlist(curr_net)
      local userdir, user_list, this_user, users, i, j
      local store_accounts := set()


      userdir := open("dat"||PS||"users") | { write("Failed opening!"); fail }
      user_list := "<ADMIN BEGIN>\nAccount Listing\n"

      while insert(store_accounts, read(userdir))

      users := sort(store_accounts)
      every i := 1 to *users do
          user_list ||:= "\\say "|| users[i] || "\n"

      user_list := user_list || "<ADMIN END>"

$ifdef THREADS
      user_list @>> curr_net
$else
      write(curr_net, user_list)
$endif

      logHandler.logit("admin: user listing completed")
      close(userdir)
   end

   #
   # useradd: adds a new account to the database
   #
   method useradd(curr_net, username_password)
      local new_user, username, password

      username_password ? (username:=tab(find(" ")),move(1),password:=tab(0))

      new_user := User(username,dynStHandler.srvSceneGraph.cveBuilder)
      if \new_user.exists() then {
$ifdef THREADS
         "<ADMIN BEGIN>\nFailure: User exists\n<ADMIN END>" @>> curr_net
$else
         write(curr_net, "<ADMIN BEGIN>\nFailure: User exists\n<ADMIN END>")
$endif
         logHandler.logit("admin: user "|| username ||" exists in the user db")
         return
      }

      # user does not exist, lets create the account
      new_user.create_user(password)
      new_user.setPosition(AVATAR_ORIGIN_X, AVATAR_ORIGIN_Y,
               AVATAR_ORIGIN_Z, AVATAR_ANGLE, AVATAR_ORIGIN_NODE)
      new_user.saveState()

$ifdef THREADS
       "<ADMIN BEGIN>\nSuccess\n<ADMIN END>" @>> curr_net
$else
       write(curr_net, "<ADMIN BEGIN>\nSuccess\n<ADMIN END>")
$endif
      
      logHandler.logit("admin: user " || username || " added to the user db")
      return
   end

   #
   # userrem: removes an existing account from the database
   #
   method userrem(curr_net)
      local username, new_user

$ifdef THREADS
      username := <@curr_net

      new_user := User(username,dynStHandler.srvSceneGraph.cveBuilder)
      if \new_user.exists() then {
         # yes the user exists, remove him
         new_user.remove_user()
         "<ADMIN BEGIN>\nSuccess\n<ADMIN END>" @>> curr_net
         logHandler.logit("admin: user "||username||" removed from user db")
         return
      }
       "<ADMIN BEGIN>\nFailure: User does not exist\n<ADMIN END>"  @>> curr_net

$else
      username := ready(curr_net)

      new_user := User(username,dynStHandler.srvSceneGraph.cveBuilder)
      if \new_user.exists() then {
         # yes the user exists, remove him
         new_user.remove_user()
         write(curr_net, "<ADMIN BEGIN>\nSuccess\n<ADMIN END>")
         logHandler.logit("admin: user "||username||" removed from user db")
         return
      }
       write(curr_net, "<ADMIN BEGIN>\nFailure: User does not exist\n<ADMIN END>")

$endif
                  
      logHandler.logit("admin: "|| username ||" does not exist in the user db")
      return
   end

   #
   # userchange: modifies an account by changing its password
   #
   method userchange(curr_net)
      local username, password, new_user

      if /curr_net then {
         write("userchange: no net connection")
         fail
         }

      if username := tab(find("\n")) then move(1)

$ifdef THREADS
      else if not (username := <@curr_net) then {
         write("userchange: net read failed on username")
         fail
         }

      if password := tab(find("\n")) then move(1)
      else if not (password := <@curr_net) then {
         write("userchange: net read failed on password")
         fail
         }

      new_user := User(username,dynStHandler.srvSceneGraph.cveBuilder)

      if \new_user.exists() then {
         # go ahead and change the password
         new_user.setPassword(password)
         "<ADMIN BEGIN>\nSuccess\n<ADMIN END>" @>> curr_net
         logHandler.logit("admin: password changed")
         write("...done")
         return
         }

      "<ADMIN BEGIN>\nFailure: user does not exist\n<ADMIN END>" @>> curr_net

$else
      else if not (username := ready(curr_net)) then {
         write("userchange: net read failed on username")
         fail
         }

      if password := tab(find("\n")) then move(1)
      else if not (password := ready(curr_net)) then {
         write("userchange: net read failed on password")
         fail
         }

      new_user := User(username,dynStHandler.srvSceneGraph.cveBuilder)

      if \new_user.exists() then {
         # go ahead and change the password
         new_user.setPassword(password)
         write(curr_net, "<ADMIN BEGIN>\nSuccess\n<ADMIN END>")
         logHandler.logit("admin: password changed")
         write("...done")
         return
         }

      write(curr_net, "<ADMIN BEGIN>\nFailure: user does not exist\n<ADMIN END>")

$endif


      logHandler.logit("admin: user does not exist")
      return
   end

   #
   # shutdown: gracefully shuts down the server
   #           at this point this can only be reached
   #           through the admin tools
   #
   method shutdown()
      local existing_user

      # remove users
      every existing_user := key(Tsocket_drivers) do {
         # inform the client that the connection has been lost
         sendRaw(existing_user, "Connection lost due to server shutting down.",
         "inform")
         removeUser( existing_user )
      }

      if \local_npc_set then{
         if integer(!local_npc_set) then
            every kill(!local_npc_set, 0)
         else{
            every (!local_npc_set).clean_and_exit()
            }
        }

      (\agents).shutdown()

      logHandler.logit("shutdown(): CVE Network Server " ||
		       cve_version() || " Shutdown Sequence")

      logHandler.terminate()
      dynStHandler.terminate()
      exit(0)
   end

   #
   # getWelcome: a welcome message for newly logged in users
   #
   method getWelcome()
      local welcome

      welcome:= "\nWelcome to the CVE $Revision: 1.125 $ Chronology: "||

      &dateline || "\n"
      welcome ||:= "Currently, there " ||
      (if *Tuser_sock=1 then "is " else "are ") || *Tuser_sock ||
      " user(s) online. Be courteous."

      return welcome
   end
   #
   # getAgent()
   #
   method getAgent(agent)
      return agents.member(agent)
   end
   #
   # getIP(): returns the known IP for the user "uid", sock
   #
   method getIP( credentials )
      local temp, pos0, pos1, pos2, net

      if /credentials then {
         logHandler.logit("getIP(): no credentials")
         return "undef"; fail
      }

      case type(credentials) of {
         "string": { net := Tuser_sock[getUser(credentials)] }
         "file" | "thread":   { net := credentials           }
      }

      if /(temp := image(net)) then {
         logHandler.logit("getIP(): no net")
         return "undef"; fail
      }

      #logHandler.logit("getIP(): image is " || temp)
      # here the output is of this format file(:4500:127.0.0.1:41774)

      if (type(net)~=="thread") then{
         temp := trim(temp,'\n\r')

         pos0 := find( ":", temp )

         if /pos0 then {
           logHandler.logit("getIP(): missing : in " || temp)
           return "undef"; fail
           }
         pos1 := pos0 + 1 + find( ":", temp[pos0+1:(*temp)+1])

         if /pos1 then {
            logHandler.logit("getIP(): missing 2nd : in " || temp)
            return "undef"; fail
            }
         pos2 := pos1 + find( ":", temp[pos1+1:(*temp)+1])

         if /pos2 then {
            logHandler.logit("getIP(): missing third : in " || temp)
            return "undef"; fail
          }

         temp := temp[pos1:pos2]
         }

      if \ (Tsocket_drivers[net].user) then
         logHandler.logit("getIP(): ip for user " ||
			  Tsocket_drivers[net].user.name || ", is " || temp)
      else
         logHandler.logit("getIP(): ip for this connection is " || temp)
      return temp
   end


# run n+5 npcs
method run_threads(n, com)
   local npc, user, concurrent, i
   /n := 0
   npcs := []

   concurrent :=  &features=="concurrent threads"

   if /concurrent then stop("Threads are not supported! shutting down...")

   every i := 1 to n do 
      put(npcs, CustomNPC(["-user", "npc"||i ], concurrent, com))

   every user := "vertex" do #| "tux" | "sid" | "dog" | "tausha" do
      put(npcs, CustomNPC(["-user", user], concurrent, com ))

   #every wait((!npcs).npcthread)       

end

# run n+5 npcs
method run_processes(n)
   local npc, user, i
    /n := 0
   npcs := []

   every i := 1 to n do 
      put(npcs, system("bin/vertex -user npc" || i , , , , "nowait"))

   every user := "vertex" do #| "tux" | "sid" | "dog" | "tausha" do
      put(npcs, system("bin/vertex -user " || user, , , , "nowait"))


   #wait()
   #every kill(!npcs, 0)
end

   initially (p, npc_mode, npc_n, com)
      server := self
      trap("SIGPIPE", pipeHandler) # traps Broken Pipe errors
      logHandler := Logger() # initialize the logging mechanism
      commandHelper := cmdHelper(logHandler)

      if /p then
	 port    := DEFAULT_PORT # getting default port number
      else
	 port := p

      IDECounter := 0 # IDE session counter
      IDE_Checked_Counter := 0
      Addcounter := 0
      Lusers_to_send := []

      # the main data structures
   Tsocket_drivers := table()
   socket_list := []
   Tuser_sock  := table() # - same data in both tables, keyed for
   Tname_group := table() # the group name as key and the group obj as value
   Tide := table()        # all users in IDE session

   Tusername_user := table()

   Cmds         := Commands() # server commands table & methods
   dynStHandler := StateHandler(logHandler) # Dynamic State Handler
   fileHandler  := fileTransfer(logHandler) # Handling file transfers
   agents := AgentHandler(self)
#   ici_groups := ICIGroups()

   local_npc_set := set()

$ifdef THREADS
#   Attrib(INBOX_LIMIT, 1024*1024)
#   Attrib(OUTBOX_LIMIT, 1024*1024)
$endif

   if \npc_mode=="T" then      run_threads(npc_n, com)
   else if \npc_mode=="P" then run_processes(npc_n)

end # class Server

#
# pipeHandler: signal exception handler for SIGPIPE
#
procedure pipeHandler(s)
   write("SIGPIPE from client. Removing user, arg ", image(s))
end

procedure datopen(fn,mode)
   return open(fn,mode)
end

procedure datfile(fn)
   return fn
end

procedure CheckIncludes(name, location)
   local filename, readline
   if not (filename := open(location, "r")) then fail
   while readline := read(filename) do {
      if find(name, readline) then {
         close(filename)
         return
	 }
      }
   close(filename)
end

procedure ConvertTwo(tot, ftwo)
   local tempWall
   if find("Box", type(tot)) then {
      write(ftwo, "\t\tBox {")
      every tempWall := !tot.walls do {
         write(ftwo, "\t\t\tWall {")
         if \tempWall.texture then
	     write(ftwo, "\t\t\t\ttexture ", tempWall.texture)
         write(ftwo, "\t\t\t\tcoords [")
         write(ftwo, "\t\t\t\t\t", tempWall.coords[1], ", ",
	       tempWall.coords[2], ", ", tempWall.coords[3], ",")
         write(ftwo, "\t\t\t\t\t", tempWall.coords[4], ", ",
	       tempWall.coords[5], ", ", tempWall.coords[6], ",")
         write(ftwo, "\t\t\t\t\t", tempWall.coords[7], ", ",
	       tempWall.coords[8], ", ", tempWall.coords[9], ",")
         write(ftwo, "\t\t\t\t\t", tempWall.coords[10], ", ",
	       tempWall.coords[11], ", ", tempWall.coords[12])
         write(ftwo, "\t\t\t\t]")
         write(ftwo, "\t\t\t}")
     }
      write(ftwo, "\t\t}")
  }
   if find("Wall", type(tot)) then {
      write(ftwo, "\t\tWall {")
      write(ftwo, "\t\t\ttexture ", tot.texture)
      write(ftwo, "\t\t\tcoords [")
      write(ftwo, "\t\t\t\t", tot.coords[1], ", ", tot.coords[2], ", ",
	    tot.coords[3], ",")
      write(ftwo, "\t\t\t\t", tot.coords[4], ", ", tot.coords[5], ", ",
	    tot.coords[6], ",")
      write(ftwo, "\t\t\t\t", tot.coords[7], ", ", tot.coords[8], ", ",
	    tot.coords[9], ",")
      write(ftwo, "\t\t\t\t", tot.coords[10], ", ", tot.coords[11], ", ",
	    tot.coords[12])
      write(ftwo, "\t\t\t]")
      write(ftwo, "\t\t}")
  }
   if find("WhiteBoard", type(tot)) then {
   }
   if find("Windowblinds", type(tot)) then {
      write(ftwo, "\t\tWindowblinds {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tangle ", tot.angle)
      write(ftwo, "\t\t\tcrod ", tot.color_rod)
      write(ftwo, "\t\t\tcblinds ", tot.color_blinds)
      write(ftwo, "\t\t\theight ", tot.height)
      write(ftwo, "\t\t\twidth ", tot.width)
      write(ftwo, "\t\t}")
  }
   if find("Chair", type(tot)) then {
      write(ftwo, "\t\tChair {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tposition ", tot.position_cube)
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t\ttype ", tot.type)
      write(ftwo, "\t\t\tmovable ", tot.movable)
      write(ftwo, "\t\t}")
  }
   if find("Table", type(tot)) then {
      write(ftwo, "\t\tTable {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tposition ", tot.angle)
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t\ttype ", tot.type)
      write(ftwo, "\t\t}")
  }
   if find("Pen", type(tot)) then {
      write(ftwo, "\t\tPen {")
      write(ftwo, "\t\t\tId ", tot.Id)
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t\tAngle ", tot.origYangle)
      write(ftwo, "\t\t}")
  }
   if find("Book", type(tot)) then {
      write(ftwo, "\t\tBook {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t\tAngle ", tot.type)
      write(ftwo, "\t\t}")
  }
   if find("Computer", type(tot)) then {
      write(ftwo, "\t\tComputer {")
      write(ftwo, "\t\t\tcoords_mntr [", tot.x_mntr, ", ", tot.y_mntr, ", ",
	    tot.z_mntr, "]")
      write(ftwo, "\t\t\tcoords_cpu [", tot.x_cpu, ", ", tot.y_cpu, ", ",
	    tot.z_cpu, "]")
      write(ftwo, "\t\t\tcoords_kb [", tot.x_kb, ", ", tot.y_kb, ", ",
	    tot.z_kb, "]")
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t\tangle ", tot.angle)
      write(ftwo, "\t\t}")
  }
   if find("Printer", type(tot)) then {
      write(ftwo, "\t\tPrinter {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tangle ", tot.angle)
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t}")
  }
   if find("Ramp", type(tot)) then {
      write(ftwo, "\t\tRamp {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tcolor ", tot.color_ramp)
      write(ftwo, "\t\t\ttexture ", tot.color_ramp)
      write(ftwo, "\t\t\ttexture ", tot.toptexture)
      write(ftwo, "\t\t\ttype ", tot.type)
      write(ftwo, "\t\t\twidth ", tot.width)
      write(ftwo, "\t\t\theight ", tot.height)
      write(ftwo, "\t\t\tlength ", tot.length)
      write(ftwo, "\t\t\tnumsteps ", tot.numsteps)
      write(ftwo, "\t\t}")
  }
   if find("Object3D", type(tot)) then {
      write(ftwo, "\t\tObject3D {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tposition ", tot.angle)
      write(ftwo, "\t\t\tscale [", tot.scalex, ", ", tot.scaley, ", ",
	    tot.scalez, "]")
      write(ftwo, "\t\t\tmodel3d ", tot.model3d_filename)
      write(ftwo, "\t\t}")
  }
end
