import gui
$include "guih.icn"
link lists, getpaths, basename, strings, colormap

$include "../common/defaults.icn"

#
# Class NSHDialog is the overall user interface that provides a "view"
# into the CVE.  As such, it serves the role of "camera" and "user" classes.
# We may need to encapsulate this functionality further in order to embed
# a CVE view as a tab in a larger IDE window.
#

global idesession, ide, maxtime, projectCreated,
       projectOpened, fileOpened, view, mynsh, projMenu, hostuser,
       onlineusers_set, showonline_checked, is_standalone, offlineusers_set,
       selected_user, selected_group, ici_groups, ici_newsfeed, new3dTab, 
       initpath, onlineusers_num, allusers_num, groups_num, interestgroups_num,
       ici_pendings, ici_notifications, ici_profile, fwrddlg, newsfeed, 
       pendings_tbl, n_username,
       selectedProjFileID, project_access_time, file_access_time,
       projActivitylst, memberActivitylst, sessionActivitylst, projMembersSet,
       active_projName, expertsList, myide_sessions,
       myprojectslst, myblocklst, myfriendsslst, mypartnersslst, 
       emails_selected, old_onlineusers_set

global sdprojfilesSet,     # Set to store opened software development file
       updatedsdfilelines, # Table to store the changed file lines
                           # the key is "fileName:projName"
       updatedsdfile_lines_events, # Table to store the changed file lines 
                                   # and events as string, the key is 
                                   # "fileName:projName"
       ActivityEditBox,
       activity_tabset,
       general_tab, member_tab, 
       all_activities_txtlst, 
       general_info_txtlst,
       currentlyworking_txtlst,
       mostactive_txtlst, 
       otherinfo_txtlst,
       activity_border2,
       general_info2_txtlst,
       fileschanged_txtlst,
       currentlyworking2_txtlst,
       file2changed2_txtlst, 
       otherinfo2_txtlst,
       proj_members_lst,
       sdp_flag,
       cwfiles_set, addedfiles_set, # store files users currently working on
       accessedfiles_set,            # accessed, and added
       membersColorTable,             # stor the user specified color
                                     # key is "projName:userID"
       changed_file_line_Table,
       line_color_table,
       members_accessed_file,        # list to store members accessed
                                    # a specific file
       userhaveColor,
       win2d, profile_win2d,profile_ava_win2d, AvWin, progWin,
       is_standalone, is_localhost,ava_win2d, myAva, prog_and_ava_isReady,
       progress_mainwin, mainprog_win, progress_tabitem, progress_tabset,
       onlinefriends_set, compfontdlg, mycompfont, session_connected


class NSHDialog : Dialog(get_lock_btn, exit_session_btn, end_session_btn, ide_session_tree,label_25, users_label, text_button_32, text_button_31, text_button_29, text_button_28, image_5, view_map, label_21, line_4, label_20, courseslist_1, line_1, line_2, line_3, calender, label_17, teacheremail, teachername, label_2, label_3,label_16, label_15, users_btn, user_invitation_btn,username, text_button_30, assignment, table_column_1, text_button_25, label_12, label_13,label_14, Desc, courses_btn, text_button_22, online_courses, mapwindow, ClassTabSet, ViewMode,  Science_Hall_overlay,  View_3D_overlay_item, VoicePhone_overlay_item, VoiceLocal_overlay_item, label_3, htoolbar, hide_toolbar, FileBrowser, menu_bar_1, VCSC_tab,label_2, image_2, label_1, view_border, exit_menu_item, chat_input, chat_output, browser,text_field_1, subwin,chatarea, toolbox, editarea, x_button, current_x, current_y, curr_x,curr_y, origx, deltax, origy, deltay, cmds, usercmd, userargs, pending_chatoutput, menu_1, origw, origh, view_3d, tab2, subwin_x, subwin_y, subwin_w, subwin_h, newtab_id, MsgBox, nullfilename, oldpos, oldsize, tab_label, EditBox, opened_file, user, clientIP, tablist, usersDisplayList, file_contents, tabItem, url_field, web_mode, users_guide_file, commands_file, uide, opened_files_num,user_me, newJavaProject, newCppProject, newUProject, Voice, winflag, courseslist, forumlist, courselist, inventory_tab_item, activequeststl, activequestslbl, files_label, showonline_chkbx, users_tree, groups_tree, projects_tree, user_status_ddl, avatar_status_ticker, image_6, activity_mini_tabset, mini_groups_tab, mini_projects_tab, mini_users_tab, pending_activities, pendings_btn, newsfeed_tab_item, newsfeed_tree, menu_18, menu_button_2, floormap, notifications_icn, notifications_menu_icn, emails_icn, emails_menu_icn, notification_item_lbl, menu_19, menu_button_3, chat_border, subwin2d, chart_border, subwin_x_2d, subwin_y_2d, subwin_w_2d, subwin_h_2d, fps_label, latency_label, emails_item_lbl, browse_item_lbl, user_chat_output, user_pending_chatoutput)

   method handle_resize(e)
      local s := (\ (world.curr_room)).name | "nowhere"
      self.Dialog.handle_resize(e)
      if \user_me then
	 s := s || "[" || user_me || "]"
      WAttrib(cwin, "label=" || s || " ~ ("||view.w||" x "||view.h||")")      
   end

   method eye(i:0)
       world.cam.eye(i)
   end

   method toggle_viewmode()
       world.cam.toggle_viewmode()
   end

   method teleport(ex,wye,zee)
       world.cam.teleport(ex,wye,zee)
   end

   method teleport_home()
      world.cam.angle := 0
      teleport(AVATAR_ORIGIN_X, AVATAR_ORIGIN_Y, AVATAR_ORIGIN_Z)
   end

   # teleport to the middle of a room, should allow by name or room obj
   method teleport_toroom(r)
   local rx, rz, i, k
      if string(r) then {
	 r := map(r," ","-")
	 if not (r := (\ (world.RoomsTable)[r])) then {
	    write_to_chat_win("couldn't find ", image(r), " in roomstable of size ",
		  *(world.RoomsTable))
	    i := 0
	    every k := key(world.RoomsTable) do {
		writes("\t",image(k))
		i +:= 1
		if i % 2 = 0 then write_to_chat_win()
		}
	    fail
	    }
	 }
      rx := r.x + r.w/2
      rz := r.z + r.l/2
      teleport(rx,r.y,rz)
   end

   method component_setup()
      self.setup()
      if \world.moodle.return_moodle_conn() then {
	 world.moodle.DisplayUsername(username)
	 #
	 # for IP
	 #
	 session.Write("\\fetchip " || world.userId)
	 on_courses_btn()
	 }
   end

   method on_courses_btn(ev)
      local L
      courseslist.set_size("125","27" )
      L := world.moodle.mdl_courses_btn()
      courseslist.set_selection_list(L)
   end

   method set_label(s)
      /s := (\ (world.curr_room)).name | "nowhere"
      if not (session.isUp()) then s ||:= " (offline)"
      if \user_me then      
         return WAttrib(\win, #"resize=off", 
                        "label="||\s||" ["||user_me||"]"||" ~ ("||view.w||" x "||view.h||")")
   end

   method reset_input_bufs()
      chat_input.set_contents("")
   end

   method write_to_chat_win(ss[])
      local s := "", temp, starts, stops
      every s ||:= !ss
      /pending_chatoutput := []
      #
      # if there is no output window yet, queue it up
      #
      if /chat_output | /win then { put(pending_chatoutput, \s); fail }
      else if *pending_chatoutput > 0 then {
         if \ (chat_output.get_contents()) then {
	    pending_chatoutput :=
	       chat_output.get_contents() ||| pending_chatoutput
	 }
	 chat_output.set_contents(pending_chatoutput)
	 chat_output.set_selections([*(chat_output.get_contents())])
         chat_output.ensure_row_visible(*(chat_output.get_contents()))
         chat_output.display()
	 pending_chatoutput := []
      }
      if *\s > 0 then {
         if *\s < 55 then {
            chat_output.set_contents(put(chat_output.get_contents(), \s))
            chat_output.set_selections([*(chat_output.get_contents())])
            chat_output.ensure_row_visible(*(chat_output.get_contents()))
	    chat_output.display() 
         }
         else {
            temp := (*s / 45)
            starts := 1
            stops := 46
            while temp >= 0 do {
	       while (stops-starts>35) & (s[stops]~==" ") do stops -:= 1
	       if stops-starts > 35 then
		  chat_output.set_contents(put(chat_output.get_contents(),
					       \s[starts:stops]))
	       else {
		  stops := starts+45; if stops > *s then stops := *s+1
		  chat_output.set_contents(put(chat_output.get_contents(),
					       \s[starts:stops]))
	          }
               starts := stops
               stops +:= 45
               temp -:= 1
               if stops > *s then stops := *s+1
	       }
	    chat_output.set_selections([*(chat_output.get_contents())])
	    chat_output.ensure_row_visible(*(chat_output.get_contents()))
	    chat_output.display()
         }
      }
   end

   method write_to_user_chat_win(ss[])
      local s := "", temp, starts, stops
      every s ||:= !ss
      /user_pending_chatoutput := []
      #
      # if there is no output window yet, queue it up
      #
      if /chat_output | /win then { put(user_pending_chatoutput, \s); fail }
      else if *user_pending_chatoutput > 0 then {
         if \ (user_chat_output.get_contents()) then {
	    user_pending_chatoutput :=
	       user_chat_output.get_contents() ||| user_pending_chatoutput
	 }
	 user_chat_output.set_contents(user_pending_chatoutput)
	 user_chat_output.set_selections([*(user_chat_output.get_contents())])
         user_chat_output.ensure_row_visible(*(user_chat_output.get_contents()))
         user_chat_output.display()
	 user_pending_chatoutput := []
      }
      if *\s > 0 then {
         if *\s < 75 then {
            user_chat_output.set_contents(put(user_chat_output.get_contents(), \s))
            user_chat_output.set_selections([*(user_chat_output.get_contents())])
            user_chat_output.ensure_row_visible(*(user_chat_output.get_contents()))
	    user_chat_output.display() 
         }
         else {
            temp := (*s / 65)
            starts := 1
            stops := 66
            while temp >= 0 do {
	       while (stops-starts>60) & (s[stops]~==" ") do stops -:= 1
	       if stops-starts > 60 then
		  user_chat_output.set_contents(put(user_chat_output.get_contents(),
					       \s[starts:stops]))
	       else {
		  stops := starts+65; if stops > *s then stops := *s+1
		  user_chat_output.set_contents(put(user_chat_output.get_contents(),
					       \s[starts:stops]))
	          }
               starts := stops
               stops +:= 65
               temp -:= 1
               if stops > *s then stops := *s+1
	       }
	    user_chat_output.set_selections([*(user_chat_output.get_contents())])
	    user_chat_output.ensure_row_visible(*(user_chat_output.get_contents()))
	    user_chat_output.display()
         }
      }
   end

   method end_dialog()
      FileBrowser.nodereplace(tab_label)
      FileBrowser.set_contents[""]
      FileBrowser.filltree()
      FileBrowser.handle_press()
      resize()
   end

   method init_dialog()
      local dw, dh, ww, wh, xpos, ypos, 
      idesession_lbl, users_lbl, groups_lbl, projects_lbl, newsfeed_lbl,
      fin, no_reset, r, friends_lbl, onlineUsers_lbl, offlineUsers_lbl,
      npcs_lbl, floc, fn, iscrashed, f, i, usr, flst := []

      view_3d := VCSC_tab.children[1]
      view_3d.set_label(MODEL_NAME)
      image_2.set_filename(DAT || "/images/logo.gif")
      if \floormap then image_5.set_filename(floormap)
      else image_5.set_filename(DAT || "/images/map.gif")
      image_5.set_scale_up()

      #win2d := subwin2d.cwin
      #open a window to the user's progress chart
      win2d := open("Users' Progress", "g", "height=150",
         "width=300", "bg=white", "canvas=hidden") |
         stop("can't open window")

      display()      
      View_3D_overlay_item := Science_Hall_overlay.children[1]
      projectCreated := projectOpened := "FALSE"
      view := world.nsh_dialog
      projMenu.Menu_Bar() #call to generate the main menubar
      projMenu.set_isShaded()

      # new VoIP things
      #Voice.VoIP_toolbar()
      Voice.VoIP_PhoneOverlay()
      Voice.VoIP_LocalOverlay()
      VoicePhone_overlay_item := Science_Hall_overlay.children[2]
      VoiceLocal_overlay_item := Science_Hall_overlay.children[3]

      write_to_chat_win()
      restore_3DView()
#      opened_files_set:= set()
      tabs_num := users_guide_file := commands_file := 0

      openedprojfileTable := table() #store the opened file 
                                     #associated with the project

      if &fail & fin := open ("dat"||PS||"last_session.ini") then {
	 if (xpos := read(fin) & ypos := read(fin) &
	     ww := read(fin) & wh := read(fin) ) then {
	       close(fin)
	       self.set_pos(xpos, ypos)
	       self.set_size(ww, wh)
	       self.resize()
	       
	       restore_3DView()
	       no_reset := 1
	       }
	    }

      if /no_reset then {
	 ww := WAttrib(win, "width")
	 wh := WAttrib(win, "height")
	 dw := WAttrib(win, "displaywidth")
	 dh := WAttrib(win, "displayheight")
	 WAttrib(win, "pos=" || (dw-ww)/2 ||","||(dh-wh)/2)
	 }

      ui_initialize()
      who_users()

      if (world.userId == "guest") & / (world.password) then {
	  gui::dispatcher.do_netline("\\dynstate NOUPDATE")
      }

# Initialize Session Tree and Users Tree
      idesession_lbl := Node("label=IDE Sessions("||0||")")
      ide_session_tree.set_root_node(idesession_lbl)

      users_lbl := Node("label=Users")
      users_tree.set_root_node(users_lbl)
      r := users_tree.get_root_node()
      friends_lbl := Node("label=Friends("||0||")")
      r.add(friends_lbl)
      npcs_lbl := Node("label=NPCs("||0||")")
      r.add(npcs_lbl)
      onlineUsers_lbl := Node("label=Online("||0||")")
      r.add(onlineUsers_lbl)
      offlineUsers_lbl := Node("label=Offline("||0||")")
      r.add(offlineUsers_lbl)

      groups_lbl := Node("label=SCI Groups")
      groups_tree.set_root_node(groups_lbl)
      projects_lbl := Node("label=Software Projects")
      projects_tree.set_root_node(projects_lbl)
      newsfeed_lbl := Node("label=Feeds")
      newsfeed_tree.set_root_node(newsfeed_lbl)

#Groups/newsFedd Creation on Login
      #ici_groups.on_login_groups_creation()
      ici_newsfeed.on_login_newsfeed_creation()
      groups_num := 0  # number of all available groups
      interestgroups_num := 0  # number of all SIGs
      onlineusers_set := set()
      offlineusers_set := set()
      allprojlst := []
      avatar_status_ticker := Ticker()

      iscrashed := loadSessionInfo(flst := [])
      if \iscrashed then {
         every i := 1 to *flst do {
            flst[i] ? {
               floc := tab(find("$"))
               &pos +:= 1
               fn   := tab(0)
               }
            opened_files_locs[fn] := floc
            view.uide.handle_openfile(, floc||fn)
            }
         }
   end

   #
   # Remebers the connection userid, server, and port
   #
   method rememberSessionInfo(flst, isExit)
      local f, r, L := [], fset := set()

      if f := datopen(USER_GLOBALPATH||PS||world.userId||PS||
         "autosave.dat", "r") then {
         while r := read(f) do
            if find("$", r) then put(L, r)
         close(f)
         }

      if f := datopen(USER_GLOBALPATH||PS||world.userId||PS||
         "autosave.dat", "w") then {
         if \isExit then
            write(f, "EXITOK")
         if *L > 0 then
            every put(flst, !L)
         every insert(fset, !flst)
         write(f,"IDE FILES:", *fset)
         every write(f, !fset)

         close(f)
         }
   end

   method loadSessionInfo(flst)
      local r, f, iscrashed, i, n, L := []

      if f := datopen(USER_GLOBALPATH||PS||world.userId||PS||
         "autosave.dat", "r") then {
         while r := read(f) do {
            put(L, r)
            }
         close(f)
         }
      if *L >= 2 then {
         if L[1] ~== "EXITOK" then {
            iscrashed := 1
            n := 2
            }
         else n := 3
         if (*L - n) > 0 then
            every i := n to *L do
               put(flst, L[i])
               
         }
      return \iscrashed
   end

   method ide_autosave(isExit)
     local ts, i, tlbl, new_tlbl, chld,
        fset := set(), lst := [], clst := []

     ts :=  world.nsh_dialog.VCSC_tab
     every i := 1 to *(ts.children) do {
        chld := ts.children[i]
        tlbl := ((ts.children)[i]).label
        if find(".c"|".cpp"|".java"|".icn"|
           ".uprj"|"Untitled"|"(PF)", tlbl) then {
           every i := 1 to *chld.children do {
              if find("SCETL", type(chld.children[i])) then
                 clst := (chld.children[i]).get_contents() | []
              }

           if find("~", tlbl) then
              new_tlbl := tlbl
           else {
              if /opened_files_locs[tlbl] then
                 opened_files_locs[tlbl] := DAT

              put(lst, opened_files_locs[tlbl]||"$"||tlbl||"~")
              new_tlbl := tlbl||"~"
              }

           opened_files_locs[new_tlbl] := opened_files_locs[tlbl]

           ide.auto_save_file(new_tlbl, clst)
           }
        }

     rememberSessionInfo(lst, isExit)
   end

   method on_br(ev)
   end

   method on_kp(ev)
     gui::dispatcher.do_cve_event()
   end

   method on_mr(ev)
   end

   method on_subwin(ev)
   end

   #
   # This handler serves as a dispatcher for the commands entered by the
   # user at the chat prompt.
   #
   method on_chat(ev)
   local input_line, parse, fheight, fwidth, userarglist, message, tmp
   local pw,t1, post_line, usr, trt, tId, minx, maxx, miny, maxy,
         minz, maxz, r, avat
   
   static last_told_user
   initial last_told_user := ""
      input_line := trim(chat_input.get_contents(), ' ', 0)
      chat_input.set_contents("")

      # parse input line - do basic validity check
      if parse := cmds.ParseCommand( input_line ) then {
	 usercmd  := parse[1] | "say"
	 userargs := parse[2] | ""
         if usercmd == "teleport" then
            if \user_me then
               session.Write("\\interactionsIn3D "||user_me||
                             " "||"Teleport")
	 }
      else if input_line[1] ~== "\\" then {
         userargs := input_line
         /usercmd := "say"
         }
      else {
         write_to_chat_win("[Invalid message not sent to server.]")
	 reset_input_bufs()
	 fail
         }
   input_line := "\\" || usercmd || " " || userargs

   case usercmd of {
      "say" : { post_line := world.userId || ": " || userargs }
      "tell" : {
	 userargs ? {
	    if \(usr := tab(find(" ") | 0)) & world.get_avatar(usr) then {
	       last_told_user := usr
	       tmp := tab(0) | ""
	       }
	    else{ 
	       tmp := userargs
	       userargs := last_told_user || " " || userargs
	       input_line := "\\" || usercmd || " " || userargs
	       }
	    } # userargs ?
	 post_line := world.userId || " whispers ("|| last_told_user ||
	    "): " || tmp
	 }
      default : { post_line := input_line }
      }
    write_to_user_chat_win(post_line)
    if usercmd == "whereami" then {
       if avat := world.get_avatar() then
          write_to_user_chat_win(avat.X, " ", avat.Y, " ", avat.Z)
          return
       }

#   chat_output.set_contents(put(chat_output.get_contents(), post_line))
#   chat_output.set_selections([*(chat_output.get_contents())])
#   chat_output.ensure_row_visible(*(chat_output.get_contents()))

      # local commands which affect only client can go here

   case usercmd of {
   "redraw": {
      t1 := &time
      eye()
      write_to_chat_win("Redraw: ", &time - t1, "ms (",*WindowContents(), " items)")
      return
      }
#   The editroom chat command facilitates the changing of room dimentions or room locations.
#   The syntax thus far is "\editroom *roomname* *option* *dimentions"
#   where *roomname* is the name of the room you would like to change
#   *option* is one of the options available (nWall, sWall, eWall, wWall, moveRoom, or check)
#   and dimentions is the amount you would like to change the option by.
#   check is used to display information about the room, useful for debugging or finding placement.
#   n(orth), s(south), e(ast), and w(est) are based off north being the direction 0, 0, -1
#                  N
#                  ^
#                  |
#               W<-+->E
#                  |
#                  V
#                  S
#   moveRoom takes 3 arguments: x, y, and z, and moves the room in those directions. Use 0 if no
#   movement is wanted in that direction. The single directions use a single value.
#   It is also worth noting, the room changes aren't saved, nor are they viewable by others until 
#   a saveroom is called. Should you log out before saving changes the room will revert back to it's 
#   previous state.
   "editroom": {
      userarglist := cmds.SplitArgs(userargs)
      EditRoomProc(userarglist)
      teleport_toroom(userarglist[1])
   }
   "addopening": {
      userarglist := cmds.SplitArgs(userargs)
      if *userarglist ~= 9 then {
         write_to_chat_win("Invalid Syntax!")
         write_to_chat_win("Try 'addopening x y z collide width height plane room1 room2'.")
         return
      }
      tId := AddOpeningProc(userarglist)
      write_to_chat_win("Your opening has the ID: " || tId || ".")
      return
   }
   "upload": {
      write_to_chat_win("Invalid Command" )
      #session.fileXferInitiate(userargs)
      reset_input_bufs()
      return
      }
   "whiteboard": {
      whiteboard1.connect()
      return
      }
      }

   if usercmd === "set" then {
      userarglist := cmds.SplitArgs( userargs )

      if *userarglist = 1 then {   #  query parm
         if userarglist[1] == "avat_step_move" then {
	    message := image( world.avat_step_move )
	    write_to_chat_win( message )
	    }
	 if userarglist[1] == "avat_step_rotate" then {
	    message := image( world.avat_step_rotate )
	    write_to_chat_win( message )
	    }
         if userarglist[1] == "cam_step_move" then {
	    message := image( world.cam_step_move )
	    write_to_chat_win( message )
	    }
	 if userarglist[1] == "cam_step_rotate" then {
	    message := image( world.cam_step_rotate )
	    write_to_chat_win( message )
	    }
	 reset_input_bufs()
	 return
	 }

      if userarglist[1] == "avat_step_move" then { # set parms
	 world.avat_step_move         := numeric( userarglist[2] )
	 world.cam.avat_step_move     := numeric( userarglist[2] )
	 }
      if userarglist[1] == "avat_step_rotate" then {
	 world.avat_step_rotate       := numeric( userarglist[2] )
	 world.nsh_dialog.avat_step_rotate   := numeric( userarglist[2] )
	 }
      if userarglist[1] == "cam_step_move" then {  # set parms
	 world.cam_step_move          := numeric( userarglist[2] )
	 world.nsh_dialog.cam_step_move      := numeric( userarglist[2] )
	 }
      if userarglist[1] == "cam_step_rotate" then {
	 world.cam_step_rotate        := numeric( userarglist[2] )
	 world.nsh_dialog.cam_step_rotate    := numeric( userarglist[2] )
	 }

      reset_input_bufs()
      return
      }

   if usercmd === "server" then {
      if userargs === "" then {
	 write_to_chat_win( "Server: " || session.server ||":" || session.port)
	 }
      else {
	 if session.isUp() then {
	    write_to_chat_win( "You must logout before changing server. ")
	    }
	 else {
	    tmp := find(":", userargs)
	    session.server := userargs[1:tmp]
	    session.port   := userargs[(tmp+1):0]
	    write_to_chat_win( "Server: " ||session.server||":"|| session.port)
	    }
	 }
      reset_input_bufs()
      return
      }

   if usercmd === "avatar" then {
      # create user's own avatar
      # nothing seems to use the window here
      if \userargs then {
         # write("creating the local avatar")
         world.avatar_create( [userargs, 0.0, 0.0, 0.0, 0.0],1 )
         }
      else {
	 write_to_chat_win( "Usage: \"\\avatar <user-id>\"")
      }
      reset_input_bufs()
      return
      }

   if usercmd === "delavatar" then {
      # write( " handle local cmd delavatar  userargs ", image(userargs ))
      # if userargs == "" then userargs := "self"
      world.avatar_delete( userargs )
      reset_input_bufs()
      return
      }

   if usercmd === "quit!" then { 
      ### fix this to do a clean logout
      world.close_cve("closed from quit! command")
   }

   #  end local commands

   #open up connection to server if user requests \login
   #  all login stuff should be gathered here, duh...
   if session.NotLogged(usercmd) then {
      if find (" ", userargs) then {
	  userargs ? {
	      usr := tab(find(" "))
	      tab(many(' \t'))
	      pw := trim(tab(0))
	  }
      } else { usr := world.userId; pw := trim(userargs) }
      session.connect_server( usr, pw)
      reset_input_bufs()
      return
   }

   #check for net connection and send message to server
   if not (session.isUp()) then {
      write_to_chat_win( "Not connected to server")
      reset_input_bufs()
      return
      }

   #deny login if already connected to server
   if usercmd === "login" then {
      message := "Already logged into server as: " ||  session.uid
      write_to_chat_win( message)
      reset_input_bufs()
      return
      }

   if usercmd === "logout" then {
      session.Write(input_line)
      WSync()

      #### maybe server should just broadcast the \logout and let clients
      #### generate the \delavatar command locally

      #   server will broadcast a \delavatar command to delete this users
      #    avatar as seen on remote terminals and then send back a
      #    server \logout message which is processed by handle_network_input()
      #    below, and will execute final local cleanup commands
      #    see user_logout() called via handle_network_input()
      #    local delete actions must wait for return server msg
      reset_input_bufs()
      return
      }
   if usercmd === "saveopening" then {
      userarglist := cmds.SplitArgs(userargs)
      SaveOpeningProc(userarglist)
      return
   }

   if usercmd === "saveroom" then {
      trt := WcveBuilder.sceneGraph.nodesTable[userargs] 
      if \trt then  
         SaveRoomProc(userargs, trt, input_line)
      else
         write_to_chat_win("save room failed")
      reset_input_bufs()
      return
   }
   if usercmd === "createroom" then {
      userarglist := cmds.SplitArgs(userargs)
      if *userarglist ~= 8 then {
         write_to_chat_win("Create Room failed:invalid syntax... We think")
         write_to_chat_win("Should be '\createroom Name X Y Z W H L texture'")
         reset_input_bufs()
         return
      }
      if \WcveBuilder.sceneGraph.nodesTable[userarglist[1]] then {
         write_to_chat_win("There is a room named " || userarglist[1] || " already!")
         return
      } 
      minx := userarglist[2]
      maxx := minx + userarglist[5]
      miny := userarglist[3]
      maxy := miny + userarglist[6]
      minz := userarglist[4]
      maxz := minz + userarglist[7]
      every r := !WcveBuilder.sceneGraph.nodesTable do {
         if r.isinside(minx, miny, minz) then {
            write_to_chat_win("Failed to create: That room contains the point (" || 
                              minx || ", " || miny || ", " ||
                              minz || ") which is inside room " || r.name || ".")
            return
         }
         if r.isinside(maxx, miny, minz) then {
            write_to_chat_win("Failed to create: That room contains the point (" || 
                              maxx || ", " || miny || ", " ||
                              minz || ") which is inside room " || r.name || ".")
            return
         }
         if r.isinside(minx, miny, maxz) then {
            write_to_chat_win("Failed to create: That room contains the point (" || 
                              minx || ", " || miny || ", " ||
                              maxz || ") which is inside room " || r.name || ".")
            return
         }
         if r.isinside(maxx, miny, maxz) then {
            write_to_chat_win("Failed to create: That room contains the point (" || 
                              maxx || ", " || miny || ", " ||
                              maxz || ") which is inside room " || r.name || ".")
            return
         }
         if r.isinside(minx, maxy, minz) then {
            write_to_chat_win("Failed to create: That room contains the point (" || 
                              minx || ", " || maxy || ", " ||
                              minz || ") which is inside room " || r.name || ".")
            return
         }
         if r.isinside(maxx, maxy, minz) then {
            write_to_chat_win("Failed to create: That room contains the point (" || 
                              maxx || ", " || maxy || ", " ||
                              minz || ") which is inside room " || r.name || ".")
            return
         }
         if r.isinside(minx, maxy, maxz) then {
            write_to_chat_win("Failed to create: That room contains the point (" || 
                              minx || ", " || maxy || ", " ||
                              maxz || ") which is inside room " || r.name || ".")
            return
         }
         if r.isinside(maxx, maxy, maxz) then {
            write_to_chat_win("Failed to create: That room contains the point (" || 
                              maxx || ", " || maxy || ", " ||
                              maxz || ") which is inside room " || r.name || ".")
            return
         }
      }
      CreateRoomProc(userarglist)
   }

   if usercmd === "teleport" then {
      userarglist := cmds.SplitArgs(userargs)
      if *userarglist = 1 then {
         teleport_toroom(userargs)
         reset_input_bufs()
         return
      }
      else if *userarglist = 3 then {
         world.cam.teleport(userarglist[1], userarglist[2], userarglist[3])
         reset_input_bufs()
         return
      }
   }
   # FINALLY - send input_line to server

#    write("sending:::" || input_line || ":::" )

   world.moodle.chatline_to_server(input_line)
   session.Write(input_line)
   
   # write("done sending command")
   reset_input_bufs()
   return

   end

   method on_x(ev)
      static lastx, lasty

      while Pending(win)[1] === &ldrag do Event(win)
      if(&x >=210 & &y >=230 & &x <=(self.w *0.5) & &y <=(self.h *0.5)) then {
         # determine how much to move everything over by
         if (deltax := &x - \current_x) & (deltay := &y - \current_y) then {
	    origx := x_button.get_x_reference()
	    origy := x_button.get_y_reference()
	    x_button.set_pos(origx+deltax, origy+deltay)
	    origx := editarea.get_x_reference()
	    origy := editarea.get_y_reference()
	    origw := editarea.get_w_reference()
	    origh := editarea.get_h_reference()
	    editarea.set_pos(origx+deltax, origy+deltay)
	    editarea.set_size("100%-"||(origx+deltax),
			      "100%-"||(origy+deltay))
	    origx := chatarea.get_x_reference()
	    origy := chatarea.get_y_reference()
	    origw := chatarea.get_w_reference()
	    origh := chatarea.get_h_reference()   
	    chatarea.set_pos(origx+deltax, origy)
	    chatarea.set_size("100%-"||(origx+deltax),
	    		     (origh+deltay))
	    origx := browser.get_x_reference()
	    origy := browser.get_y_reference()
	    origw := browser.get_w_reference()
	    origh := browser.get_h_reference()
	    browser.set_pos(origx, origy+deltay)
	    browser.set_size((origw+deltax),"100%-"||
	 		    (origy+deltay))
	    origx := toolbox.get_x_reference()
	    origy := toolbox.get_y_reference()
	    origw := toolbox.get_w_reference()
	    origh := toolbox.get_h_reference()
	    toolbox.set_size(origw+deltax, origh+deltay)
	    resize()
            display()
            }
         current_x := &x
         current_y := &y
         if (VCSC_tab.get_which_one()).label ===MODEL_NAME then {
	    restore_3DView()
	    }
         }
   end

   method on_press(ev)
      current_x := &x
      current_y := &y
   end

   method on_release(ev)
      current_x := current_y := &null
   end

#-----------------------------------------------------------------------#
#---------------------# Begin Collaborative IDE  #----------------------#
#-----------------------------------------------------------------------#
#----------------------       IDE      ---------------------------------#

   #
   # Received lock request to the owner from a user
   #
   method Received_IDE_Lock_Request(args, flag)
      local index,user,pos,file_name,oldwindow
      pos := find(" ",args)
      user := args[1:pos]
      index := integer(args[pos+1:0])
      file_name := idesession.Tidesession[index].IDEFile
      if flag == 1 then {
         idesession.Change_IDE_Owner(user,index)
         session.Write("\\CETLLockTransfer "||user||" "||index)
         }
      else { 
         session.Write("\\tell "||user||
                       " sorry, i'm still working on that file ")
         }
   end
   #
   # Get Lock button
   #
   method on_get_lock_btn(ev)
      local edit_box_attribute,found := 1,counter := 1,attrib,file_name, ftab

      debugger := 1

      if (VCSC_tab.get_which_one()).label == (MODEL_NAME|"Map") then
         view.write_to_chat_win("Please Choose a file tab")
      else{# It is file Tab 
         ftab := view.VCSC_tab
         edit_box_attribute := ftab.get_which_one().get_children()[1].attribs
      	 attrib := edit_box_attribute[1]
         file_name := VCSC_tab.get_which_one().label
         if find("light yellow",attrib) then {
            #exit only if it is collaborative file
            while (found=1)&(counter <= idesession.Table_Index) do{
               if \idesession.Tidesession[counter] then {
                  if (idesession.Tidesession[counter].IDEFile==file_name) then{
                     #it maybe &null for some field for some users
                     found := 0
                     }
                  }
               counter := counter+1
               }#end while

         if (found=0) then{
            if user_me==idesession.Tidesession[counter-1].IDEOwner then {
               view.write_to_chat_win("You are the owner of the file")
               }
            else{
               session.Write("\\CETLLock "|| 
                             idesession.Tidesession[counter-1].IDEOwner||
                             " "||user_me||" "||counter-1)
               }
            }
         }
         else {
            view.write_to_chat_win(
                 "This file is not currently in collaboration")
            }
      }
   end
   #
   #User exit IDE collaborative session
   #
   method on_exit_session_btn(ev)
      local counter := 1,found := 1,attrib,edit_box_attribute,file_name

      if (VCSC_tab.get_which_one()).label == (MODEL_NAME | "Map") then {
         view.write_to_chat_win("Please Choose a file tab")
         }
      else {# It is file Tab 
         edit_box_attribute := view.VCSC_tab.get_which_one().get_children()[1].attribs
         attrib := edit_box_attribute[1]
         file_name := VCSC_tab.get_which_one().label     
         if find("light yellow",attrib) then{
	    #exit only if it is collaborative file
            while (found=1)&(counter <= idesession.Table_Index) do{
               if \idesession.Tidesession[counter] then {
                  if (idesession.Tidesession[counter].IDEFile==file_name) then{
                     #it maybe &null for some field for some users
                     found := 0
                     }
                  }
                  counter := counter+1
               }#end while
            if (found=0) then{
               idesession.White_Background_And_Unlock(
                          idesession.Tidesession[counter-1])
               idesession.Delete_File_IDESession(counter-1,user_me,1)
               session.Write("\\CETLDeletefile " || user_me||" "||
                             file_name||" "||counter-1)
               }
            }
         else{
            view.write_to_chat_win(
                 "This file is not currently in collaboration")
            }
         }
   end
   
   #
   # delete_user_usertab
   # delete users logged out from the usersDisplayList
   #
   method delete_user_usertab(user)
      local i, found

      i := 1
      found := 0
      while (i <= *session.usersList) & (found = 0) do {
         if session.usersList[i] == user then {
            found := 1
            }
         i +:= 1
         }
      #usersDisplayList.set_contents(session.usersList)
      delete(session.usersList,i-1)
      # The above code will be replaced with the following statement
      # session.deluser(user)
   end
   
   #
   # add_user_usertab
   # add new users logged in to the usersDisplayList
   #
   method add_user_usertab(user)
      # missing intelligence here, don't put them on the list if they are on it

      session.adduser(user)  # put(session.usersList,user)
      view.all_users()
      if / (session.WhoIsUpList) then {
         stop()
         }
      #usersDisplayList.set_contents(session.WhoIsUpList)
      #voipdlg.Voice_users_list.set_selection_list(session.WhoIsUpList)
   end
   #
   # return this user name
   #
   method Whoami(user)
      user_me := user
   end
   #
   # on_ide_user_invitation_btn
   # Send CETL Command to the server
   # 1-Check if the user choose himself to do collaboration with
   # 2-Check the tab label if it is acceptable (not Map and not the 3D tab)
   # 3-Check if session already exist between theses users
   # 4-Check if the fg = "light yellow"; means a session is already exist
   # if theres no session between the two users, invitation will be send
   #
   method on_user_invitation_btn(ev, user_name, file_name, sdp_flag, s)
      local index, found, edit_box_attribute, msg_box_attribute, 
         attrib, attrib1, is_owner

      hostuser := user_me

      if \s == 1 then {
         \selected_user | fail 
         /user_name := selected_user
         }

      if (\user_name)&(user_name~==user_me) then { #user didn't choose himself
         
         if (VCSC_tab.get_which_one()).label == (MODEL_NAME | "Map") then {
            view.write_to_chat_win("Please Choose a file tab")
            }
         else 
            {# It is file Tab
            edit_box_attribute := view.VCSC_tab.get_which_one().get_children()[1].attribs
            attrib := edit_box_attribute[1]
            msg_box_attribute := view.VCSC_tab.get_which_one().get_children()[2].attribs
            attrib1 := msg_box_attribute[1]

            /file_name := VCSC_tab.get_which_one().label
            found := idesession.Check_Session(user_name,file_name,idesession.index_counter,1)
            if find("light yellow",attrib) &
               find("light yellow",attrib1) then {#send events only to the yellow
               is_owner := idesession.Check_Owner(user_me,file_name,idesession.index_counter)
               #check if session already exist between these users
               if (found=0) &(is_owner=1) then {
                  hostuser := user_me
                  idesession.Invite_to_IDE(user_name, file_name, hostuser, sdp_flag)
                  }# end if
               if found=1 then {
                  view.write_to_chat_win(" You already have IDE session with " || user_name )
                  }
               if is_owner=0 then {
                  view.write_to_chat_win(" Sorry you are not the owner of the file " || file_name )
                  }
               }
            else {#white backround send invite without check ,also will save the EditBox
               hostuser := user_me
               idesession.Invite_to_IDE(user_name, file_name, hostuser, sdp_flag)
               }
            } # end else
        } # end if
     else {
        view.write_to_chat_win(" Please select user other than yourself " )
        }
   end
   #
   # Remove * from the owner, because he is not the owner anymore
   #
   method Remove_Owner_In_Tree(file_name,OldOwner)
      local r, node, root := ide_session_tree.get_root_node()
      r := Search_Tree(file_name, root)

      hostuser := trim(hostuser,"\x1e",0)
      if hostuser === OldOwner then { #find(hostuser, OldOwner) then {
         OldOwner ||:= "(owner)"
         }

      node := Search_Tree(OldOwner||" *",r)
      node.label := OldOwner
      ide_session_tree.expand()
   end
   #
   # When Give Turn button pressed we transfer the * in the tree
   #  (which shows who can edit the file currently)
   #
   method Swap_User_Owner_In_Tree(file_name,NewOwner)
      local node, r, root := ide_session_tree.get_root_node()
      r := Search_Tree(file_name,root)
      node := Search_Tree(NewOwner, r)
      node.label ||:= " *"
      ide_session_tree.expand()
   end
   #
   # Search IDE tree for specific node label
   #
   method Search_Tree(file_name,root)
      local found := 0,j := 1

      while (j<=*root.subnodes) &(found=0) do{
         if root.subnodes[j].label == file_name |
            find(file_name, root.subnodes[j].label) then {
            found := 1
            }
         j := j+1
         }#end while
      return root.subnodes[j-1]
   end
   #
   # Create IDE session subtree for new invited user
   #
   method Create_Session_SubTree(index,root,user)
      local j := 1,child

      if \idesession.Tidesession[index] then{
         while (j<=*idesession.Tidesession[index].Lusers)  do{
            if idesession.Tidesession[index].Lusers[j]~==user_me then {
               child := Node("label="||idesession.Tidesession[index].Lusers[j])
               child.set_bmps([editorimgs("Online"),
                               editorimgs("Online"),
                               editorimgs("Online")])
               root.add(child)
               }
            j := j+1
            }#end while
         child := Node("label="||user)
         child.set_bmps([editorimgs("Online"),
                         editorimgs("Online"),
                         editorimgs("Online")])
         root.add(child)
         }
   end
   #
   # Create IDE session tree
   #
   method Create_Session_Tree(master,slave,user_me,file_name,found)
      local root,child1,user,r,flag := 0,r2

      r := ide_session_tree.get_root_node()

      if user_me == master then user := slave
      else user := master||" *"

      if not (find(hostuser, user_me)) then
         user ||:= "(owner)"

      if (found=1) then {
         root := Node("label="||file_name)
         r.add(root)
         }
      else if(found>1)&(user_me == master) then { #tree already exist
         r2 := ide_session_tree.get_root_node()
         root := Search_Tree(file_name,r2)
         }
      else if(\found>1)&(user_me ~== master) then { #tree is not there
         root := Node("label="||file_name)
         r.add(root)
         Create_Session_SubTree(found-10,root,user)
         flag := 1
         }
      if flag=0 then {
         child1 := Node("label="||user)
         child1.set_bmps([editorimgs("Online"),
                         editorimgs("Online"),
                         editorimgs("Online")])

         root.add(child1)
         }
      ide_session_tree.expand()
   end
   #
   # Remove $ from recieved user string
   #
   method Generate_Users_List(str_users)
      local i, L := [], k := 2, j, x

      every i := 2 to *str_users do {
         if str_users[i]=="$" then {
            x := str_users[k:i]
            if x == hostuser then
               x ||:= "(owner)"
            put(L,x)
            k := i+1
            }
         }
      put(L,str_users[k:0])
      return L
   end
   #
   # Send new invited user to all users in the IDE session
   #
   method Send_user_to_all_IDE(user_me,index_counter,Luser)
      local i

      every i := 1 to *Luser do {
         session.Write("\\CETLSendUser " || Luser[i]||" "||user_me||" "||
                       index_counter)
         }
   end
   #
   # add the new invited user to the tree
   #
   method Add_Node_To_Tree(file_name,user)
      local root,child,r

      r := ide_session_tree.get_root_node()
      root := Search_Tree(file_name,r)
      child := Node("label="||user)
      child.set_bmps([editorimgs("Online"),
                      editorimgs("Online"),
                      editorimgs("Online")])
      root.add(child)
      ide_session_tree.expand()
   end
   #
   # Delete the user who closed the file from the tree
   #
   method Delete_Node_From_Tree(file_name,user,file_or_user)
      local root,child,r,r2

      r := ide_session_tree.get_root_node()
      if file_or_user=1 then {#Remove the file from the tree
         root := Search_Tree(file_name,r)
         r.delete_node(root)
         }
      else {#Remove the user from the tree
         root := Search_Tree(file_name,r)
         r2 := Search_Tree(user,root)
         root.delete_node(r2)
         }
      ide_session_tree.expand()
   end
   #
   # Check_Gender(user)
   # Check user gender
   #
   method Check_Gender(user)
      local line, file, i, nm, val, file_path, sex

      file := datopen(world.avatar_path||user||PS||user||".avt") |
      stop("Checkgender: can't open ",file_path)
      while line := trim(read(file)) do {
         if line[1]~=="#" then {
            if not (i := find("=", line) + 1) then {
	       write_to_chat_win("avt file format error in ", image(line))
	       break
	       }
	    nm := map(line[1:i-1])
	    if *(val := line[i:0]) = 0 then break
	    case nm of {
	       "gender": sex := val
	       default : self[nm] := val
	       }
            }
         }
      close(file)
      if \sex=="f" then return "her"
      else return "his"
   end
   #
   # CETL_New 
   # Create a new tab in the reciever client
   # but ask user before opening the tab
   method CETL_New(args, flag)
      local user,oldwindow,temp,file_name,ide_prop,index_counter,slave,
         Addcounter,found,str_users,Luser,gender,msg,msg_contents, sdp_flag,
         mbox, ebox, m, font_size, lst_ln, lnum, cnum

      args ? {
         font_size := tab(find(" "))
         &pos +:= 1
         user := tab(find(" "))
         &pos +:= 1
         index_counter := integer(tab(find(" ")))
         &pos +:= 1
         slave := tab(find(" "))
         &pos +:= 1
         file_name := tab(find("|"))
         &pos +:= 1
         file_contents := tab(find("@@"))
         &pos +:= 2
         msg_contents := tab(find("$$"))
         &pos +:= 2
         hostuser := tab(find("$$"))
         &pos +:= 2
         Addcounter := integer(tab(find(" ")))
         &pos +:= 1
         str_users := tab(find(" "))
         &pos +:= 1
         sdp_flag := integer(tab(find(" ")))
         &pos +:= 1
         lst_ln := integer(tab(find(" ")))
         &pos +:= 1
         lnum := integer(tab(find(" ")))
         &pos +:= 1
         cnum := integer(tab(0))
         }

      session.Write("\\setIDESession "||file_name||" "||hostuser||
         " "||view.user_me)

      idesession.CETL_SetFileContents(file_contents)
      idesession.CETL_SetMsgBoxContents(msg_contents, 0)
#      oldwindow := &window
#      &window := &null
#         gender:=Check_Gender(user)
#         if gender == "his" then msg:="him" else msg:="her"
         if flag == 1 then {
            found := idesession.Check_Session(slave,file_name,index_counter,2)
            if found~=0 then{
               view.write_to_chat_win(" You have a file with the name "||
                                      file_name||" in collaboration session")
               session.Write("\\tell "||user||
                             " You have file with the same name "|| file_name)
               if Addcounter=1 then  #session is new one
                  session.Write("\\RejectIDE "||index_counter-1) 
                                              #reduce global counter
               }
            else {
               if ide_file_contents ==="Empty" then {
                  ide.new_tabitem(,1,file_name,"")
                  MsgBox1.set_contents([" "])
                  }
               else {
                  ide.new_tabitem(,1,(\file_name)|"test",ide_file_contents)

                  #Change the font to a compatible font
                  set_to_compatible_font(font_size)

                  # lst_ln is the last line visible on the screen, it came to
                  # us from the sender's network message.
                  # lnum is the line number (cursor_x).
                  view.uide.goto_line(1, 1)
                  view.uide.goto_line(lnum, cnum)

                  msg_contents ? {
                     m := tab(find("X$~$X"))
                     move(5)
                     }
                  msg_contents := m

                  MsgBox1.set_contents([msg_contents])
                  }
               # If we have list of users already in the collaboration
               if str_users ~== "No" then {
                  Luser := Generate_Users_List(str_users)
                  Send_user_to_all_IDE(user_me,index_counter,Luser)
                  }
               found := idesession.Create_New_IDESession(index_counter,
                      user,slave,ide.EditBox1, MsgBox1, file_name,"off",
                      user_me,Luser, lnum, cnum)
               Create_Session_Tree(user,slave,user_me,file_name,found)

               session.Write("\\CETLaccept " ||font_size||" "||user||
                             " "||index_counter||" "||file_name||" "||slave||
                             " "||\sdp_flag||" "||lst_ln||" "||lnum||" "||cnum) 
               session.Write("\\tell "||user || 
                             " accepted to start the collaborative IDE")
               session.Write("\\addFeed "||user||
                  " started a collaborative editing session with "||
                  slave||"."||"@@"||0||" "||"Session:"||file_name)
               session.Write("\\writeToWall "||user||
                  " started a collaborative editing session with  "||
                  slave||".")
               session.Write("\\writeToWall "||slave||
                  " started a collaborative editing session with  "||
                  user||".")
               }
            }
         else {
            session.Write("\\tell "||user||" sorry, i'm busy ") 
            if Addcounter=1 then{ #session is new one
               session.Write("\\RejectIDE "||
                             index_counter-1) #reduce global counter
               }
            }
   end
   #
   # Change the font to a compatible font
   #
   method set_to_compatible_font(fsize)
      local ceb, ccfont, ts

      ceb := ide.CurrentEditBox()
      ccfont := mpfont(fsize)
      (ceb).set_attribs("font=" || ccfont)
      ts := view.VCSC_tab
      ts.init()
      ts.resize()
      ts.display()
   end
   #
   # mpfont, the multi-platform size-compatible fonts
   #
   method mpfont(s)
   static t
   initial {
      t := table()
      t["small"] :=
      if &features == "MS Windows NT" then "typewriter,7" else "mono,7"
      t["medium"] :=
      if &features == "MS Windows NT" then "typewriter,16" else
          if &features == "MacOSX" then "mono,13" else "mono,14"
      t["large"] :=
      if &features == "MS Windows NT" then "typewriter,18" else "mono,16"
      t["huge"] :=
      if &features == "MS Windows NT" then "typewriter,22" else "mono,20"
      }
      return \ (t[s])
   end

   #--------------------------------------------------------------------#
   #---------------------# End Collaborative IDE #----------------------#
   #--------------------------------------------------------------------#
   #----------------------      IDE      -------------------------------#

   method tell_friend_activity(curr_mode)
      local usr, avat, ustat, u_loc

      if \(view.user_me) then {
         session.Write("\\updateMode "||user_me||" "||curr_mode)
         session.Write("\\checkMode "||user_me||" "||user_me)
         u_loc := world.all_friends_location [user_me]

         every usr := !onlinefriends_set do {
            if \(avat := world.get_avatar(usr)) then
               ustat := avat.get_activity_status()
            else ustat := "Offline"
            if \ustat == ("Online" | "Away" | "Busy") then
               session.Write("\\tell "||usr||" "||user_me||
                          " switched to "||curr_mode||
                          " mode. ["||u_loc||"]")
            }
      }
   end

   method on_tab_selection(ev)
      local vt_lbl := (VCSC_tab.get_which_one()).label
      if vt_lbl === MODEL_NAME then {
	 winflag := 0
         projMenu.set_isShaded()
	 restore_3DView()
         activity_tab_teardown()
         world.cam.avatar.actions("move_forward", 0.01)
	 eye(2)
         tell_friend_activity("3D")
	 }
      else if vt_lbl === "Map" then {
	 winflag := 0
         projMenu.set_isShaded()
	 resize_3DView()
         activity_tab_teardown()
         tell_friend_activity("Map")
	 }
      else if find("(PF):", vt_lbl) then {
	 winflag := 0
         projMenu.clear_isShaded()
         activity_tab_setup() #activity_tab_teardown()
	 resize_3DView()
         tell_friend_activity("Editor")
	 }
      else if find(".c"|".cpp"|".java"|".icn"|".uprj"|
         "Untitled", vt_lbl) then {
	 winflag := 0
         projMenu.clear_isShaded()
         activity_tab_teardown()
	 resize_3DView()
         tell_friend_activity("Editor")
	 }
      else if find("Profile", vt_lbl) then {
	 winflag := 1
         projMenu.set_isShaded()
         activity_tab_teardown()
         projMenu.close_file.clear_is_shaded()
	 resize_3DView()
         tell_friend_activity("Profile")
	 }
      else if find("Group:"|"Project:", vt_lbl) then {
	 winflag := 1
         projMenu.set_isShaded()
         activity_tab_teardown()
         projMenu.close_file.clear_is_shaded()
	 resize_3DView()
         tell_friend_activity("Wall")
	 }
   end

   method is_subwin_hidden()
      if view_3d.label===MODEL_NAME then {
	 resize_3DView()
	 }
      else {
	 restore_3DView()
	 }
   end

   method on_courseslist(ev, file_contents)
      world.moodle.mdl_courseslist()
   end 

   method on_assignment_btn(ev)
      world.moodle.mdl_assignment_btn(ev)
   end
   #
   # SQL hex string literal from binary .exe string
   #
   method hstr(s)
   local outs := "0x", i
      every i := ord(!s) do {
	 outs ||:= hch(i / 16)
	 outs ||:= hch(i % 16)
	 }
      return outs
   end

   method hch(c)
      if c < 0 | c > 15 then stop("c is ", image(c))
      case c of {
         10: return "a"
         11: return "b"
         12: return "c"
         13: return "d"
         14: return "e"
         15: return "f"
         default: return string(c)
         }
   end

   method on_mdl_grades(ev)
      system("firefox "|| "www.moodle.org")
   end

   method on_lect_notelist()
      world.moodle.mdl_lect_notelist()
   end

   method on_assignmentlist()
      world.moodle.mdl_assignmentlist()
   end

   # Not yet implemented 
   method CalculateTimeLeft(tm, timedue)
   end
   #
   # Web browsing code
   # Method on_send_url: on button click get the http web page
   #
   method on_send_url()
      local url, url_process, url_name, html_file, pos, j, fname
      local html_contents := []
      url := url_field.get_contents() #get the textbox contents
      # write("web mode",web_mode)
      if web_mode == 1 then {
         url_process := "http://"||url
         url_name := url_process  #global variable
         #write("on_send_url  "||url_name)
         Get_Http_Page(url_name) 
         }
      else { # local html file
         html_file := file_name(url)
         #write( "html: ",html_file," url: ",url )
         html_contents := localHTMLfiles(url)
         dehtml(\html_contents) #send web contents into dehtml.icn
         EditBox.set_contents(web_result) #web_result
         #c :=  view.VCSC_tab.get_tabitem(view.VCSC_tab.get_which_one().label)
         #view.VCSC_tab.set_which_one(c)
         view.VCSC_tab.set_which_one(view.VCSC_tab.which_one)
         view.resize()
         }
   end

   method localHTMLfiles(filename)
      local line, nchars, file, found, which_tab
      local tab_id, c

      if  filename[-2:0]==(".*") then filename := filename[1:-2] 
      file := open(filename, "ru") | {
	 view.write_to_chat_win("Could not open file: " || filename)
         fail
         }

      tab_label :=  file_name(filename)
      found := 1

      file_contents := []
      while line := read(file) do {
         if line[-1] == "\^m" then line := line[1:-1]
         put(file_contents, line)
         }

      insert(opened_files_set, tab_label)
      view.resize()
      view.is_subwin_hidden()
      opened_file := filename
      return file_contents
   end
   #
   # Method Get_Http_Page: Putting the web page in the list w
   # and then in the editable textbox
   #
   method Get_Http_Page(url_text)    
      local w := [],target := 0,f_read := "s",get_page,f2
      # write("Get_Http_Page  "||url_text)
      get_page := open(url_text,"m")
      f2 := open(basename(url_text,"w")) 
      while (f_read ~== "1") & (target=0) do {
         f_read := read(get_page) |  {target := 1}
         if (f_read ~== "1") then put(w,f_read)
         }
      dehtml(w) #send web contents into dehtml.icn
      EditBox.set_contents(web_result) #web_result is global list in dehtml.icn
   end
   #
   # Creating a new Web Browsing Tab.
   #
   method new_browsing_tabitem(ev,url_txt,mode)
      local tab_item_new,send_url,http_label

      web_mode := mode
      tab_item_new := TabItem()  
      tab_item_new.set_label("Web Browser")

      url_field := TextField()
      url_field.set_pos("27%", "4%")
      url_field.set_size("314", "20")
      url_field.set_draw_border()
      url_field.set_contents(url_txt)
      url_field.set_draw_border()
      self.set_focus(url_field)
      tab_item_new.add(url_field)

      send_url := TextButton()
      send_url.set_pos("85%", "4%")
      send_url.clear_toggles()
      send_url.set_label("View web site")
      send_url.set_internal_alignment("c")
      send_url.connect(self, "on_send_url", ACTION_EVENT) 
      tab_item_new.add(send_url)

      EditBox := TextList()
      EditBox.set_pos("2", "15%")
      EditBox.set_size("100%-4", "85%")
      EditBox.set_attribs("bg=white","font=sans,14")
      EditBox.set_contents([""])
      tab_item_new.add(EditBox) 

      http_label := Label()
      http_label.set_pos("2", "4%")
      http_label.set_size("185", "20")
      http_label.set_internal_alignment("l")
      http_label.set_label("Please Enter HTTP address")
      tab_item_new.add(http_label)

      VCSC_tab.add(tab_item_new)  
      tab_item_new.init()
      resize()
      VCSC_tab.set_which_one(tab_item_new)
      is_subwin_hidden()
   end
   #
   # method Recieved_Url : recieved url in the other party
   #
   method Recieved_Url(args)
      local indx,url,url_text

      indx := find(" ",args)      #find first space to get url
      url := args[indx+1: 0]
      write_to_chat_win(args)
      new_browsing_tabitem(,url)
      Get_Http_Page(url)
   end

   method restore_3DView()
      subwin.set_pos(5, 5)
      subwin.set_size("100%-12", "100%-12")
      subwin_x := self.parent_dialog.view_border.x + 5
      subwin_y := self.parent_dialog.view_border.y + 5 
      subwin_w := self.parent_dialog.view_border.w - 10
      subwin_h := self.parent_dialog.view_border.h - 10
      WAttrib(subwin.cwin, "pos="||subwin_x||","||subwin_y)
      WAttrib(subwin.cwin, "size="||subwin_w||","||subwin_h)
      #set_label(&null)
      view.resize()
   end

   method resize_3DView()
      oldpos := WAttrib(subwin.cwin, "pos")
      oldsize := WAttrib(subwin.cwin, "pos=0,30", "size=1,1")
      WAttrib(subwin.cwin, "pos=0,30", "size=1,1")
      subwin.set_pos(5, 5)
      subwin.set_size(1, 1)
      #set_label(&null)
   end

   method restore2D()
      profile_subwin2d.set_pos("0", "0")
      profile_subwin2d.set_size("100%-4", "100%-4")
      WAttrib(profile_subwin2d.cwin, "pos="||
         profile_subwin2d.x||","||profile_subwin2d.y)
      WAttrib(profile_subwin2d.cwin, "size="||
         profile_subwin2d.w||","||profile_subwin2d.h)

      ava_subwin2d.set_pos("0", "0")
      ava_subwin2d.set_size("100%-4", "100%-4")
      WAttrib(ava_subwin2d.cwin, "pos="||
         ava_subwin2d.x||","||ava_subwin2d.y)
      WAttrib(ava_subwin2d.cwin, "size="||
         ava_subwin2d.w||","||ava_subwin2d.h)
   end

   method resize2D()
      local sw_x, sw_y

      sw_x := self.parent_dialog.view_border.x + 1
      sw_y := self.parent_dialog.view_border.y + 1

      # resizing the progress chart
      WAttrib(profile_subwin2d.cwin, "pos="||
         sw_x||","||sw_y, "size=1,1")
      profile_subwin2d.set_size(sw_x, sw_y)
      profile_subwin2d.set_size(1, 1)

      # resizing the availability chart
      WAttrib(ava_subwin2d.cwin, "pos="||
         sw_x||","||sw_y, "size=1,1")
      ava_subwin2d.set_size(sw_x, sw_y)
      ava_subwin2d.set_size(1, 1)

      #close(profile_subwin2d.cwin)
      #close(ava_subwin2d.cwin)
   end

   method activity_tab_setup()
      activity_tabset.set_pos("71%", "1")
      activity_tabset.set_size("29%", "100%-2")
      activity_tabset.resize()
      view.VCSC_tab.set_pos("1", "1")
      view.VCSC_tab.set_size("71%", "100%-2") #"98%", "98%")
      #activity_tabset.clear_is_shaded()
      view.VCSC_tab.resize()
   end

   method activity_tab_teardown()
      activity_tabset.set_pos("2", "2")
      activity_tabset.set_size("1", "1")
      activity_tabset.resize()
      VCSC_tab.set_pos("1", "1")
      VCSC_tab.set_size("100%-2", "100%-2")
      #activity_tabset.set_is_shaded()
      view.VCSC_tab.resize()
   end

   method editor_tab()
      local editor := "yes"
      if (VCSC_tab.get_which_one()).label===(MODEL_NAME | "Map") then {
         write_to_chat_win("operation not allowed during the 3D mode.")
         editor := "no"
         }
      else if (VCSC_tab.get_which_one()).label==="Voice" then {
         write_to_chat_win("operation not allowed during the Voice mode.")
         editor := "no"
         }
      return editor
   end
   #
   # method UpdateUserList: update who is in the system at the users tab
   #
   method UpdateUserList(WhoIsUp)
      local name, name2, i, t, avat, status, duration
      WhoIsUp ? {
	 tab(many(' '))
	 if ="Users" then{
	    tab(find(":"))
	    move(1)
	    }
	 while not(pos(0)) do{
	    name2 := tab(upto(',\n')|0)
	    move(1)
	    name2 ? {
	       if \(name := tab(find(":"))) then{
		  move(1)
		  status := tab(upto('\n, '))
		  /status := "Online" 
		  if status=="afk" then {
		     move(1)
		     duration := integer(tab(many(&digits)))
		     }
		  if \(avat := world.get_avatar(name)) then {
		     if status=="afk" then
			avat.set_afk(duration)
		     else
			avat.set_activity_status(status)
		     }
		  } # if \(name ....
		else
		   name := tab(0)
	      session.adduser(name)
	      view.all_users()
	      } # ? name2
	   } # while
	 } # WhoIsUp ?
      #-- new voip
      #session.WhoIsUpList := copy(session.usersList)
      session.WhoIsUpList := session.get_list_of_users()
      if find("User",session.WhoIsUpList[1]) then
         delete(session.WhoIsUpList,1)

      every i := 1 to *session.WhoIsUpList do
         if session.WhoIsUpList[i][-1]=="," then 
            session.WhoIsUpList[i][-1] := ""
      Voice.Display_list.set_contents(session.WhoIsUpList)
      #voipdlg.Voice_users_list.set_selection_list(session.WhoIsUpList) ##check later
   end

   method on_ClassTabSet(ev)
      if (ClassTabSet.get_which_one()).label === ("Users"|"IDE Users") then
         who_users()
   end

   method showhistory_dlg(h_info[])
      local oldwindow, history_info := ""
      history_info ||:= !h_info
      oldwindow := &window
      &window := &null

      if TextDialog([history_info, "\n"] )=="Okay" then {
         dispose()
         }
      &window := oldwindow
   end

#
#
#

   method who_users()
      #if \session.IDESession then {
          session.usersList := []
	  session.usersSet := set()
          #usersDisplayList.set_selections([*session.usersList])
          session.Write("\\users") 	
          return [file_contents,opened_file]
      #}
   end

   method GetLocalIP()
      local fin, str, pos0, pos1, ip := "", substr := ""

$ifdef _UNIX
      #system("/sbin/ifconfig > ipconfig.txt")
      fin := open("/sbin/ifconfig","p")
      while str := read(fin) do {
         if find("addr:", str) then {
            pos0 := find(":",str)
            substr := str[pos0+1:(*str)]
            pos1 := find(" ",substr)
            ip := substr[1:pos1]
            close(fin)
            session.Write("\\setip " || ip )
            return 
            }
         }
$else
      #system("ipconfig > ipconfig.txt")
      fin := open("ipconfig", "p")
      while str := read(fin) do{
         if find("IP Address", str) then {
            pos0 := find(":",str)
            #pos1 := find("\r",str[pos0:(*str)])
            ip := str[pos0:(*str)]
            close(fin)
            #system("rm -f ipconfig.txt")
            session.Write("\\setip " || ip )
            return 
            }
         }
$endif
   end

   method InstructorInfo()
      world.moodle.mdl_InstructorInfo(teachername, teacheremail, forumlist)
   end

   method on_courselist()
      world.moodle.mdl_courselist(tablist, courseslist, tabItem, teachername, teacheremail, forumlist, clientIP)
   end

   method fetchIP(IP)
      clientIP := IP
      #write("ClientIP " , clientIP)
      # late updation of the client IP 
      # login info is updated into the database here rather than 
      # near setup()
      #
      world.moodle.ClientUserActivity(courseslist, clientIP)
      #write("fetchIP function")
   end

   method on_Desc(ev)
   end

   method on_username(ev)
   end

   method on_users_btn(ev)
   end

   method on_username_1(ev)
   end

   method on_courselist_1(ev)
   end

   method on_open_web(ev)
      new_browsing_tabitem(,"",1)
   end

   method on_filebrowser_click(ev)
      FileBrowser.handle_press(ev)
   end

   method on_text_button_33(ev)
   end

   method on_activequeststl(ev)
      local questk, npc_name, quest, questinvdialog, questdialog
      if (questk := activequeststl.object_get_cursor())==="" then fail

      quest := world.user_inventory.get_active_quest(questk)
      if /quest then fail

      questinvdialog := QuestInvitationDialog(quest, "run quest")
      questinvdialog.show_modal()

      if questinvdialog.user_choice=="take quest" then{
         questdialog := QuestDialog(quest)
         questdialog.show_modal()
         if quest.is_completed() & questdialog.user_choice=="ok" then{
            world.user_inventory.finish_quest(quest.npc_name, quest, questk)
            session.Write("\\npcmsg " || quest.npc_name || 
                          " Quest Title(" || quest.title  || ") Done" ||
                          " Score=" || string(quest.get_user_score()))
            }
         }
   end

   method on_showonline_chkbx(ev)
      /showonline_checked := 1

      if showonline_checked = 0 then
         showonline_checked := 1
      else
         showonline_checked := 0
      
      users_tree.set_root_node(&null)
      all_users()
      users_tree.tree_structure_changed()
   end

   method on_users_tree(ev)
      local snode, snode_depth, loc, uNode, nodeParent

      snode := users_tree.object_get_cursor().get_label()
      snode_depth := (users_tree.object_get_cursor()).depth
      selected_node := "user"

      if \snode then {
      if snode_depth = 1 then {
         if ev.get_param() = -6 then {
            if ((VCSC_tab.get_which_one()).label) == MODEL_NAME then {
               resize_3DView()
               VCSC_tab.set_which_one(view_map)
               }
            }
         ici_groups.users_popup_menu()
         }
      else if snode_depth = 2 then {
         if find("Friends", snode) |
            find("Online", snode) |
            find("Offline", snode) |
            find("NPCs", snode) then {
            }
         else {
            snode ? {
               selected_user := tab(find(" "))
               move(1)
               loc := tab(0)
               }

            if \selected_user then {
               if ev.get_param() = -4 then {
                  if (VCSC_tab.get_which_one()).label == "Map" then
                     view.resize()
                  session.Write("\\memberProjectsList "||selected_user||" "||
                  view.user_me)
                  }
               if ev.get_param() = -6 then {
                  session.Write("\\memberProjectsList "||selected_user||" "||
                  view.user_me)
                  if ((VCSC_tab.get_which_one()).label) == MODEL_NAME then {
                     resize_3DView()
                     VCSC_tab.set_which_one(view_map)
                     }

                  if \snode then
                     ici_groups.users_popup_menu()
                  }
               }
            }
         }
      else if snode_depth = 3 then {
         uNode := world.nsh_dialog.users_tree.object_get_cursor()
         nodeParent := (uNode.get_parent_node()).get_label()

         if not find("NPCs", nodeParent) then {
         if \snode then {
            snode ? {
               selected_user := tab(find(" "))
               move(1)
               loc := tab(0)
               }

            if \selected_user then {
               if ev.get_param() = -4 then {
                  if (VCSC_tab.get_which_one()).label == "Map" then
                     view.resize()
                  session.Write("\\memberProjectsList "||selected_user||" "||
                  view.user_me)
                  }
               if ev.get_param() = -6 then {
                  session.Write("\\memberProjectsList "||selected_user||" "||
                  view.user_me)

                  if ((VCSC_tab.get_which_one()).label) == MODEL_NAME then {
                     resize_3DView()
                     VCSC_tab.set_which_one(view_map)
                     }

                  if \snode then
                     ici_groups.users_popup_menu()
                  }
               }
            }
            }
         }
         }
      else  world.write_chat("Select a user node...")
   end
   #
   # This popup menu allows the user to:
   # Invite for collaboration session, leave session, 
   # and IDE take turn
   #
   method idesession_popup_menu()
      local tree_pop, p_menu, invite_to_ide_session,
         leave_ide_session, ide_take_turn, sep_1, 
         invite_to_group, usrid, invited_usr, invited_user, 
         avat, ustat, ide_activity_history, selected_node_depth

      tree_pop := PopupMenu()

      p_menu := Menu()

      tree_pop.set_menu(p_menu)
      tree_pop.set_attribs("bg=white")

      selected_node_depth := (world.nsh_dialog.ide_session_tree.object_get_cursor()).depth

      if selected_node_depth == (2) then {
         invite_to_ide_session := Menu()
         invite_to_ide_session.set_label("Invite to IDE Session")

         every usrid := key(world.all_registered_users) do {
            if \(avat := world.get_avatar(usrid)) then
	       ustat := avat.get_activity_status()
	    else
	       ustat := "Offline"

            if ustat ~== "Offline" then {
               if usrid ~== user_me then {
                  invited_usr := TextMenuItem()
                  invited_usr.set_label(usrid)
                  invited_user := image(invited_usr.get_label())
                  invited_usr.connect(self, 
                     "on_invite_user_to_existing_ide_session", ACTION_EVENT)
                  invite_to_ide_session.add(invited_usr)
                  }
               }
            }
         p_menu.add(invite_to_ide_session)

         leave_ide_session := TextMenuItem()
         leave_ide_session.set_label("Leave IDE Session")
         leave_ide_session.connect(self, "on_leave_ide_session", ACTION_EVENT)
         p_menu.add(leave_ide_session)

         ide_take_turn := TextMenuItem()
         ide_take_turn.set_label("IDE: Take Turn")
         ide_take_turn.connect(self, "on_ide_take_turn", ACTION_EVENT)
         p_menu.add(ide_take_turn)

         ide_activity_history := TextMenuItem()
         ide_activity_history.set_label("Activity History")
         ide_activity_history.connect(self, "on_ide_activity_history", ACTION_EVENT)
         p_menu.add(ide_activity_history)
         }

      view.add(tree_pop)
      tree_pop.init()
      tree_pop.resize()
      tree_pop.popup()
   end
   #
   # Invite user to join an existing collaboration session
   #
   method on_invite_user_to_existing_ide_session(ev)
      filename := (\ide_session_tree.object_get_selections()[1]).get_label()
      n_username := (ev.get_source()).label

      if find("(PF):", filename) then
         sdp_flag := 1
      
      on_user_invitation_btn(ev, n_username, filename, sdp_flag, 1)
   end

   #
   # The user leaves the IDE session
   #
   method on_leave_ide_session(ev)
      on_exit_session_btn()
   end
   #
   # The user calls to take turn editing the shared files
   # during the collaboration session.
   #
   method on_ide_take_turn(ev)
      on_get_lock_btn()
   end
   #
   # View Session's Activity History
   #
   method on_ide_activity_history(ev)
      local sNode, sName
      sNode := view.ide_session_tree.object_get_selections()[1]
      sName := sNode.get_label()
      session.Write("\\sessionActivity "||sName||" "||view.user_me)
   end

   #
   # View User's activity summary
   #
   method on_view_activity_menu_item(ev)
      session.Write("\\history " ||
         (\users_tree.object_get_selections()[1]).get_label())
   end

   method on_view_active_quests_menu_item(ev)
      session.Write("\\history " || (\users_tree.object_get_selections()[1]).get_label() || 
                    " QuestActive")
   end

   method on_view_completed_quests_menu_item(ev)
      session.Write("\\history " || (\users_tree.object_get_selections()[1]).get_label() || 
                    " QuestActive")
   end
   
   method reset_users_tree()
      local users_lbl, usrid, avat, ustat

      users_tree.set_root_node(&null)
      users_lbl := Node("label=Users(0)")
      users_tree.set_root_node(users_lbl)

      every usrid := key(world.all_registered_users) do {
         if \(avat := world.get_avatar(usrid)) then {
            ustat := avat.get_activity_status()
            if ustat === ("Online" | "Away" | "Busy") then
               avat.set_activity_status("Offline")
            }
         }
      all_users()
   end

   method all_users()
      local usrid, users_lbl, ustat, avat, uloc, r, friends_lbl, npcs_lbl,
         me_lbl, onlineUsers_lbl, offlineUsers_lbl, users_total := 0, 
         npcs_total := 0,
         online_npcs_total := 0,
         onlinefriends_total := 0,
         onlineusers_total := 0, 
         offlineusers_total := 0,
         friends_total := 0
      onlineusers_set  := set()
      offlineusers_set := set()
      onlinefriends_set := set()
      users_tree.set_root_node(&null)

      every usrid := key(world.all_other_users) do {
         if \(avat := world.get_avatar(usrid)) then
            ustat := avat.get_activity_status()
         else
            ustat := "Offline"

         if \ustat ~== "Offline" then  {
            insert(onlineusers_set, usrid)
            }
         else insert(offlineusers_set, usrid)
         }

      if \world.all_registered_users then 
          friends_total := *world.all_registered_users - 1
      if \world.all_npc_users then 
          npcs_total := *world.all_npc_users
      if \onlineusers_set then onlineusers_total := *onlineusers_set      
      if \offlineusers_set then offlineusers_total := *offlineusers_set      
      
      users_total := friends_total + onlineusers_total + 
          offlineusers_total + npcs_total + 1
   
      users_lbl := Node("label=Users("||users_total||")")
      users_tree.set_root_node(users_lbl)
      r := users_tree.get_root_node()

      every usrid := key(world.all_registered_users) do {
         if \(avat := world.get_avatar(usrid)) then {
            ustat := avat.get_activity_status()
            if usrid ~== user_me then
               onlinefriends_total +:= 1
            }
         else
            ustat := "Offline"
         uloc := world.all_friends_location [usrid]
         if usrid === user_me then
            add_user_node(usrid||" ["||uloc||"]", ustat, "me")
         }

      every usrid := key(world.all_npc_users) do {
         if \(avat := world.get_avatar(usrid)) then {
            ustat := avat.get_activity_status()
            online_npcs_total +:= 1
            }
         else
            ustat := "Offline"
         }

      if friends_total > 0 then {
         friends_lbl := Node("label=Friends("||onlinefriends_total||"/"||
            friends_total||")")
         r.add(friends_lbl)
         }

      if npcs_total > 0 then {
         npcs_lbl := Node("label=NPCs("||online_npcs_total||"/"||
                          npcs_total||")")
         r.add(npcs_lbl)
         }

      if onlineusers_total > 0 then {
         onlineUsers_lbl := Node("label=Online("||onlineusers_total||")")
         r.add(onlineUsers_lbl)
         }

      if offlineusers_total > 0 then {
         offlineUsers_lbl := Node("label=Offline("||offlineusers_total||")")
         r.add(offlineUsers_lbl)
         }
  
      # add users' nodes (others)
      every usrid := key(world.all_registered_users) do {
         if \(avat := world.get_avatar(usrid)) then
            ustat := avat.get_activity_status()
         else
            ustat := "Offline"
         uloc := world.all_friends_location [usrid]
         if usrid ~== world.userId then
            if showonline_checked = 1 & ustat == "Offline" then next

         if usrid ~== user_me then {
            add_user_node(usrid||" ["||uloc||"]", ustat, "friend")
            insert(onlinefriends_set, usrid)
            }
         }

      every usrid := key(world.all_other_users) do {
         if \(avat := world.get_avatar(usrid)) then
            ustat := avat.get_activity_status()
         else
            ustat := "Offline"
         uloc := world.all_others_location [usrid]

         add_user_node(usrid||" ["||uloc||"]", ustat, "others")
         }

      every usrid := key(world.all_npc_users) do {
         if \(avat := world.get_avatar(usrid)) then
            ustat := avat.get_activity_status()
         else
            ustat := "Offline"
         uloc := world.all_npc_location[usrid]

         add_user_node(usrid||" ["||uloc||"]", ustat, "npcs")
         }

      old_onlineusers_set := set()
      every insert(old_onlineusers_set, !onlineusers_set)
      insert(old_onlineusers_set, user_me)

      users_tree.expand()
      users_tree.tree_structure_changed()
   end

   method add_user_node(userid, ustat, relation)
      local r, r2, node, users_lbl, usrid, usrloc

      r2 := users_tree.get_root_node()

      if relation == "me" then {
         node := Node("label="||userid)
         if \ustat == "Online" then
            node.set_bmps([editorimgs("me"),editorimgs("me"),editorimgs("me")])
         else
            node.set_bmps([editorimgs(map(ustat)),
                           editorimgs(map(ustat)),
                           editorimgs(map(ustat))])
          
         r2.add(node)
         }
      else if relation == "friend" then
         r := Search_Tree("Friends", r2)
      else if relation == "npcs" then
         r := Search_Tree("NPCs", r2)
      else if relation == "others" then {
         if \ustat == ("Busy" | "Away" | "Online") then
            r := Search_Tree("Online", r2)
         else if \ustat == "Offline" then
            r := Search_Tree("Offline", r2)
         }

      node := Node("label="||userid)

      if \is_standalone = 1 then {
         node.set_bmps([editorimgs("busy"),
                        editorimgs("busy"),
                        editorimgs("busy")])
         r.add(node)
         }
      else {
         if \ustat == "Busy" then
            node.set_bmps([editorimgs("busy"),
                           editorimgs("busy"),
                           editorimgs("busy")])
         else if \ustat == "Away" then
            node.set_bmps([editorimgs("away"),
                           editorimgs("away"),
                           editorimgs("away")])
         else if \ustat == "Offline" then
            node.set_bmps([editorimgs("offline"),
                           editorimgs("offline"),
                           editorimgs("offline")])
         else
            node.set_bmps([editorimgs("online"),
                           editorimgs("online"),
                           editorimgs("online")])

         userid ? {
            usrid := tab(find(" "))
            move(1)
            usrloc := tab(0)
            }
#         if usrid == user_me &
#            \ustat == "Online" then
#            node.set_bmps([editorimgs("me"),
#                           editorimgs("me"),
#                           editorimgs("me")])
#
         if usrid ~== user_me then
            r.add(node)
         }
      users_tree.expand()
   end

  method on_ide_session_tree(ev)
     local selected_node_depth, str1, str2

     selected_node := world.nsh_dialog.ide_session_tree.object_get_cursor().get_label()
     selected_node := trim(selected_node, " ", 0)
     selected_node_depth := (world.nsh_dialog.ide_session_tree.object_get_cursor()).depth

     if selected_node_depth == 1 then {
        selected_node ? {
           str1 := tab(find("("))
           move(1)
           str2 := integer(tab(find(")"))) # number of sessions
           move(1)
           }
        #if \str2 = 0 then
        #   idesession_popup_menu()
        }
     if ev.get_param() = -6 then
        if selected_node_depth == 2 then
           idesession_popup_menu()
     else {
        if selected_node_depth == (2) then
           session.Write("\\sessionTooltip "||user_me||
              " "||\selected_node)
        }
  end

  method on_groups_tree(ev)
     if \view.user_me then {
        selected_node := "group"
        selected_group := groups_tree.object_get_cursor().get_label()
        if \ selected_group then
           if ev.get_param() = -6 then {
              if ((VCSC_tab.get_which_one()).label) == MODEL_NAME then {
                 resize_3DView()
                 VCSC_tab.set_which_one(view_map)
                 }
              ici_groups.groups_popup_menu()
              }
           else {
              if (VCSC_tab.get_which_one()).label == "Map" then
                 view.resize()
              }
        }
  end

  method on_projects_tree(ev)
     local projName, txt, user_id, selected_node_depth, selected_proj_node,
        sNode, sName, pt, ptn
     if \view.user_me then {
        pt := \(projects_tree.object_get_selections()[1])
        if \pt then
           active_projName := \(pt.get_label())
        if \active_projName & \pt then {
        selectedProjFileID := 1
        if ev.get_param() = -6 then {
           session.Write("\\myProjectsList "||view.user_me)

           if ((VCSC_tab.get_which_one()).label) == MODEL_NAME then {
              resize_3DView()
              VCSC_tab.set_which_one(view_map)
              }
           projectdlg.project_popup_menu()
           }
        else {
           if (VCSC_tab.get_which_one()).label == "Map" then
              view.resize()
           pt := \(projects_tree.object_get_selections()[1])
           if \pt then
              active_projName := \(pt.get_label())
           if \active_projName then {
              session.Write("\\membersColorList "||user_me||
              " "||\active_projName)
              session.Write("\\projMembersLst "||user_me||" "||
              \active_projName)
           }
           ptn := world.nsh_dialog.projects_tree.object_get_cursor()
           selected_node := ptn.get_label()
           selected_node := trim(selected_node, " ", 0)
           selected_node_depth := ptn.depth

           if selected_node_depth == (2) then {
              session.Write("\\projTooltip "||2||" "||user_me||
              " "||\selected_node||" "||"NULL")
              }
           else if selected_node_depth == (3) then {
              sNode := world.nsh_dialog.projects_tree.object_get_selections()[1]
              if \sNode then {
                 sName := sNode.get_parent_node()
                 sName := sName.get_label()
                 }

              selected_proj_node := sName

              session.Write("\\projTooltip "||3||" "||user_me||
              " "||\selected_proj_node||" "||selected_node)
              }
           }
           }
        }
  end

  method on_inbox(ev)
     local btn_lbl

     btn_lbl := (ev.get_source()).label
     if (btn_lbl === "Inbox ...") then {
        emails_selected := 1
        ici_pendings.show_modal()
        }
  end

  method on_pendings_btn(ev)
     local menu_lbl, btn_lbl

     menu_lbl := integer((view.notifications_menu_icn).label)
     if menu_lbl > 0 then {
        btn_lbl := (ev.get_source()).label
        emails_selected := &null
        if (btn_lbl === "Browse ...") then
           ici_pendings.show_modal()
        }
     else view.write_to_chat_win("Your notifications' box is empty (0 notifications)...")
  end

  method get_chart_info(projName)
     local p
     p := trim(projName, ' ', 0)

     session.Write("\\userTimeSpent " || view.user_me || " " ||p)
  end

  method set_member_not_active()
     EraseArea(win2d)
     WAttrib(win2d, "fg=black")
     CenterString(win2d, 105, 75, "You are not yet a member")
     CenterString(win2d, 105, 90, "of any project.")
     view.resize()
  end

  method activity_chart(info_str)
     local user_time_tbl, user_color_tbl, projName, info_lst,
        l, uId, uColor, time_spent
     user_time_tbl := table(0)
     user_color_tbl := table(0)

     info_str ? {
        projName := tab(find("~"))
        move(1)
        info_lst := tab(0)
        }
     if *info_lst > 0 then {
        info_lst ? {
           while not(pos(0)) do {
              l :=  tab(find(","))
              move(1)
              if l ~== "" then {
                 l ? {
                    uId := tab(find(":"))
                    move(1)
                    uColor := tab(find(":"))
                    move(1)
                    time_spent := integer(tab(0))
                    }
                 user_time_tbl[uId] := time_spent
                 user_color_tbl[uId] := uColor
                 }
              }
           }
        }
     else {
        EraseArea(win2d)
        WAttrib(win2d, "fg=black")
        CenterString(win2d, 105, 15, "Activity of ("||projName||")")
        CenterString(win2d, 105, 30, "--------------------")
        CenterString(win2d, 105, 45, "SCI shows no activity")
        CenterString(win2d, 105, 60, "in this project.")
        }

     plot_figure(user_time_tbl, user_color_tbl, projName)
     mainprog_win := 1
  end

  method plot_figure(user_time_tbl, user_color_tbl, projName)
     local xscale := 0.0, yscale := 0.0, total_spent := 0,
        maxi, t_spent, u, k, maxlength, drawing_shift

     every u := key(user_time_tbl) do {
        total_spent +:= user_time_tbl[u]
        }

     if *user_time_tbl > 0 then {
     if total_spent > 0 then {
        EraseArea(win2d)
        xscale := (165.0/(*user_time_tbl))
        maxi := 0
        every u := key(user_time_tbl) do {
           #percentage time spent scaled to the window height
           t_spent := ((user_time_tbl[u] * 1.0) / total_spent) * 165.0
           if t_spent > maxi then maxi := t_spent
           if maxi > 0 then
              yscale := 152.0/maxi
           }

        WAttrib(win2d, "fg=black")
        CenterString(win2d, 105, 05, "Activity of ("||projName||")")
        CenterString(win2d, 105, 20, "project's members")
        CenterString(win2d, 105, 35, "Members are : ["||*user_time_tbl||"]")
        CenterString(win2d, 105, 45, "--------------------")

        maxlength := 0  #stores the max length of the file names
        every u := key(user_time_tbl) do {
           if *u > maxlength then maxlength := *u
           }
        # maxlength * char_width
        drawing_shift := maxlength * WAttrib("fwidth") + 2

        k := 1
        if total_spent > 0 then
        every u := key(user_time_tbl) do {
           #percentage time spent
           t_spent := round(((user_time_tbl[u] * 1.0) / (total_spent * 1.0)) * 100.0)

           WAttrib(win2d, "fg=black")
           DrawString(win2d, 1, 157-(k*(xscale/2)-(xscale/4)+15), u)
           WAttrib(win2d, "fg="||user_color_tbl[u])
           FillRectangle(win2d, drawing_shift, 152-(k*(xscale/2)+15), 
              yscale*t_spent, xscale/2)
           WAttrib(win2d, "fg=blue")
           DrawString(win2d, (yscale*t_spent)+ drawing_shift, 
              157-(k*(xscale/2)-(xscale/4)+15), t_spent ||"%")
           k +:= 1
          }
        }
     else {
        EraseArea(win2d)
        WAttrib(win2d, "fg=black")
        CenterString(win2d, 105, 05, "Activity of ("||projName||")")
        CenterString(win2d, 105, 20, "project's members")
        CenterString(win2d, 105, 35, "Members are : ["||*user_time_tbl||"]")
        CenterString(win2d, 105, 45, "--------------------")
        CenterString(win2d, 105, 75, "No activity")
        CenterString(win2d, 105, 90, "on this project.")
        }
        }

     view.resize()
  end


  method plot_users_availability(ava_str)
     local colors, sp, mx, i, s, l, wday, hrs, tminutes, hr, dayslst := []

     colors := colormap()
     AvWin := open("Users' Availability", "g", "height=180",
        "width=480", "bg=black", "inputmask=c") | stop("can't open window")
     dispatcher.add_raw_win(AvWin)
     #rectangle drawing
     WAttrib(AvWin, "fg=white")
     DrawRectangle(AvWin, 0, 0, 478, 150)
     DrawRectangle(AvWin, 0, 150, 478, 30)

     #legend drawing
     WAttrib(AvWin, "fg=red")
     FillRectangle(AvWin, 40, 155, 10, 10)
     DrawString(AvWin, 55, 165, "Never")
     WAttrib(AvWin, "fg=yellow")
     FillRectangle(AvWin, 140, 155, 10, 10)
     DrawString(AvWin, 155, 165, "Low")
     WAttrib(AvWin, "fg=green")
     FillRectangle(AvWin, 240, 155, 10, 10)
     DrawString(AvWin, 255, 165, "High")

     #Draw table header
     x := 30
     sp := 0
     mx := 30

     WAttrib(AvWin, "fg=white")
     DrawString(AvWin, mx, 10, "AM")
     every i := 1 to 24 do {
        s := i
        WAttrib(AvWin, "fg=white")
        mx := (x + sp + (i * 15)) - 12
        if s = 12 then
           DrawString(AvWin, mx-5, 10, "noon")
        if s > 12 then {
           s -:= 12
           if s = 12 then
              DrawString(AvWin, mx-5, 10, "midnight")
           DrawString(AvWin, mx, 20, s)
           }
        else DrawString(AvWin, mx, 20, s)
        sp +:= 1
        }

     #Draw table contents
     ava_str ? {
        y := 25
        while not(pos(0)) do {
           l := tab(find("&&"))
           move(2)
           x := 30
           l ? {
              wday := tab(find(" "))[1:4]
              move(1)
              hrs := tab(0)
              }
           #drawing the day strings
           WAttrib(AvWin, "fg=white")
           DrawString(AvWin, 5, y+15, wday)

           tminutes := 0 #total minutes per day
           hrs ? {
              while not(pos(0)) do {
                 hr := integer(tab(find(" ")))
                 tminutes +:= hr
                 if hr = 0 then {
                    WAttrib(AvWin, "fg=red")
                    FillRectangle(AvWin, x, y, 15, 15)
                    }
                 else if hr <= 20 then {
                    WAttrib(AvWin, "fg=yellow")
                    FillRectangle(AvWin, x, y, 15, 15)
                    }
                 else if hr > 20 then {
                    WAttrib(AvWin, "fg=green")
                    FillRectangle(AvWin, x, y, 15, 15)
                    }
                 move(1)
                 x +:= 16
                 }
                 WAttrib(AvWin, "fg=white")
                 DrawString(AvWin, x, y+10, tminutes||" times")
                 tminutes := 0
              }
           y +:= 16
           }
       }
    #WFlush(AvWin)
    #WSync(AvWin)
    #WDone(AvWin)
    view.resize()
  end

  method plot_availability(objType, userID, ava_str)
     local colors, sp, mx, i, s, l, wday, hrs, tminutes, hr,
        cLDays, d

     colors := colormap()

     if objType == "user" then {
        AvWin := open(userID||"'s Availability Table", "g", "height=180",
        "width=480", "inputmask=c") | stop("can't open window")
        }
     else {
        AvWin := open("Users' Availability", "g", "height=174",
        "width=480", "canvas=hidden") | stop("can't open window")
        }

     WAttrib(AvWin, "bg=pale blue")

     #rectangle drawing
     WAttrib(AvWin, "fg=blue")
     DrawRectangle(AvWin, 0, 0, 478, 140)
     DrawRectangle(AvWin, 0, 140, 478, 30)

     #legend drawing
     WAttrib(AvWin, "fg=red")
     FillRectangle(AvWin, 40, 155, 10, 10)
     CenterString(AvWin, 70, 160, "Never")
     WAttrib(AvWin, "fg=yellow")
     FillRectangle(AvWin, 140, 155, 10, 10)
     CenterString(AvWin, 170, 160, "Low")
     WAttrib(AvWin, "fg=green")
     FillRectangle(AvWin, 240, 155, 10, 10)
     CenterString(AvWin, 270, 160, "High")

     #Draw table header
     x := 30
     sp := 0
     mx := 30

     WAttrib(AvWin, "fg=black")
     CenterString(AvWin, mx, 10, "AM")
     every i := 1 to 24 do {
        s := i
        WAttrib(AvWin, "fg=black")
        mx := (x + sp + (i * 15)) - 12
        if s = 12 then
           CenterString(AvWin, mx-5, 10, "noon")
        if s > 12 then {
           s -:= 12
           if s = 12 then
              CenterString(AvWin, mx-5, 10, "midnight")
           CenterString(AvWin, mx, 20, s)
           }
        else
           CenterString(AvWin, mx, 20, s)
        sp +:= 1
        }

       CenterString(AvWin, 30 + (26 * 16), 20, "min(Avg)")

       #Draw table contents
       if ava_str ~== "" then {
        ava_str ? {
           y := 25
           while not(pos(0)) do {
              l := tab(find("&&"))
              move(2)
              x := 30
              l ? {
                 wday := tab(find(" "))[1:4]
                 move(1)
                 hrs := tab(0)
                 }
              #drawing the day strings
              WAttrib(AvWin, "fg=black")
              CenterString(AvWin, 20, y+10, wday)

              tminutes := 0 #total minutes per day
              hrs ? {
                 while not(pos(0)) do {
                    hr := integer(tab(find(" ")))
                    tminutes +:= hr
                    if hr = 0 then {
                       WAttrib(AvWin, "fg=red")
                       FillRectangle(AvWin, x, y, 15, 15)
                       }
                    else if hr <= 20 then {
                       WAttrib(AvWin, "fg=yellow")
                       FillRectangle(AvWin, x, y, 15, 15)
                       }
                    else if hr > 20 then {
                       WAttrib(AvWin, "fg=green")
                       FillRectangle(AvWin, x, y, 15, 15)
                       }
                    move(1)
                    x +:= 16
                    }
                    WAttrib(AvWin, "fg=black")
                    CenterString(AvWin, x+25, y+10, tminutes||" min")
                    tminutes := 0
                 }
              y +:= 16
              }
          }
       }
    else {
       cLDays := ["Sunday", "Monday", "Tuesday", "Wednesday",
                 "Thursday", "Friday", "Saturday"]
       y := 25
       every d := !cLDays do {
          x := 30
          #drawing the day strings
          WAttrib(AvWin, "fg=black")
          CenterString(AvWin, 20, y+10, d[1:4])
          WAttrib(AvWin, "fg=red")
          every i := 1 to 24 do {
             FillRectangle(AvWin, x, y, 15, 15)
             x +:= 16
             }
          WAttrib(AvWin, "fg=black")
          CenterString(AvWin, x+25, y+10, "0 min")
          y +:= 16
          }
       }
     prog_and_ava_isReady := 1
  end

  method on_newsfeed_tree(ev)
     if ev.get_param() = -6 then
        ici_newsfeed.newsfeed_popup()
  end

  method on_close(ev)
     # Added to replace dispose() for a reason
     projMenu.on_exit(ev) 
  end

  method setup()
    local View_3D_overlay_item, border_14, class_browser_tab_item, users_tab_item, view_3d
    self.set_attribs("size=950,700", "resize=on", "label=CVE", "bg=very light whitish gray")
    self.set_min_size(700, 515)
    chatarea := Border()
    chatarea.set_pos("23%", "75%")
    chatarea.set_size("77%-2", "25%-4")
    chatarea.set_attribs("resize=on")
    chatarea.set_internal_alignment("l")
    chat_input := TextField()
    chat_input.set_pos("2", "80%+4")
    chat_input.set_size("100%-4", "20%-4")
    chat_input.set_draw_border()
    chat_input.set_attribs("bg=very light whitish green", "resize=on")
    chat_input.connect(self, "on_chat", ACTION_EVENT)
    chat_input.set_contents("")
    chatarea.add(chat_input)
    chat_output := TextList()
    chat_output.set_pos("60%+2", "2")
    chat_output.set_size("40%-2", "80%-4")
    chat_output.set_draw_border()
    chat_output.set_attribs("bg=very light whitish yellow", "resize=on")
    chat_output.set_contents([""])
    chatarea.add(chat_output)
    user_chat_output := TextList()
    user_chat_output.set_pos("2", "2")
    user_chat_output.set_size("60%-2", "80%-4")
    user_chat_output.set_draw_border()
    user_chat_output.set_attribs("bg=very light whitish yellow", "resize=on")
    user_chat_output.set_contents([""])
    chatarea.add(user_chat_output)
    self.add(chatarea)
    browser := Border()
    browser.set_pos("0", "4%")
    browser.set_size("23%", "71%-4")
    browser.set_attribs("resize=on")
    browser.set_internal_alignment("l")
    ClassTabSet := BufferTabSet()
    ClassTabSet.set_pos("2", "2")
    ClassTabSet.set_size("100%-4", "100%-4")
    ClassTabSet.set_attribs("font=serif,17", "fg=#630000")
    ClassTabSet.connect(self, "on_ClassTabSet", ACTION_EVENT)
    class_browser_tab_item := TabItem()
    class_browser_tab_item.set_label("Class Browser")
    FileBrowser := ClassBrowser()
    FileBrowser.set_pos("2%", "8%")
    FileBrowser.set_size("96%", "90%")
    FileBrowser.set_draw_border()
    FileBrowser.set_attribs("bg=white", "font=serif,15")
    FileBrowser.connect(self, "on_filebrowser_click", SELECTION_CHANGED_EVENT)
    FileBrowser.set_select_one()
    class_browser_tab_item.add(FileBrowser)
    ClassTabSet.add(class_browser_tab_item)
    users_tab_item := TabItem()
    users_tab_item.set_label("Activity")
    usersDisplayList := TextList()
    usersDisplayList.set_pos(141, 233)
    usersDisplayList.set_size("46", "52")
    usersDisplayList.set_draw_border()
    usersDisplayList.set_is_shaded()
    usersDisplayList.set_attribs("bg=white")
    usersDisplayList.set_select_one()
    usersDisplayList.set_contents([""])
    users_tab_item.add(usersDisplayList)
    user_invitation_btn := TextButton()
    user_invitation_btn.set_pos("33", "220")
    user_invitation_btn.set_size("45%", "6%")
    user_invitation_btn.set_is_shaded()
    user_invitation_btn.connect(self, "on_user_invitation_btn", ACTION_EVENT)
    user_invitation_btn.clear_toggles()
    user_invitation_btn.set_label("Invite User")
    user_invitation_btn.set_internal_alignment("c")
    users_tab_item.add(user_invitation_btn)
    ide_session_tree := Tree()
    ide_session_tree.set_pos("2%", "5%")
    ide_session_tree.set_size("96%", "26%")
    ide_session_tree.set_draw_border()
    ide_session_tree.set_attribs("bg=white")
    ide_session_tree.connect(self, "on_ide_session_tree", MOUSE_RELEASE_EVENT)
    ide_session_tree.set_select_one()
    users_tab_item.add(ide_session_tree)
    exit_session_btn := TextButton()
    exit_session_btn.set_pos("36", "246")
    exit_session_btn.set_size("45%", "6%")
    exit_session_btn.set_is_shaded()
    exit_session_btn.connect(self, "on_exit_session_btn", ACTION_EVENT)
    exit_session_btn.clear_toggles()
    exit_session_btn.set_label("Exit Session")
    exit_session_btn.set_internal_alignment("c")
    users_tab_item.add(exit_session_btn)
    get_lock_btn := TextButton()
    get_lock_btn.set_pos("37", "273")
    get_lock_btn.set_size("45%", "6%")
    get_lock_btn.set_is_shaded()
    get_lock_btn.connect(self, "on_get_lock_btn", ACTION_EVENT)
    get_lock_btn.clear_toggles()
    get_lock_btn.set_label("Take Turn")
    get_lock_btn.set_internal_alignment("c")
    users_tab_item.add(get_lock_btn)
    files_label := Label()
    files_label.set_pos("2%", "0")
    files_label.set_size(, "4%")
    files_label.set_attribs("font=serif, bold, 12", "bg=very light whitish blue")
    files_label.set_internal_alignment("l")
    files_label.set_label("Session Files")
    users_tab_item.add(files_label)
    pendings_btn := TextButton()
    pendings_btn.set_pos("41", "249")
    pendings_btn.set_size("84", "20")
    pendings_btn.set_is_shaded()
    pendings_btn.connect(self, "on_pendings_btn", ACTION_EVENT)
    pendings_btn.clear_toggles()
    pendings_btn.set_label("Pendings(0)")
    pendings_btn.set_internal_alignment("c")
    users_tab_item.add(pendings_btn)
    activity_mini_tabset := TabSet()
    activity_mini_tabset.set_pos("2", "31%")
    activity_mini_tabset.set_size("100%-4", "68%")
    mini_users_tab := TabItem()
    mini_users_tab.set_label("Users")
    showonline_chkbx := CheckBox()
    showonline_chkbx.set_pos("2", "0")
    showonline_chkbx.set_size("70%", "6%")
    showonline_chkbx.set_draw_border()
    showonline_chkbx.set_attribs("font=serif, bold, 12", "bg=very light whitish blue")
    showonline_chkbx.connect(self, "on_showonline_chkbx", ACTION_EVENT)
    showonline_chkbx.set_toggles()
    showonline_chkbx.set_label("Show Offline friends")
    mini_users_tab.add(showonline_chkbx)
    users_tree := Tree()
    users_tree.set_pos(1, 17)
    users_tree.set_size("100%-2", "100%-18")
    users_tree.set_draw_border()
    users_tree.set_attribs("bg=white")
    users_tree.connect(self, "on_users_tree", MOUSE_RELEASE_EVENT)
    users_tree.set_select_one()
    mini_users_tab.add(users_tree)
    activity_mini_tabset.add(mini_users_tab)
    mini_groups_tab := TabItem()
    mini_groups_tab.set_label("Groups")
    groups_tree := Tree()
    groups_tree.set_pos("1", "1")
    groups_tree.set_size("100%-2", "100%-2")
    groups_tree.set_draw_border()
    groups_tree.set_attribs("bg=white")
    groups_tree.connect(self, "on_groups_tree", MOUSE_RELEASE_EVENT)
    groups_tree.set_select_one()
    mini_groups_tab.add(groups_tree)
    activity_mini_tabset.add(mini_groups_tab)
    mini_projects_tab := TabItem()
    mini_projects_tab.set_label("Projects")
    projects_tree := Tree()
    projects_tree.set_pos("1", "1")
    projects_tree.set_size("100%-2", "100%-2")
    projects_tree.set_draw_border()
    projects_tree.set_attribs("bg=white")
    projects_tree.connect(self, "on_projects_tree", MOUSE_RELEASE_EVENT)
    projects_tree.set_select_one()
    mini_projects_tab.add(projects_tree)
    activity_mini_tabset.add(mini_projects_tab)
    activity_mini_tabset.set_which_one(mini_users_tab)
    users_tab_item.add(activity_mini_tabset)
    ClassTabSet.add(users_tab_item)
    inventory_tab_item := TabItem()
    inventory_tab_item.set_label("Inventory")
    activequestslbl := Label()
    activequestslbl.set_pos(4, 23)
    activequestslbl.set_size("102", "25")
    activequestslbl.set_attribs("bg=whitish blue")
    activequestslbl.set_internal_alignment("l")
    activequestslbl.set_label(" Active Quests")
    inventory_tab_item.add(activequestslbl)
    activequeststl := TextList()
    activequeststl.set_pos("2", "50")
    activequeststl.set_size("100%-4", "145")
    activequeststl.set_draw_border()
    activequeststl.set_attribs("bg=pale blue", "font=serif,bold,15")
    activequeststl.connect(self, "on_activequeststl", ACTION_EVENT)
    activequeststl.connect(self, "on_activequeststl", MOUSE_PRESS_EVENT)
    activequeststl.set_select_one()
    activequeststl.set_contents([""])
    inventory_tab_item.add(activequeststl)
    ClassTabSet.add(inventory_tab_item)
    newsfeed_tab_item := TabItem()
    newsfeed_tab_item.set_label("News Feed")
    newsfeed_tree := Tree()
    newsfeed_tree.set_pos("2", "2")
    newsfeed_tree.set_size("100%-4", "100%-4")
    newsfeed_tree.set_draw_border()
    newsfeed_tree.set_attribs("bg=white")
    newsfeed_tree.connect(self, "on_newsfeed_tree", MOUSE_RELEASE_EVENT)
    newsfeed_tree.set_select_one()
    newsfeed_tab_item.add(newsfeed_tree)
    ClassTabSet.add(newsfeed_tab_item)
    ClassTabSet.set_which_one(users_tab_item)
    browser.add(ClassTabSet)
    self.add(browser)
    x_button := Image()
    x_button.set_pos("22.8%", "75%")
    x_button.set_size("1.1%", "1.45%")
    x_button.set_draw_border()
    x_button.connect(self, "on_press", MOUSE_PRESS_EVENT)
    x_button.connect(self, "on_x", MOUSE_DRAG_EVENT)
    x_button.connect(self, "on_release", MOUSE_RELEASE_EVENT)
    x_button.set_filename("dat/xbtn.gif")
    x_button.set_internal_alignment("c", "c")
    x_button.set_scale_up()
    self.add(x_button)
    image_6 := Image()
    image_6.set_pos("82%", "0")
    image_6.set_size("4.5%", "4.5%")
    image_6.set_align("c", "t")
    image_6.set_attribs("resize=on", "bg=very medium gray")
    image_6.set_filename("dat/images/cve_80.gif")
    image_6.set_internal_alignment("c", "c")
    image_6.set_scale_up()
    self.add(image_6)
    image_2 := Image()
    image_2.set_pos("97%+6", "0")
    image_2.set_size("4.5%", "4.5%")
    image_2.set_align("c", "t")
    image_2.set_attribs("resize=on", "bg=very medium gray")
    image_2.set_filename("dat/nmsulogo.gif")
    image_2.set_internal_alignment("c", "c")
    image_2.set_scale_up()
    self.add(image_2)
    label_3 := Label()
    label_3.set_pos("84.5%", "0")
    label_3.set_size("11%+6", "4.5%")
    label_3.set_attribs("font=serif, bold, italic,12", "fg=very dark red")
    label_3.set_internal_alignment("c")
    label_3.set_label("Computer Science")
    self.add(label_3)
    editarea := Border()
    editarea.set_pos("23%", "4%")
    editarea.set_size("77%", "71%")
    editarea.set_attribs("resize=on")
    editarea.set_internal_alignment("l")
    VCSC_tab := BufferTabSet()
    VCSC_tab.set_pos("1", "1")
    VCSC_tab.set_size("100%-2", "100%-2")
    VCSC_tab.set_attribs("resize=on", "font=serif,17")
    VCSC_tab.connect(self, "on_tab_selection", SELECTION_CHANGED_EVENT)
    view_3d := TabItem()
    view_3d.set_label("Science Hall")
    view_border := Border()
    view_border.set_pos(4, 3)
    view_border.set_size("99%", "99%")
    view_border.set_attribs("resize=on")
    view_border.set_internal_alignment("l")
    Science_Hall_overlay := OverlaySet()
    Science_Hall_overlay.set_pos("4", "4")
    Science_Hall_overlay.set_size("100%-8", "100%-8")
    View_3D_overlay_item := OverlayItem()
    border_14 := Border()
    border_14.set_pos("2", "2")
    border_14.set_size("100%-4", "100%-4")
    border_14.set_internal_alignment("l")
    subwin := Subwindow3D()
    subwin.set_pos(4, 4)
    subwin.set_size("100%-8", "100%-8")
    subwin.set_draw_border()
    subwin.set_attribs("resize=on")
    subwin.connect(self, "on_subwin", ACTION_EVENT)
    subwin.connect(self, "on_br", BUTTON_RELEASE_EVENT)
    subwin.connect(self, "on_mr", MOUSE_RELEASE_EVENT)
    subwin.connect(self, "on_kp", KEY_PRESS_EVENT)
    border_14.add(subwin)
    View_3D_overlay_item.add(border_14)
    Science_Hall_overlay.add(View_3D_overlay_item)
    Science_Hall_overlay.set_which_one(View_3D_overlay_item)
    view_border.add(Science_Hall_overlay)
    view_3d.add(view_border)
    VCSC_tab.add(view_3d)
    view_map := TabItem()
    view_map.set_label("Map")
    image_5 := MapImage()
    image_5.set_pos("2%", "2%")
    image_5.set_size("96%", "96%")
    image_5.set_filename("dat/images/map.gif")
    image_5.set_internal_alignment("c", "c")
    image_5.set_scale_up()
    view_map.add(image_5)
    VCSC_tab.add(view_map)
    VCSC_tab.set_which_one(view_3d)
    editarea.add(VCSC_tab)
    self.add(editarea)

    # Add the notifications icon
    notifications_icn := MenuButton()
    notifications_icn.set_pos("60%", "0")
    notifications_icn.set_size("3%", "4.5%")
    notifications_icn.set_attribs("bg=gray", "fg=white", "font=serif, bold, 12")
    notifications_icn.set_tooltip("Notifications ....")
    notifications_menu_icn := Menu()
    notifications_menu_icn.set_label("0")
    notifications_icn.set_menu(notifications_menu_icn)
    #browse_item_lbl := TextMenuItem()
    #browse_item_lbl.set_label("Browse ...")
    #browse_item_lbl.connect(self, "on_pendings_btn", ACTION_EVENT)
    #notifications_menu_icn.add(browse_item_lbl)
    self.add(notifications_icn)

    # Add the emails icon
    emails_icn := MenuButton()
    emails_icn.set_pos("63%", "0")
    emails_icn.set_size("3%", "4.5%")
    emails_icn.set_attribs("bg=gray", "fg=white", "font=serif, bold, 12")
    emails_icn.set_tooltip("Emails ....")
    emails_menu_icn := Menu()
    emails_menu_icn.set_label("0")
    emails_icn.set_menu(emails_menu_icn)
    emails_item_lbl := TextMenuItem()
    emails_item_lbl.set_label("Inbox ...")
    emails_item_lbl.connect(self, "on_inbox", ACTION_EVENT)
    emails_menu_icn.add(emails_item_lbl)

    self.add(emails_icn)

    projActivityTab_Setup()

    # Add the fps (frames/second) label
    fps_label := Label()
    fps_label.set_pos("68%", "0")
    fps_label.set_size("5%", "4.5%")
    fps_label.set_attribs("font=serif, bold, 12", "fg=very dark red")
    fps_label.set_internal_alignment("c")
    fps_label.set_label("? fps")
    fps_label.set_tooltip("fps")
    self.add(fps_label)

    # Add the network latency label
    latency_label := Label()
    latency_label.set_pos("73%", "0")
    latency_label.set_size("5%", "4.5%")
    latency_label.set_attribs("font=serif, bold, 12", "fg=very dark red")
    latency_label.set_internal_alignment("c")
    latency_label.set_label("?latency")
    latency_label.set_tooltip("latency")
    self.add(latency_label)

    # Add the progress tab
    progress_tabset := TabSet()
    progress_tabset.set_pos("0", "74%")
    progress_tabset.set_size("23%", "26%")
    progress_tabitem := progressTabItem()
    progress_tabitem.set_label("Progress")
    progress_mainwin := TempImage()
    progress_mainwin.set_pos("1", "1")
    progress_mainwin.set_size("100%-5", "100%-2")
    progress_mainwin.set_attribs("resize=on")
    progress_tabitem.add(progress_mainwin)
    progress_tabset.add(progress_tabitem)
    progress_tabset.set_which_one(progress_tabitem)
    self.add(progress_tabset)

    self.connect(self, "on_close", CLOSE_BUTTON_EVENT)
  end

   method activity_tabset_update()
      local i, j, L, L1, firststop, secondstop, thirdstop, fourthstop,
	 firststop2, secondstop2, thirdstop2, active_proj, user_id, 
         color_lbl, name_lbl, k, fname, pname, usr, tlbl, m, pn, un
      local firstlst := [], secondlst := [], thirdlst := [],
	 fourthlst := [],  fifthlst := [], firstlst2 := [], 
         secondlst2 := [], thirdlst2 := [], fourthlst2 := []

      tlbl := (VCSC_tab.get_which_one()).label
      tlbl ? {
         fname := tab(find("(PF):"))
         &pos +:= 5
         pname := tab(0)
         }
      usr := view.user_me
      session.Write("\\memberActivity "||usr||" "||pname||" "||usr)
      session.Write("\\projActivity "||usr||" "||pname||" "||fname)
      session.Write("\\membersColorList "||usr||" "||pname)
      #
      # General Activity
      #
      i := 1
      every L := !projActivitylst do {
	    if find("Currently Working", L) then {
	       firststop := i
	       every j:= 2 to firststop - 2 do {
	          L1 := projActivitylst[j]
	          if L1 ~== "" then {
	             put(firstlst, L1)
	             }
	          }
	       }
	    if find("All File Activities", L) then {
	       secondstop := i
	       every j:= firststop + 1 to secondstop - 1 do {
	          L1 := projActivitylst[j]
	          if L1 ~== "" then
	             put(secondlst, projActivitylst[j])
	          }
	       }
	    if find("Most Active Member :", L) then {
	       thirdstop := i
	       every j:= secondstop + 1 to thirdstop - 1 do {
	          L1 := projActivitylst[j]
	          if L1 ~== "" then
	             put(thirdlst, projActivitylst[j])
	          }
	       }
	    if find("Other Info", L) then {
	       fourthstop := i
	       every j:= thirdstop + 1 to fourthstop - 1 do {
	          L1 := projActivitylst[j]
	          if L1 ~== "" then
	             put(fourthlst, projActivitylst[j])
	          }
	       }
	    i +:= 1
	 }
      #
      # Adding the member(s) info.
      #
      put(fifthlst, "Member(s) Info.:")
      put(fifthlst, "User\t\tColor")
      put(fifthlst, "----\t\t-----")      
      every m := key(membersColorTable) do {
         m ? {
            pn := tab(find(":"))
            move(1)
            un := tab(0)
            }
         put(fifthlst, un||"\t\t"||membersColorTable[m])
         }
      put(fifthlst, "----------------------------------")

      if \fourthstop then
      every j:= fourthstop + 1 to *projActivitylst do {
	 L1 := projActivitylst[j]
	 if L1 ~== "" then
	   put(fifthlst, projActivitylst[j])
	 }
      #
      # Member Activity
      #
      i := 1
      every L := !memberActivitylst do {
	    if find("Files Changed", L) then {
	       firststop2 := i
	       every j:= 1 to firststop2 - 1 do {
	          L1 := memberActivitylst[j]
	          if L1 ~== "" then
	             put(firstlst2, memberActivitylst[j])
	          }
	       }
	    if find("Currently Working On", L) then {
	       secondstop2 := i
	       every j:= firststop2 + 1 to secondstop2 - 1 do {
	          L1 := memberActivitylst[j]
	          if L1 ~== "" then
	             put(secondlst2, memberActivitylst[j])
	          }
	       }
	    if find("Other Info", L) then {
	       thirdstop2 := i
	       every j:= secondstop2 + 1 to thirdstop2 - 1 do {
	          L1 := memberActivitylst[j]
	          if L1 ~== "" then
	             put(thirdlst2, memberActivitylst[j])
	          }
	       }
	    i +:= 1
	 }
      if \thirdstop2 then
      every j:= thirdstop2 + 1 to *memberActivitylst do {
	 L1 := memberActivitylst[j]
	 if L1 ~== "" then
	   put(fourthlst2, memberActivitylst[j])
	 }

      general_info_txtlst.set_contents(firstlst)
      currentlyworking_txtlst.set_contents(secondlst)
      all_activities_txtlst.set_contents(thirdlst)
      mostactive_txtlst.set_contents(fourthlst)
      otherinfo_txtlst.set_contents(fifthlst)

      general_info2_txtlst.set_contents(firstlst2)
      fileschanged_txtlst.set_contents(secondlst2)
      currentlyworking2_txtlst.set_contents(thirdlst2)
      otherinfo2_txtlst.set_contents(fourthlst2)
   end

   method projActivityTab_Setup()
      local activity_border, update_btn, label_0, 
         label_1, label_2, label_3, label_4, label_5, 
         label_6, label_7, label_8, label_9, label_10

      activity_tabset := TabSet()
      activity_tabset.set_pos("2", "2")
      activity_tabset.set_size("1", "1")
      activity_tabset.set_attribs("resize=on")
      activity_tabset.connect(self, "on_activity_tabset", SELECTION_CHANGED_EVENT)

      general_tab := TabItem()
      general_tab.set_label("General Activity")
      activity_border := Border()
      activity_border.set_pos("1", "1")
      activity_border.set_size("100%-2", "100%-2")
      activity_border.set_attribs("resize=on")
      activity_border.set_internal_alignment("l")

      label_0 := Label()
      label_0.set_pos("2", "2")
      label_0.set_size("50%-4", "5%")
      label_0.set_attribs("resize=on")
      label_0.set_attribs("bg=pale gray")
      label_0.set_internal_alignment("l")
      label_0.set_label("General Info:")
      activity_border.add(label_0)
      general_info_txtlst := TextList()
      general_info_txtlst.set_pos("2", "5%+2")
      general_info_txtlst.set_size("100%-4", "15%")
      general_info_txtlst.set_attribs("resize=on", "bg=white", "font=serif, 13")
      general_info_txtlst.set_contents([""])
      activity_border.add(general_info_txtlst)

      label_1 := Label()
      label_1.set_pos("2", "20%+2")
      label_1.set_size("100%-4", "5%")
      label_1.set_attribs("bg=pale gray", "resize=on")
      label_1.set_internal_alignment("l")
      label_1.set_label("Currently Working:")
      activity_border.add(label_1)
      currentlyworking_txtlst := TextList()
      currentlyworking_txtlst.set_pos("2", "25%+2")
      currentlyworking_txtlst.set_size("100%-4", "15%")
      currentlyworking_txtlst.set_attribs("resize=on", "bg=white", "font=serif, 13")
      currentlyworking_txtlst.set_contents([""])
      activity_border.add(currentlyworking_txtlst)


      label_2 := Label()
      label_2.set_pos("2", "40%+2")
      label_2.set_size("100%-4", "5%")
      label_2.set_attribs("bg=pale gray")
      label_2.set_internal_alignment("l")
      label_2.set_label("All File Activities:")
      activity_border.add(label_2)
      all_activities_txtlst := TextList()
      all_activities_txtlst.set_pos("2", "45%+2")
      all_activities_txtlst.set_size("100%-4", "15%")
      all_activities_txtlst.set_attribs("resize=on", "bg=white", "font=serif, 13")
      all_activities_txtlst.set_contents([""])
      activity_border.add(all_activities_txtlst)

      label_3 := Label()
      label_3.set_pos("2", "60%+2")
      label_3.set_size("100%-4", "5%")
      label_3.set_attribs("resize=on", "bg=pale gray")
      label_3.set_internal_alignment("l")
      label_3.set_label("Most Active Member:")
      activity_border.add(label_3)
      mostactive_txtlst := TextList()
      mostactive_txtlst.set_pos("2", "65%+2")
      mostactive_txtlst.set_size("100%-4", "15%")
      mostactive_txtlst.set_attribs("resize=on", "bg=white", "font=serif, 13")
      mostactive_txtlst.set_contents([""])
      activity_border.add(mostactive_txtlst)

      label_4 := Label()
      label_4.set_pos("2", "80%+2")
      label_4.set_size("100%-4", "5%")
      label_4.set_attribs("resize=on", "bg=pale gray")
      label_4.set_internal_alignment("l")
      label_4.set_label("Other Info:")
      activity_border.add(label_4)
      otherinfo_txtlst := TextList()
      otherinfo_txtlst.set_pos("2", "85%+2")
      otherinfo_txtlst.set_size("100%-4", "15%-2")
      otherinfo_txtlst.set_attribs("resize=on", "bg=white", "font=serif, 13")
      otherinfo_txtlst.set_contents([""])
      activity_border.add(otherinfo_txtlst)
 
      update_btn := TextButton()
      update_btn.set_pos("50%", "2")
      update_btn.set_size("50%-4", "5%")
      update_btn.connect(self, "activity_tabset_update", ACTION_EVENT)
      update_btn.clear_toggles()
      update_btn.set_label("Update")
      update_btn.set_attribs("font=serif, 12", "bg=light yellow")
      update_btn.set_internal_alignment("c")
      activity_border.add(update_btn)

      general_tab.add(activity_border)
      activity_tabset.add(general_tab)
      member_tab := TabItem()
      member_tab.set_label("Members Activity")

      activity_border2 := Border()
      activity_border2.set_pos("1", "1")
      activity_border2.set_size("100%-2", "100%-2")
      activity_border2.set_attribs("resize=on")
      activity_border2.set_internal_alignment("l")

      label_5 := Label()
      label_5.set_pos("4", "4")
      label_5.set_size("100%-8", "5%")
      label_5.set_attribs("resize=on")
      label_5.set_internal_alignment("l")
      label_5.set_label("Members Changed The File:")
      activity_border2.add(label_5)

      proj_members_lst := List()
      proj_members_lst.set_pos("4", "5%+8")
      proj_members_lst.set_size("100%-8", "5%")
      proj_members_lst.set_attribs("resize=on")
      proj_members_lst.connect(self, "on_proj_members_lst", SELECTION_CHANGED_EVENT)
      proj_members_lst.set_selection_list([""])
      activity_border2.add(proj_members_lst)

      label_7 := Label()
      label_7.set_pos("2", "12%")
      label_7.set_size("100%-4", "5%")
      label_7.set_attribs("resize=on", "bg=pale gray")
      label_7.set_internal_alignment("l")
      label_7.set_label("General Info:")
      activity_border2.add(label_7)
      general_info2_txtlst := TextList()
      general_info2_txtlst.set_pos("2", "17%")
      general_info2_txtlst.set_size("100%-4", "15%")
      general_info2_txtlst.set_attribs("resize=on", "bg=white", "font=serif, 13")
      general_info2_txtlst.set_contents([""])
      activity_border2.add(general_info2_txtlst)

      label_8 := Label()
      label_8.set_pos("2", "32%")
      label_8.set_size("100%-4", "5%")
      label_8.set_attribs("resize=on", "bg=pale gray")
      label_8.set_internal_alignment("l")
      label_8.set_label("Files Changed:")
      activity_border2.add(label_8)
      fileschanged_txtlst := TextList()
      fileschanged_txtlst.set_pos("2", "37%")
      fileschanged_txtlst.set_size("100%-4", "15%")
      fileschanged_txtlst.set_attribs("resize=on", "bg=white", "font=serif, 13")
      fileschanged_txtlst.set_contents([""])
      activity_border2.add(fileschanged_txtlst)


      label_9 := Label()
      label_9.set_pos("2", "52%")
      label_9.set_size("100%-4", "5%")
      label_9.set_attribs("resize=on", "bg=pale gray")
      label_9.set_internal_alignment("l")
      label_9.set_label("Currently Working:")
      activity_border2.add(label_9)
      currentlyworking2_txtlst := TextList()
      currentlyworking2_txtlst.set_pos("2", "57%")
      currentlyworking2_txtlst.set_size("100%-4", "15%")
      currentlyworking2_txtlst.set_attribs("resize=on", "bg=white", "font=serif, 13")
      currentlyworking2_txtlst.set_contents([""])
      activity_border2.add(currentlyworking2_txtlst)

      label_10 := Label()
      label_10.set_pos("2", "72%")
      label_10.set_size("100%-4", "5%")
      label_10.set_attribs("resize=on", "bg=pale gray")
      label_10.set_internal_alignment("l")
      label_10.set_label("Other Info:")
      activity_border2.add(label_10)
      otherinfo2_txtlst := TextList()
      otherinfo2_txtlst.set_pos("2", "77%+2")
      otherinfo2_txtlst.set_size("100%-4", "15%")
      otherinfo2_txtlst.set_attribs("resize=on", "bg=white", "font=serif, 13")
      otherinfo2_txtlst.set_contents([""])
      activity_border2.add(otherinfo2_txtlst)

      member_tab.add(activity_border2)

      activity_tabset.add(member_tab)
      activity_tabset.set_which_one(general_tab)
      editarea.add(activity_tabset)
      #activity_tabset.set_is_shaded()
   end

   method on_proj_members_lst()
      local userID
      userID := proj_members_lst.selection_list[proj_members_lst.get_selection()]
      activity_border2.set_attribs("bg="||
         membersColorTable[active_projName||":"||userID])
   end

   method on_activity_tabset()
      #if (activity_tabset.get_which_one()).label === "Members Activity" then {
      #   proj_members_lst.set_selection_list(members_accessed_file)
      #   }
   end

initially
   self.Dialog.initially()
   user_me := "guest"
   cmds := Commands()
   uide:=IDE(view_3d)
   #CProjEditor   :=CProjEditor()
   newCppProject :=CProject()
   newJavaProject:=JProject()
   newUProject   :=UProject()
   projMenu:=ProjectMenubar(newJavaProject, newCppProject, newUProject)
   ici_groups := ICIGroups()
   ici_profile := Profile()
   ici_pendings := PendingsDlg()
   ici_notifications :=NotificationsDlg()
   fwrddlg := ForwardDlg()
   voipdlg := VoIPDlg()

   ici_newsfeed := ICINewsFeed()
   projectdlg := Projects()
   pendings_tbl := table("")
   sdprojfilesSet := set("")
   projActivitylst := [""]
   memberActivitylst := [""]
   projMembersSet := set()
   updatedsdfilelines := table("")
   updatedsdfile_lines_events := table("")
   membersColorTable := table("")
   changed_file_line_Table := table("")
   line_color_table := table("")
   member_proj_set   := set("")
   mypartnersslst := set()

   cwfiles_set := set()
   accessedfiles_set := set()
   addedfiles_set := set()

   Voice := VoIP()
   / (world.cam) := Camera()
   world.cam.reset()
   #teleport_home()
   flag :=0
   tablist:=[MODEL_NAME]
   idesession:=IDESession()
   idesession.dialog := self
   ide := IDE()
   mynsh := self
   selected_group := ""
   selected_user  := ""
   myide_sessions := 0
end

$ifndef NSH
   procedure main()
      local d
      world := World()
      #
      # overwrite the system dispatcher with one that knows about subwindows
      #
      gui::dispatcher := N3Dispatcher()
      d := NSHDialog()
      d.show_modal()
   end
$endif

class progressTabItem : TabItem()

   method display()
      local pane
      self.TabItem.display()
      if /mainprog_win then fail

      pane := CopyArea(win2d, progress_mainwin.cbwin,,,,,
         progress_mainwin.x, progress_mainwin.y)
      Clip(pane, progress_mainwin.x, progress_mainwin.y, 
         progress_mainwin.w, progress_mainwin.h)
   end
end

global world

#CONTROLS:
#up arrow - move foward
#down arrow - move backward
#left arrow - rotate camera left
#right arrow - rotate camera right
# ' w ' key - look up
# ' s ' key - look down
# ' d ' key - toggle door open/closed

#GLOBAL variables
global xdelta, ydelta, lookdelta

global Rooms

   #
   # This method will not simply render everthing... we would make it more 
   # intelligent by passing it the room and avatar list that would render it 
   # only if they are not automatically rendered
   #
   procedure please(d,TroomsToBeRendered, TavatarsToBeRendered)
      local r, nodeName, node, avatarName, avat, dist, render_dist
      local xroom, yroom, zroom, xx, y, z

      &window := d
      WAttrib("texmode=on")
      WAttrib("pick=on")
      #
      # First do derendering
      #
      cltSceneGraph.deRenderNodes(world.curr_room.name,
                                  TroomsToBeRendered,TavatarsToBeRendered)

      if chat_filter_flag =="low" then world.write_chat("Rendering...")

      # render graphics
      #
      # This call will only render unrendered rooms as each room has
      # an internal check whether it is rendered. Mind well this is to
      # be done only for static objects. For dynamic objects we need
      # additional check whether the object has changed state.
      #

      avat := world.cam.avatar  

      xx := avat.X
      y := avat.Y
      world.cam.y := y + 1.5
      z := avat.Z
      every node := !TroomsToBeRendered do {
	 if chat_filter_flag =="low" then world.write_chat("   ", node.name)
         xroom := node.x       #xroom := (node.x + node.l) / 2
         zroom := node.z       #zroom := (node.z + node.w) / 2
         yroom := node.y
         dist := find_distance(xx,y,z,xroom,yroom,zroom)
         render_dist := 10
         if dist <= render_dist then {
            # maximum render_level
            if \maxtime > 200 then node.render_level := 1
            else if \maxtime > 100 then node.render_level := 2
            else node.render_level := 3
            }
         else
            if dist > render_dist & dist <= (render_dist + 10) then {
               if \maxtime > 150 then node.render_level := 1
               node.render_level := 2
               }
         else
            if dist > (render_dist + 10) & dist <= (render_dist + 20) then
               node.render_level := 1
         else
            if dist > (render_dist + 20) then
               node.render_level := 0 
         if node.name == world.curr_room.name then {
            world.curr_room.render_level := 3 
            }
         node.render(world)
         #write("render_level: ", node.render_level)
         }

      if chat_filter_flag =="low" then world.write_chat("Active Node Count: ",
                       cltSceneGraph.printRenderedNodes(2))
      #
      # Here the server may send the avatars that may not be logged in and/or 
      # may send a subset of avatars that are logged in. The user always have 
      # the set of avatars that are logged in but they are selectively rendered
      # according to the graph model
      #
      #every (\world.TAvatars[key(TavatarsToBeRendered)]).render()
      every avatarName := key(TavatarsToBeRendered) do {
         if (avatarName ~== world.userId) then {
            (\world.TAvatars[avatarName]).render()
            }
         }
#      gui::dispatcher.cam_move(0.01)

      # ready for event processing loop
   end

   procedure find_distance(x1,y1,z1,x2,y2,z2)
      local x,y,z,dist
      x := (x2 - x1) * (x2 - x1)
      y := (y2 - y1) * (y2 - y1)
      z := (z2 - z1) * (z2 - z1)
      dist := sqrt(x + y + z) 
      return dist
   end

   #
   # main initialization procedure
   #
   procedure ui_initialize()
      local f, line, b, font
      ui_ini := getenv("UNICONINI") | "ui.ini"
      height := 400
      width := 600
      msglines := 7
      font := "sans,15"
      linebreak := "LF"                      # default to UNIX mode
      if f := open(ui_ini) then {
      while line := read(f) do {
         line ? {
            if ="msglines" then {
               tab(upto(&digits))
               msglines := integer(tab(many(&digits)))
               }
            else if ="height" then {
               tab(upto(&digits))
               height := integer(tab(many(&digits)))
               }
            else if ="width" then {
               tab(upto(&digits))
               width := integer(tab(many(&digits)))
               }
            else if ="font" then {
               tab(many('= \t'))
               font := tab(0)
               }
            else if ="linebreak" then {
               tab(many('= \t'))
               linebreak := tab(0)
               }
            }
         }
         close(f)
         }
      wiconlog := tempname("ui",,(getenv("TEMP") | "/tmp"),5)
      if not setenv("WICONLOG", wiconlog) then 
         write("can't set WICONLOG")
      xargs := ""

$ifdef _UNIX
      browser := &null
      if stat(getpaths() || (b := (getenv("BROWSER") | "netscape" | "mozilla"|
			"firefox" | "google-chrome" | "opera" | "open"))) then {
	 browser := b
	 }
$else
      (browser := "\"" || WinAssociate("HTM") || "\"" ) |
      write(
      "What, no browser?  Unicon's online help won't be readable until you\n_
       associate an HTML reader application with the HTM file extension.\n")
$endif
   end
   #
   # newer(): is t1 newer than t2?
   #
   procedure newer(s1, s2)
      local t1, t2
      t1 := stat(s1).mtime | fail
      t2 := stat(s2).mtime | fail
      return t1 - t2 > 0 # or something like that
   end
   #
   #
   #
   procedure FileTransfer() 
      local portnum,ser,fn,flen,chunk,handle,handle1,sendto,
            buffer,i,j,remainder
      #ser := args[1] 
      #portnum := args[2] 
      ser := "unicon.cs.nmsu.edu"
      portnum := 8900
      fn      :=tab_label 
      flen :=stat(fn).size
      handle := "<" || fn || ">" || flen || "?"  | 
                write("problem in reading file and length ")
      #sending filename and filelength #
      sendto := connectTo(ser, portnum) | fail 
      writes(sendto, handle)  | 
         write("unable to send file nameand file length")
      close(sendto)

      delay(2000)
      handle1 := open(fn,"ru") | write("failed to open the file") 

      buffer :=reads(handle1,flen)
      close(handle1)
      #sending acutal contents #
      i := 0
      j := chunk := 1024*6
      if flen/chunk == 0 then {
         j := chunk := flen
         }
      else {
         remainder := flen % chunk
         write("the remainder is :" || remainder )
         }

      sendto := connectTo(ser, portnum) | fail 
     while j <= flen   do {
        #select(sendto,5) 
        delay(3)
        writes(sendto, buffer[i+1:j+1])  | 
           write("unable to send file contents")
        i +:= chunk
        if i >= flen then 
           break
        j +:= chunk
        if j>flen then 
           j := j-chunk + remainder
        }
      #sendto := connectTo(ser, portnum) | fail 
      #writes(sendto,buffer)
      close(sendto)
   end

   procedure connectTo(sernm, pnum)
      return open( sernm || ":" || pnum, "n" )
   end

procedure CheckIncludes(name, location)
   local filename, readline
   filename := open(location, "r")
   while readline := read(filename) do {
      if find("/"||name||".dat", readline) then {
         close(filename)
         fail
      }
   }
   close(filename)
   return
end

procedure CreateRoomProc(userarglist)
      local tmproom
      tmproom := Room(WcveBuilder.opMode, WcveBuilder.world, WcveBuilder.dispatcher, 
                      userarglist[1], userarglist[2], userarglist[3], userarglist[4], 
                      userarglist[5], userarglist[6], userarglist[7], userarglist[8])
      tmproom.make_default_left_wall(userarglist[8])
      tmproom.make_default_right_wall(userarglist[8])
      tmproom.make_default_front_wall(userarglist[8])
      tmproom.make_default_back_wall(userarglist[8])
      /tmproom.actors := []
      #WcveBuilder.sceneGraph.putRoomInWorld(tmproom)
      WcveBuilder.sceneGraph.nodesTable[userarglist[1]] := tmproom
end

procedure SaveRoomProc(userargs, trt, input_line)
         local includeListDat, fone, ftwo, tempWall, tempWallz, tot, tmpWord
         includeListDat:= 0
         if CheckIncludes(userargs, DAT || PS || "roomdat" || PS || "roomlist.dat") then {
            fone := open(DAT || PS || "roomdat" || PS || "roomlist.dat", "a")
            write(fone, "include roomdat" || PS || trt.name || ".dat")
            close(fone)
            includeListDat := 1
         }
         ftwo := open(DAT || PS || "roomdat" || PS || trt.name || ".dat", "w")
         write(ftwo, "Room {")
         write(ftwo, "\tname  ", trt.name)
         write(ftwo, "\tx ", trt.x) 
         write(ftwo, "\ty ", trt.y) 
         write(ftwo, "\tz ", trt.z) 
         write(ftwo, "\tw ", trt.w) 
         write(ftwo, "\th ", trt.h) 
         write(ftwo, "\tl ", trt.l) 
         write(ftwo, "\ttexture ", trt.walls[1].texture)
         every tempWall := !trt.walls do {
            if find("Tiled", type(tempWall)) then {
               if (tempWall.plane = 1) & (tempWall.coords[1] = trt.x) then write(ftwo, "\tleft_wall_tiled [")
               if (tempWall.plane = 1) & (tempWall.coords[1] ~= trt.x) then write(ftwo, "\tright_wall_tiled [")
               if (tempWall.plane = 3) & (tempWall.coords[3] = trt.z) then write(ftwo, "\tback_wall_tiled [")
               if (tempWall.plane = 3) & (tempWall.coords[3] ~= trt.z) then write(ftwo, "\tfront_wall_tiled [")
               every tempWallz := !tempWall.walls do {
                  write(ftwo, "\t\tWall {")
                  write(ftwo, "\t\t\ttexture ", tempWallz.texture)
                  write(ftwo, "\t\t\tcoords [")
                  write(ftwo, "\t\t\t\t", tempWallz.coords[1], ", ", tempWallz.coords[2], ", ", tempWallz.coords[3], ",")
                  write(ftwo, "\t\t\t\t", tempWallz.coords[4], ", ", tempWallz.coords[5], ", ", tempWallz.coords[6], ",")
                  write(ftwo, "\t\t\t\t", tempWallz.coords[7], ", ", tempWallz.coords[8], ", ", tempWallz.coords[9], ",")
                  write(ftwo, "\t\t\t\t", tempWallz.coords[10], ", ", tempWallz.coords[11], ", ", tempWallz.coords[12])
                  write(ftwo, "\t\t\t]")
                  write(ftwo, "\t\t}")
               }
               write(ftwo, "\t]")
            }
         }
         if find("Tiled", type(trt.floor)) then {
            write(ftwo, "\tfloor_tiled [")
            every tempWall := !trt.floor.walls do {
               write(ftwo, "\t\tWall {")
               write(ftwo, "\t\t\ttexture ", tempWall.texture)
               write(ftwo, "\t\t\tcoords [")
               write(ftwo, "\t\t\t\t", tempWall.coords[1], ", ", tempWall.coords[2], ", ", tempWall.coords[3], ",")
               write(ftwo, "\t\t\t\t", tempWall.coords[4], ", ", tempWall.coords[5], ", ", tempWall.coords[6], ",")
               write(ftwo, "\t\t\t\t", tempWall.coords[7], ", ", tempWall.coords[8], ", ", tempWall.coords[9], ",")
               write(ftwo, "\t\t\t\t", tempWall.coords[10], ", ", tempWall.coords[11], ", ", tempWall.coords[12])
               write(ftwo, "\t\t\t]")
               write(ftwo, "\t\t}")
            }
            write(ftwo, "\t]")
         }
         else write(ftwo, "\tfloor Wall { texture ", trt.floor.texture, " }")
         if find("Tiled", type(trt.ceiling)) then {
            write(ftwo, "\tceiling_tiled [")
            every tempWall := !trt.ceiling.walls do {
               write(ftwo, "\t\tWall {")
               write(ftwo, "\t\t\ttexture ", tempWall.texture)
               write(ftwo, "\t\t\tcoords [")
               write(ftwo, "\t\t\t\t", tempWall.coords[1], ", ", tempWall.coords[2], ", ", tempWall.coords[3], ",")
               write(ftwo, "\t\t\t\t", tempWall.coords[4], ", ", tempWall.coords[5], ", ", tempWall.coords[6], ",")
               write(ftwo, "\t\t\t\t", tempWall.coords[7], ", ", tempWall.coords[8], ", ", tempWall.coords[9], ",")
               write(ftwo, "\t\t\t\t", tempWall.coords[10], ", ", tempWall.coords[11], ", ", tempWall.coords[12])
               write(ftwo, "\t\t\t]")
               write(ftwo, "\t\t}")
            }
            write(ftwo, "\t]")
         }
         else write(ftwo, "\tceiling Wall { texture ", trt.ceiling.texture, " }")
         write(ftwo, "\tobstacles [")
         every tot := !trt.obstacles do {
            ConvertTwo(tot, ftwo)
         }
         write(ftwo, "\t]")
         write(ftwo, "\tdecorations [")
         every tot := !trt.decorations do {
            ConvertTwo(tot, ftwo)
         }
         write(ftwo, "\t]")
         write(ftwo, "\ttools [")
         every tot := !trt.tools do {
            ConvertTwo(tot, ftwo)
         }
         write(ftwo, "\t]")
         write(ftwo, "}")
         close(ftwo)
         ftwo := open(DAT || PS || "roomdat" || PS || trt.name || ".dat", "r")
         userargs := trt.name||"&"||includeListDat
         while tmpWord := read(ftwo) do
            userargs ||:= tmpWord || "@"
         userargs := map(userargs, "\t", "#")
         userargs := map(userargs, " ", "~")
         close(ftwo)
         input_line := "\\saveroom " || userargs
         world.moodle.chatline_to_server(input_line)
end

procedure SaveOpeningProc(userarglist)
   local tmpthing, ftwo, fone, tempth
   every tmpthing := !WcveBuilder.sceneGraph.edgesTable do 
      if tmpthing.id = userarglist[1] then break
   if tmpthing.id ~= userarglist[1] then return
   ftwo := open(DAT || PS || "edgedat" || PS || tmpthing.id || ".dat", "w")
   if CheckIncludes(userarglist[1], DAT || PS || "edgedat" || PS || "edgelist.dat") then {
      fone := open(DAT || PS || "edgedat" || PS || "edgelist.dat", "a")
      write(fone, "include edgedat" || PS || tmpthing.id || ".dat")
      close(fone)
   }
   if find("Door", type(tmpthing)) then write(ftwo, "Door {")
   else write(ftwo, "Opening {")
   write(ftwo, "\tid ", tmpthing.id)
   write(ftwo, "\tx ", tmpthing.x)
   write(ftwo, "\ty ", tmpthing.y)
   write(ftwo, "\tz ", tmpthing.z)
   write(ftwo, "\tw ", tmpthing.width)
   if find("Door", type(tmpthing)) & (tempth := Texture(\tmpthing.texturec)) then 
      write(ftwo, "\ttexture " || tmpthing.texturec)
   write(ftwo, "\theight ", tmpthing.height)
   write(ftwo, "\tcollide_in ", tmpthing.collide)
   write(ftwo, "\tplane ", tmpthing.plane)
   write(ftwo, "\trooms [", tmpthing.rooms[1].name, ", ", tmpthing.rooms[2].name, "]")
   write(ftwo, "}")
   close(ftwo)
end

procedure AddOpeningProc(userarglist)
   local tId, clear, temp, tOpen, tName
      every tId := 1 to 1000 do {
         clear := 0
         every temp := !WcveBuilder.sceneGraph.edgesTable do 
            if tId = temp.id then clear := 1
         if clear = 0 then break
      }
      tOpen := Opening(WcveBuilder.opMode, userarglist[1], userarglist[2], userarglist[3],
                       userarglist[4], userarglist[5])
      tOpen.height := userarglist[6]
      tOpen.plane := userarglist[7]
      tOpen.id := tId
      WcveBuilder.sceneGraph.nodesTable[userarglist[8]].render()
      WcveBuilder.sceneGraph.nodesTable[userarglist[8]].add_opening(tOpen, 1)
      WcveBuilder.sceneGraph.nodesTable[userarglist[9]].render()
      WcveBuilder.sceneGraph.nodesTable[userarglist[9]].add_opening(tOpen, 1)
      temp := WcveBuilder.sceneGraph.nodesTable[userarglist[8]]
      temp.UpdateRenderedNode()
      temp := WcveBuilder.sceneGraph.nodesTable[userarglist[9]]
      temp.UpdateRenderedNode()
      tName := WcveBuilder.sceneGraph.createEdgeName(tOpen)
      WcveBuilder.sceneGraph.edgesTable[tName] :=  tOpen
      return tId
end

#userarglist is the list or parsed arguments with 1 beign the room name, 2 being the part that is to be 
#editied, 3 (4, and 5) being the amount the room is to be changed.
#temp is the name for the room that is being edited.

procedure EditRoomProc(userarglist)
      local tempWall, temp, i
      temp := WcveBuilder.sceneGraph.nodesTable[userarglist[1]]
      if /temp then return 
      case userarglist[2] of {
         "ceiling": {
             temp.ceiling.coords[2] +:= userarglist[3]
             temp.ceiling.coords[5] +:= userarglist[3]
             temp.ceiling.coords[8] +:= userarglist[3]
             temp.ceiling.coords[11] +:= userarglist[3]
             temp.h +:= userarglist[3]
             every tempWall := !temp.walls do
             {
                tempWall.coords[5] +:= userarglist[3]
                tempWall.coords[8] +:= userarglist[3]
             }
             temp.UpdateRenderedNode()
          }
         "floor": {
             temp.floor.coords[2] +:= userarglist[3]
             temp.floor.coords[5] +:= userarglist[3]
             temp.floor.coords[8] +:= userarglist[3]
             temp.floor.coords[11] +:= userarglist[3]
             temp.h +:= userarglist[3]
             temp.y +:= userarglist[3]
             every tempWall := !temp.walls do
             {
                tempWall.coords[2] +:= userarglist[3]
                tempWall.coords[11] +:= userarglist[3]
             }
             temp.UpdateRenderedNode()
          }
         "nWall": {
             temp.floor.coords[3] -:= userarglist[3]
             temp.floor.coords[12] -:= userarglist[3]
             temp.ceiling.coords[3] -:= userarglist[3]
             temp.ceiling.coords[12] -:= userarglist[3]
             every tempWall := !temp.walls do
             {
                if (tempWall.coords[3] = tempWall.coords[6] = tempWall.coords[9] = tempWall.coords[12] = temp.z) then
                {
                   tempWall.coords[3] -:= userarglist[3]
                   tempWall.coords[6] -:= userarglist[3]
                   tempWall.coords[9] -:= userarglist[3]
                   tempWall.coords[12] -:= userarglist[3]
                }
                else if (tempWall.coords[1] = tempWall.coords[4] = tempWall.coords[7] = tempWall.coords[10] = temp.x) then
                {
                   tempWall.coords[3] -:= userarglist[3]
                   tempWall.coords[6] -:= userarglist[3]
                }
                else if(tempWall.coords[1] = tempWall.coords[4] = tempWall.coords[7] = tempWall.coords[10] = (temp.x + temp.w)) then
                {
                   tempWall.coords[3] -:= userarglist[3]
                   tempWall.coords[6] -:= userarglist[3]
                }
             }
             temp.l +:= userarglist[3]
             temp.z -:= userarglist[3]
             temp.UpdateRenderedNode()
          }
         "sWall": {
             temp.floor.coords[6] +:= userarglist[3]
             temp.floor.coords[9] +:= userarglist[3]
             temp.ceiling.coords[6] +:= userarglist[3]
             temp.ceiling.coords[9] +:= userarglist[3]
             every tempWall := !temp.walls do
             {
                if (tempWall.coords[3] = tempWall.coords[6] = tempWall.coords[9] = tempWall.coords[12] = (temp.l + temp.z)) then
                {
                   tempWall.coords[3] +:= userarglist[3]
                   tempWall.coords[6] +:= userarglist[3]
                   tempWall.coords[9] +:= userarglist[3]
                   tempWall.coords[12] +:= userarglist[3]
                }
                else if (tempWall.coords[1] = tempWall.coords[4] = tempWall.coords[7] = tempWall.coords[10] = temp.x) then
                {
                   tempWall.coords[9] +:= userarglist[3]
                   tempWall.coords[12] +:= userarglist[3]
                }
                else if (tempWall.coords[1] = tempWall.coords[4] = tempWall.coords[7] = tempWall.coords[10] = (temp.w + temp.x)) then
                {
                   tempWall.coords[9] +:= userarglist[3]
                   tempWall.coords[12] +:= userarglist[3]
                }
             }
             temp.l +:= userarglist[3]
             temp.UpdateRenderedNode()
          }
         "wWall": {
             temp.floor.coords[1] -:= userarglist[3]
             temp.floor.coords[4] -:= userarglist[3]
             temp.ceiling.coords[1] -:= userarglist[3]
             temp.ceiling.coords[4] -:= userarglist[3]
             every tempWall := !temp.walls do
             {
                if (tempWall.coords[1] = tempWall.coords[4] = tempWall.coords[7] = tempWall.coords[10] = temp.x) then
                {
                   tempWall.coords[1] -:= userarglist[3]
                   tempWall.coords[4] -:= userarglist[3]
                   tempWall.coords[7] -:= userarglist[3]
                   tempWall.coords[10] -:= userarglist[3]
                }
                else if (tempWall.coords[3] = tempWall.coords[6] = tempWall.coords[9] = tempWall.coords[12] = temp.z) then
                {
                   tempWall.coords[1] -:= userarglist[3]
                   tempWall.coords[4] -:= userarglist[3]
                }
                else if (tempWall.coords[3] = tempWall.coords[6] = tempWall.coords[9] = tempWall.coords[12] = (temp.l + temp.z)) then
                {
                   tempWall.coords[1] -:= userarglist[3]
                   tempWall.coords[4] -:= userarglist[3]
                }
             }
             temp.w +:= userarglist[3]
             temp.x -:= userarglist[3]
             temp.UpdateRenderedNode()
          }
         "eWall": {
             temp.floor.coords[7] +:= userarglist[3]
             temp.floor.coords[10] +:= userarglist[3]
             temp.ceiling.coords[7] +:= userarglist[3]
             temp.ceiling.coords[10] +:= userarglist[3]
             every tempWall := !temp.walls do
             {
                if (tempWall.coords[1] = tempWall.coords[4] = tempWall.coords[7] = tempWall.coords[10] = (temp.x + temp.w)) then
                {
                   tempWall.coords[1] +:= userarglist[3]
                   tempWall.coords[4] +:= userarglist[3]
                   tempWall.coords[7] +:= userarglist[3]
                   tempWall.coords[10] +:= userarglist[3]
                }
                else if (tempWall.coords[3] = tempWall.coords[6] = tempWall.coords[9] = tempWall.coords[12] = temp.z) then
                {
                   tempWall.coords[7] +:= userarglist[3]
                   tempWall.coords[10] +:= userarglist[3]
                }
                else if (tempWall.coords[3] = tempWall.coords[6] = tempWall.coords[9] = tempWall.coords[12] = (temp.l + temp.z)) then
                {
                   tempWall.coords[7] +:= userarglist[3]
                   tempWall.coords[10] +:= userarglist[3]
                }
             }
             temp.w +:= userarglist[3]
             temp.UpdateRenderedNode()
         }
         "moveRoom":{
            temp.floor.coords[1] +:= userarglist[3]
            temp.floor.coords[2] +:= userarglist[4]
            temp.floor.coords[3] +:= userarglist[5]
            temp.floor.coords[4] +:= userarglist[3]
            temp.floor.coords[5] +:= userarglist[4]
            temp.floor.coords[6] +:= userarglist[5]
            temp.floor.coords[7] +:= userarglist[3]
            temp.floor.coords[8] +:= userarglist[4]
            temp.floor.coords[9] +:= userarglist[5]
            temp.floor.coords[10] +:= userarglist[3]
            temp.floor.coords[11] +:= userarglist[4]
            temp.floor.coords[12] +:= userarglist[5]
            temp.ceiling.coords[1] +:= userarglist[3]
            temp.ceiling.coords[2] +:= userarglist[4]
            temp.ceiling.coords[3] +:= userarglist[5]
            temp.ceiling.coords[4] +:= userarglist[3]
            temp.ceiling.coords[5] +:= userarglist[4]
            temp.ceiling.coords[6] +:= userarglist[5]
            temp.ceiling.coords[7] +:= userarglist[3]
            temp.ceiling.coords[8] +:= userarglist[4]
            temp.ceiling.coords[9] +:= userarglist[5]
            temp.ceiling.coords[10] +:= userarglist[3]
            temp.ceiling.coords[11] +:= userarglist[4]
            temp.ceiling.coords[12] +:= userarglist[5]
            every tempWall := !temp.walls do
            {
               tempWall.coords[1] +:= userarglist[3]
               tempWall.coords[2] +:= userarglist[4]
               tempWall.coords[3] +:= userarglist[5]
               tempWall.coords[4] +:= userarglist[3]
               tempWall.coords[5] +:= userarglist[4]
               tempWall.coords[6] +:= userarglist[5]
               tempWall.coords[7] +:= userarglist[3]
               tempWall.coords[8] +:= userarglist[4]
               tempWall.coords[9] +:= userarglist[5]
               tempWall.coords[10] +:= userarglist[3]
               tempWall.coords[11] +:= userarglist[4]
               tempWall.coords[12] +:= userarglist[5]
            }
            temp.x +:= userarglist[3]
            temp.y +:= userarglist[4]
            temp.z +:= userarglist[5]
#            newList := []
#            while tExit := pop(temp.exits) do {
#               if (find("Portal", type(tExit))) & (tExit.rooms[1].name === temp.name) then {
#                  tExit.x1 +:= userarglist[3]
#                  tExit.y1 +:= userarglist[4]
#                  tExit.z1 +:= userarglist[5]
#                  push(newList, tExit)
#                  tExit.rooms[1] := temp
#	       }
#               else if (find("Portal", type(tExit))) & (tExit.rooms[2].name === temp.name) then {
#                  tExit.x2 +:= userarglist[3]
#                  tExit.y2 +:= userarglist[4]
#                  tExit.z2 +:= userarglist[5]
#                  push(newList, tExit)
#                  tExit.rooms[2] := temp
#	       }
#               else if tExit.rooms[1].name === temp.name then {
#                  port := Portal(tExit.opMode, tExit.world, tExit.dispatcher, tExit.x, tExit.y, tExit.z,
#                                 tExit.x + userarglist[3], tExit.y + userarglist[4],
#                                 tExit.z + userarglist[5], tExit.collide, tExit.width,
#                                 tExit.height)
#                  port.plane := tExit.plane
#                  port.id := tExit.id
#                  port.rooms := temp.rooms
#                  WcveBuilder.sceneGraph.edgesTable["edge"||tExit.id] := port
#                  push(newList, tExit)
#                  tExit.rooms[1] := temp
#	       }
#               else {
#                  port := Portal(tExit.opMode, tExit.world, tExit.dispatcher, tExit.x + userarglist[3], 
#                                 tExit.y + userarglist[4], tExit.z + userarglist[5],
#                                 tExit.x, tExit.y, tExit.z, tExit.collide, tExit.width,
#                                 tExit.height)
#                  port.plane := tExit.plane
#                  port.id := tExit.id
#                  port.rooms := temp.rooms
#                  WcveBuilder.sceneGraph.edgesTable["edge"||tExit.id] := port
#                  push(newList, tExit)
#                  tExit.rooms[2] := temp
#	       }
#            }
#            temp.exits := newList
            temp.UpdateRenderedNode()
         }
         "check": {
            write("x=", temp.x || "|maxx=" || image(temp.maxx) || "|minx=" || image(temp.minx))
            write("y=", temp.y || "|maxy=" || image(temp.maxy) || "|miny=" || image(temp.miny))
            write("z=", temp.z || "|maxa=" || image(temp.maxz) || "|minz=" || image(temp.minz))
            write("w=", temp.w)
            write("h=", temp.h)
            write("l=", temp.l)
            temp := WcveBuilder.sceneGraph.nodesTable[userarglist[1]]
            write("Ceiling")
            every i := 1 to *temp.ceiling.coords by 3 do 
               writes("(" || temp.ceiling.coords[i] || ", " || 
                      temp.ceiling.coords[i+1] || ", " || 
                      temp.ceiling.coords[i+2] || ") ")
            write("")
            write("Floor")
            every i := 1 to *temp.floor.coords by 3 do 
               writes("(" || temp.floor.coords[i] || ", " || 
                      temp.floor.coords[i+1] || ", " || 
                      temp.floor.coords[i+2] || ") ")
            write("")
            every tempWall := !temp.walls do
            {
               write("Wall")
               every i := 1 to *tempWall.coords by 3 do 
                  writes("(" || tempWall.coords[i] || ", " || 
                         tempWall.coords[i+1] || ", " || 
                         tempWall.coords[i+2] || ") ")
               write("")
            }
         }
      }
      temp.render()
      WcveBuilder.sceneGraph.nodesTable[userarglist[1]] := temp
      WcveBuilder.sceneGraph.nodesTable[userarglist[1]].calc_boundbox()
end

#used in the save room function, ConvertTwo takes a part of a room and parses out the data that
#is to be saved. 
#tot is the part of the room that is being passed in. These can be walls, boxes, or any other
#part of a room.
#ftwo is the file that the room is being sent to. This will be an open .dat file.
procedure ConvertTwo(tot, ftwo)
   local tempWall
   if find("Box", type(tot)) then {
      write(ftwo, "\t\tBox {")
      every tempWall := !tot.walls do {
         write(ftwo, "\t\t\tWall {")
         if \tempWall.texture then write(ftwo, "\t\t\t\ttexture ", tempWall.texture)
         write(ftwo, "\t\t\t\tcoords [")
         write(ftwo, "\t\t\t\t\t", tempWall.coords[1], ", ", tempWall.coords[2], ", ", tempWall.coords[3], ",")
         write(ftwo, "\t\t\t\t\t", tempWall.coords[4], ", ", tempWall.coords[5], ", ", tempWall.coords[6], ",")
         write(ftwo, "\t\t\t\t\t", tempWall.coords[7], ", ", tempWall.coords[8], ", ", tempWall.coords[9], ",")
         write(ftwo, "\t\t\t\t\t", tempWall.coords[10], ", ", tempWall.coords[11], ", ", tempWall.coords[12])
         write(ftwo, "\t\t\t\t]")
         write(ftwo, "\t\t\t}")
      }
      write(ftwo, "\t\t}")
   }
   if find("Wall", type(tot)) then {
      write(ftwo, "\t\tWall {")
      write(ftwo, "\t\t\ttexture ", tot.texture)
      write(ftwo, "\t\t\tcoords [")
      write(ftwo, "\t\t\t\t", tot.coords[1], ", ", tot.coords[2], ", ", tot.coords[3], ",")
      write(ftwo, "\t\t\t\t", tot.coords[4], ", ", tot.coords[5], ", ", tot.coords[6], ",")
      write(ftwo, "\t\t\t\t", tot.coords[7], ", ", tot.coords[8], ", ", tot.coords[9], ",")
      write(ftwo, "\t\t\t\t", tot.coords[10], ", ", tot.coords[11], ", ", tot.coords[12])
      write(ftwo, "\t\t\t]")
      write(ftwo, "\t\t}")
   }
   if find("WhiteBoard", type(tot)) then {
   }
   if find("Windowblinds", type(tot)) then {
      write(ftwo, "\t\tWindowblinds {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tangle ", tot.angle)
      write(ftwo, "\t\t\tcrod ", tot.color_rod)
      write(ftwo, "\t\t\tcblinds ", tot.color_blinds)
      write(ftwo, "\t\t\theight ", tot.height)
      write(ftwo, "\t\t\twidth ", tot.width)
      write(ftwo, "\t\t}")           
   }
   if find("Chair", type(tot)) then {
      write(ftwo, "\t\tChair {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tposition ", tot.position_cube)
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t\ttype ", tot.type)
      write(ftwo, "\t\t\tmovable ", tot.movable)
      write(ftwo, "\t\t}")
   }
   if find("Table", type(tot)) then {
      write(ftwo, "\t\tTable {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tposition ", tot.angle)
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t\ttype ", tot.type)
      write(ftwo, "\t\t}")
   }
   if find("Pen", type(tot)) then {
      write(ftwo, "\t\tPen {")
      write(ftwo, "\t\t\tId ", tot.Id)
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t\tAngle ", tot.origYangle)
      write(ftwo, "\t\t}")
   }
   if find("Book", type(tot)) then {
      write(ftwo, "\t\tBook {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t\tAngle ", tot.type)
      write(ftwo, "\t\t}")
   }
   if find("Computer", type(tot)) then {
      write(ftwo, "\t\tComputer {")
      write(ftwo, "\t\t\tcoords_mntr [", tot.x_mntr, ", ", tot.y_mntr, ", ", tot.z_mntr, "]")
      write(ftwo, "\t\t\tcoords_cpu [", tot.x_cpu, ", ", tot.y_cpu, ", ", tot.z_cpu, "]")
      write(ftwo, "\t\t\tcoords_kb [", tot.x_kb, ", ", tot.y_kb, ", ", tot.z_kb, "]")
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t\tangle ", tot.angle)
      write(ftwo, "\t\t}")           
   }
   if find("Printer", type(tot)) then {
      write(ftwo, "\t\tPrinter {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tangle ", tot.angle)
      write(ftwo, "\t\t\tcolor ", tot.color)
      write(ftwo, "\t\t}")
   }
   if find("Ramp", type(tot)) then {
      write(ftwo, "\t\tRamp {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tcolor ", tot.color_ramp)
      write(ftwo, "\t\t\ttexture ", tot.toptexture)
      write(ftwo, "\t\t\ttype ", tot.type)
      write(ftwo, "\t\t\twidth ", tot.width)
      write(ftwo, "\t\t\theight ", tot.height)
      write(ftwo, "\t\t\tlength ", tot.length)
      write(ftwo, "\t\t\tnumsteps ", tot.numsteps)
      write(ftwo, "\t\t}")           
   }
   if find("Object3D", type(tot)) then {
      write(ftwo, "\t\tObject3D {")
      write(ftwo, "\t\t\tcoords [", tot.x, ", ", tot.y, ", ", tot.z, "]")
      write(ftwo, "\t\t\tposition ", tot.angle)
      write(ftwo, "\t\t\tscale [", tot.scalex, ", ", tot.scaley, ", ", tot.scalez, "]")
      write(ftwo, "\t\t\tmodel3d ", tot.model3d_filename)
      write(ftwo, "\t\t}")
   }
end

### Ivib-v2 layout ##
#class|Canvas|17|Name Table|table|integer|0|84|string|CurrentActiveRoom
#_list|integer|1|string|CurrentRoom_label|integer|1|string|Dial_btn|int
#eger|1|string|Local_Off_btn|integer|1|string|Off_btn|integer|1|string|
#VoiceDisabled_btn|integer|2|string|border|integer|16|string|chat_outpu
#t|integer|1|string|check_box|integer|4|string|check_box_group|integer|
#1|string|class_btn|integer|1|string|copy_btn|integer|1|string|coursesl
#ist|integer|1|string|custom|integer|6|string|cut_btn|integer|1|string|
#delete_btn|integer|1|string|edit_list|integer|1|string|editable_text_l
#ist|integer|5|string|find_btn|integer|1|string|htoolbar|integer|1|stri
#ng|icon|integer|5|string|icon_button|integer|12|string|image|integer|6
#|string|label|integer|27|string|line|integer|4|string|list|integer|3|s
#tring|makeexe_btn|integer|1|string|menu|integer|19|string|menu_bar|int
#eger|2|string|menu_button|integer|3|string|menu_separator|integer|1|st
#ring|method_btn|integer|1|string|new_btn|integer|2|string|on_Dial_btn|
#integer|1|string|on_Off_btn|integer|1|string|on_class_btn|integer|1|st
#ring|on_copy_btn|integer|1|string|on_courselist|integer|1|string|on_cu
#t_btn|integer|1|string|on_delete_btn|integer|1|string|on_find_btn|inte
#ger|1|string|on_makeexe_btn|integer|1|string|on_method_btn|integer|1|s
#tring|on_new_btn|integer|2|string|on_open_btn|integer|1|string|on_past
#e_btn|integer|4|string|on_phone_btn|integer|1|string|on_procedure_btn|
#integer|1|string|on_run_btn|integer|1|string|on_save_btn|integer|1|str
#ing|on_saveas_btn|integer|1|string|on_sound_btn|integer|2|string|on_un
#do_btn|integer|1|string|on_username|integer|1|string|on_viewall_btn|in
#teger|9|string|on_viewfiles_btn|integer|1|string|on_viewfilesmsgs_btn|
#integer|1|string|open_btn|integer|1|string|overlay_item|integer|4|stri
#ng|overlay_set|integer|2|string|panel|integer|4|string|paste_btn|integ
#er|4|string|phone_btn|integer|1|string|procedure_btn|integer|1|string|
#run_btn|integer|1|string|save_btn|integer|1|string|saveas_btn|integer|
#1|string|sizer|integer|1|string|sound_btn|integer|2|string|tab_item|in
#teger|17|string|tab_set|integer|5|string|table|integer|1|string|text_b
#utton|integer|36|string|text_field|integer|2|string|text_list|integer|
#11|string|text_menu_item|integer|45|string|toolbox|integer|2|string|tr
#ee|integer|8|string|undo_btn|integer|1|string|username|integer|1|strin
#g|users_label|integer|2|string|viewall_btn|integer|9|string|viewfiles_
#btn|integer|1|string|viewfilesmsgs_btn|integer|1|SuperClass Name|strin
#g|Dialog|Import Name|string|gui|Button Groups|class|ButtonGroupSet|2|P
#arent Canvas|1|Boxes|list|0|Checkbox Groups|class|CheckBoxGroupSet|2|P
#arent Canvas|1|Boxes|list|1|class|CanvasCheckBoxGroup|6|Name|string|ch
#eck_box_group_1|Number|integer|1|Class Name|string|CheckBoxGroup|Impor
#t Name|string|gui|Class Variable|integer|1|Which One|null|Gen Indent|i
#nteger|2|Gen Main|integer|1|Gen Component Setup|integer|1|Gen Init Dia
#log|integer|1|Gen Initially|integer|1|Dialog Struct|class|CDialog|4|Mi
#n Width|integer|700|Min Height|integer|515|Ticker Rate|null|Attribs|li
#st|3|string|resize=on|string|label=CVE|string|bg=very light whitish gr
#ay|Name|string|NSHDialog|Width|integer|950|Height|integer|700|Items|li
#st|7|class|CanvasBorder|28|Parent Canvas|1|Name|string|chatarea|Class 
#Name|string|Border|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|
#null|H Fix|null|W Default|null|H Default|null|X Spec|string|23%|Y Spec
#|string|75%|W Spec|string|77%-2|H Spec|string|25%-4|X Align|string|l|Y
# Align|string|t|Is shaded|null|Is Button Subclass|null|Draw Border|nul
#l|Attribs|list|1|string|resize=on|Tooltip|null|Accel|null|Event Handle
#rs|list|0|Class Variable|integer|1|Parent Component|1|Internal Alignme
#nt|string|l|Children|list|3|class|CanvasTextField|27|Parent Canvas|1|N
#ame|string|chat_input|Class Name|string|TextField|Import Name|string|g
#ui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Defaul
#t|null|X Spec|string|2|Y Spec|string|80%+4|W Spec|string|100%-4|H Spec
#|string|20%-4|X Align|string|l|Y Align|string|t|Is shaded|null|Is Butt
#on Subclass|null|Draw Border|integer|1|Attribs|list|2|string|bg=very l
#ight whitish green|string|resize=on|Tooltip|null|Accel|null|Event Hand
#lers|list|1|list|2|string|ACTION_EVENT|string|on_chat|Class Variable|i
#nteger|1|Parent Component|11|Contents|string||Filter String|string||cl
#ass|CanvasTextList|29|Parent Canvas|1|Name|string|chat_output|Class Na
#me|string|TextList|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|
#null|H Fix|null|W Default|null|H Default|null|X Spec|string|60%+2|Y Sp
#ec|string|2|W Spec|string|40%-2|H Spec|string|80%-4|X Align|string|l|Y
# Align|string|t|Is shaded|null|Is Button Subclass|null|Draw Border|int
#eger|1|Attribs|list|2|string|bg=very light whitish yellow|string|resiz
#e=on|Tooltip|null|Accel|null|Event Handlers|list|0|Class Variable|inte
#ger|1|Parent Component|11|Select One|null|Select Many|null|Checked|lis
#t|1|null|Contents|list|1|string||class|CanvasTextList|29|Parent Canvas
#|1|Name|string|user_chat_output|Class Name|string|TextList|Import Name
#|string|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null
#|H Default|null|X Spec|string|2|Y Spec|string|2|W Spec|string|60%-2|H 
#Spec|string|80%-4|X Align|string|l|Y Align|string|t|Is shaded|null|Is 
#Button Subclass|null|Draw Border|integer|1|Attribs|list|2|string|bg=ve
#ry light whitish yellow|string|resize=on|Tooltip|null|Accel|null|Event
# Handlers|list|0|Class Variable|integer|1|Parent Component|11|Select O
#ne|null|Select Many|null|Checked|list|1|null|Contents|list|1|string||T
#itle Obj|null|class|CanvasBorder|28|Parent Canvas|1|Name|string|browse
#r|Class Name|string|Border|Import Name|string|gui|X Fix|null|Y Fix|nul
#l|W Fix|null|H Fix|null|W Default|null|H Default|null|X Spec|string|0|
#Y Spec|string|4%|W Spec|string|23%|H Spec|string|71%-4|X Align|string|
#l|Y Align|string|t|Is shaded|null|Is Button Subclass|null|Draw Border|
#null|Attribs|list|1|string|resize=on|Tooltip|null|Accel|null|Event Han
#dlers|list|0|Class Variable|integer|1|Parent Component|1|Internal Alig
#nment|string|l|Children|list|1|class|CanvasTabSet|27|Parent Canvas|1|N
#ame|string|ClassTabSet|Class Name|string|BufferTabSet|Import Name|stri
#ng|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H De
#fault|null|X Spec|string|2|Y Spec|string|2|W Spec|string|100%-4|H Spec
#|string|100%-4|X Align|string|l|Y Align|string|t|Is shaded|null|Is But
#ton Subclass|null|Draw Border|null|Attribs|list|2|string|font=serif,17
#|string|fg=#630000|Tooltip|null|Accel|null|Event Handlers|list|1|list|
#2|string|ACTION_EVENT|string|on_ClassTabSet|Class Variable|integer|1|P
#arent Component|29|Children|list|4|class|CanvasTabItem|28|Parent Canva
#s|1|Name|string|class_browser_tab_item|Class Name|string|TabItem|Impor
#t Name|string|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Defaul
#t|null|H Default|null|X Spec|integer|0|Y Spec|integer|0|W Spec|string|
#100%|H Spec|string|100%|X Align|string|l|Y Align|string|t|Is shaded|nu
#ll|Is Button Subclass|null|Draw Border|null|Attribs|list|0|Tooltip|nul
#l|Accel|null|Event Handlers|null|Class Variable|null|Parent Component|
#33|Label|string|Class Browser|Parent TabSet|33|Children|list|1|class|C
#anvasTree|29|Parent Canvas|1|Name|string|FileBrowser|Class Name|string
#|ClassBrowser|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|null|
#H Fix|null|W Default|null|H Default|null|X Spec|string|2%|Y Spec|strin
#g|8%|W Spec|string|96%|H Spec|string|90%|X Align|string|l|Y Align|stri
#ng|t|Is shaded|null|Is Button Subclass|null|Draw Border|integer|1|Attr
#ibs|list|2|string|bg=white|string|font=serif,15|Tooltip|null|Accel|nul
#l|Event Handlers|list|1|list|2|string|SELECTION_CHANGED_EVENT|string|o
#n_filebrowser_click|Class Variable|integer|1|Parent Component|38|Selec
#t One|integer|1|Select Many|null|Show Root Handles|integer|1|Show Root
#|integer|1|class|CanvasTabItem|28|Parent Canvas|1|Name|string|users_ta
#b_item|Class Name|string|TabItem|Import Name|string|gui|X Fix|null|Y F
#ix|null|W Fix|null|H Fix|null|W Default|null|H Default|null|X Spec|int
#eger|0|Y Spec|integer|0|W Spec|string|100%|H Spec|string|100%|X Align|
#string|l|Y Align|string|t|Is shaded|null|Is Button Subclass|null|Draw 
#Border|null|Attribs|list|0|Tooltip|null|Accel|null|Event Handlers|null
#|Class Variable|null|Parent Component|33|Label|string|Activity|Parent 
#TabSet|33|Children|list|8|class|CanvasTextList|29|Parent Canvas|1|Name
#|string|usersDisplayList|Class Name|string|TextList|Import Name|string
#|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Defa
#ult|null|X Spec|integer|141|Y Spec|integer|233|W Spec|string|46|H Spec
#|string|52|X Align|string|l|Y Align|string|t|Is shaded|integer|1|Is Bu
#tton Subclass|null|Draw Border|integer|1|Attribs|list|1|string|bg=whit
#e|Tooltip|null|Accel|null|Event Handlers|list|0|Class Variable|integer
#|1|Parent Component|45|Select One|integer|1|Select Many|null|Checked|l
#ist|1|null|Contents|list|1|string||class|CanvasTextButton|36|Parent Ca
#nvas|1|Name|string|user_invitation_btn|Class Name|string|TextButton|Im
#port Name|string|gui|X Fix|null|Y Fix|null|W Fix|integer|1|H Fix|integ
#er|1|W Default|null|H Default|null|X Spec|string|33|Y Spec|string|220|
#W Spec|string|45%|H Spec|string|6%|X Align|string|l|Y Align|string|t|I
#s shaded|integer|1|Is Button Subclass|integer|1|Draw Border|null|Attri
#bs|list|0|Tooltip|null|Accel|null|Event Handlers|list|1|list|2|string|
#ACTION_EVENT|string|on_user_invitation_btn|Class Variable|integer|1|Pa
#rent Component|45|Label|string|Invite User|No Keyboard|null|Img Up|nul
#l|Img Down|null|Img Width|null|Img Height|null|Is Checked Flag|null|Is
# Checkbox Flag|null|Parent CheckBoxGroup|null|Parent Button Group|null
#|Internal Align|string|c|class|CanvasTree|29|Parent Canvas|1|Name|stri
#ng|ide_session_tree|Class Name|string|Tree|Import Name|string|gui|X Fi
#x|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Default|null|
#X Spec|string|2%|Y Spec|string|5%|W Spec|string|96%|H Spec|string|26%|
#X Align|string|l|Y Align|string|t|Is shaded|null|Is Button Subclass|nu
#ll|Draw Border|integer|1|Attribs|list|1|string|bg=white|Tooltip|null|A
#ccel|null|Event Handlers|list|1|list|2|string|MOUSE_RELEASE_EVENT|stri
#ng|on_ide_session_tree|Class Variable|integer|1|Parent Component|45|Se
#lect One|integer|1|Select Many|null|Show Root Handles|integer|1|Show R
#oot|integer|1|class|CanvasTextButton|36|Parent Canvas|1|Name|string|ex
#it_session_btn|Class Name|string|TextButton|Import Name|string|gui|X F
#ix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Default|null
#|X Spec|string|36|Y Spec|string|246|W Spec|string|45%|H Spec|string|6%
#|X Align|string|l|Y Align|string|t|Is shaded|integer|1|Is Button Subcl
#ass|integer|1|Draw Border|null|Attribs|list|0|Tooltip|null|Accel|null|
#Event Handlers|list|1|list|2|string|ACTION_EVENT|string|on_exit_sessio
#n_btn|Class Variable|integer|1|Parent Component|45|Label|string|Exit S
#ession|No Keyboard|null|Img Up|null|Img Down|null|Img Width|null|Img H
#eight|null|Is Checked Flag|null|Is Checkbox Flag|null|Parent CheckBoxG
#roup|null|Parent Button Group|null|Internal Align|string|c|class|Canva
#sTextButton|36|Parent Canvas|1|Name|string|get_lock_btn|Class Name|str
#ing|TextButton|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|null
#|H Fix|null|W Default|null|H Default|null|X Spec|string|37|Y Spec|stri
#ng|273|W Spec|string|45%|H Spec|string|6%|X Align|string|l|Y Align|str
#ing|t|Is shaded|integer|1|Is Button Subclass|integer|1|Draw Border|nul
#l|Attribs|list|0|Tooltip|null|Accel|null|Event Handlers|list|1|list|2|
#string|ACTION_EVENT|string|on_get_lock_btn|Class Variable|integer|1|Pa
#rent Component|45|Label|string|Take Turn|No Keyboard|null|Img Up|null|
#Img Down|null|Img Width|null|Img Height|null|Is Checked Flag|null|Is C
#heckbox Flag|null|Parent CheckBoxGroup|null|Parent Button Group|null|I
#nternal Align|string|c|class|CanvasLabel|27|Parent Canvas|1|Name|strin
#g|files_label|Class Name|string|Label|Import Name|string|gui|X Fix|nul
#l|Y Fix|null|W Fix|null|H Fix|null|W Default|integer|1|H Default|null|
#X Spec|string|2%|Y Spec|string|0|W Spec|integer|51|H Spec|string|4%|X 
#Align|string|l|Y Align|string|t|Is shaded|null|Is Button Subclass|null
#|Draw Border|null|Attribs|list|2|string|font=serif, bold, 12|string|bg
#=very light whitish blue|Tooltip|null|Accel|null|Event Handlers|list|0
#|Class Variable|integer|1|Parent Component|45|Label|string|Session Fil
#es|Internal Align|string|l|class|CanvasTextButton|36|Parent Canvas|1|N
#ame|string|pendings_btn|Class Name|string|TextButton|Import Name|strin
#g|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Def
#ault|null|X Spec|string|41|Y Spec|string|249|W Spec|string|84|H Spec|s
#tring|20|X Align|string|l|Y Align|string|t|Is shaded|integer|1|Is Butt
#on Subclass|integer|1|Draw Border|null|Attribs|list|0|Tooltip|null|Acc
#el|null|Event Handlers|list|1|list|2|string|ACTION_EVENT|string|on_pen
#dings_btn|Class Variable|integer|1|Parent Component|45|Label|string|Pe
#ndings(0)|No Keyboard|null|Img Up|null|Img Down|null|Img Width|null|Im
#g Height|null|Is Checked Flag|null|Is Checkbox Flag|null|Parent CheckB
#oxGroup|null|Parent Button Group|null|Internal Align|string|c|class|Ca
#nvasTabSet|27|Parent Canvas|1|Name|string|activity_mini_tabset|Class N
#ame|string|TabSet|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|n
#ull|H Fix|null|W Default|null|H Default|null|X Spec|string|2|Y Spec|st
#ring|31%|W Spec|string|100%-4|H Spec|string|68%|X Align|string|l|Y Ali
#gn|string|t|Is shaded|null|Is Button Subclass|null|Draw Border|null|At
#tribs|list|0|Tooltip|null|Accel|null|Event Handlers|list|0|Class Varia
#ble|integer|1|Parent Component|45|Children|list|3|class|CanvasTabItem|
#28|Parent Canvas|1|Name|string|mini_users_tab|Class Name|string|TabIte
#m|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W
# Default|null|H Default|null|X Spec|integer|0|Y Spec|integer|0|W Spec|
#string|100%|H Spec|string|100%|X Align|string|l|Y Align|string|t|Is sh
#aded|null|Is Button Subclass|null|Draw Border|null|Attribs|list|0|Tool
#tip|null|Accel|null|Event Handlers|null|Class Variable|integer|1|Paren
#t Component|76|Label|string|Users|Parent TabSet|76|Children|list|2|cla
#ss|CanvasCheckBox|35|Parent Canvas|1|Name|string|showonline_chkbx|Clas
#s Name|string|CheckBox|Import Name|string|gui|X Fix|null|Y Fix|null|W 
#Fix|null|H Fix|null|W Default|null|H Default|null|X Spec|string|2|Y Sp
#ec|string|0|W Spec|string|70%|H Spec|string|6%|X Align|string|l|Y Alig
#n|string|t|Is shaded|null|Is Button Subclass|integer|1|Draw Border|int
#eger|1|Attribs|list|2|string|font=serif, bold, 12|string|bg=very light
# whitish blue|Tooltip|null|Accel|null|Event Handlers|list|1|list|2|str
#ing|ACTION_EVENT|string|on_showonline_chkbx|Class Variable|integer|1|P
#arent Component|80|Label|string|Show Offline friends|No Keyboard|null|
#Img Up|string|(0=shadow;1=hilite;~=trans)13,c6,~~~~~~~~~~~~~~111111111
#11~~11111111110~~11~~~~~~~00~~11~~~~~~~00~~11~~~~~~~00~~11~~~~~~~00~~1
#1~~~~~~~00~~11~~~~~~~00~~11~~~~~~~00~~11000000000~~10000000000~~~~~~~~
#~~~~~~|Img Down|string|(b=black;0=shadow;1=hilite;~=trans)13,c6,~~~~~~
#~~~~~~~~00000000001~~00000000001~~00~~~~~~~11~~00~bbbbb~11~~00~bbbbb~1
#1~~00~bbbbb~11~~00~bbbbb~11~~00~bbbbb~11~~00~~~~~~~11~~01111111111~~11
#111111111~~~~~~~~~~~~~~|Img Width|integer|13|Img Height|integer|13|Is 
#Checked Flag|null|Is Checkbox Flag|integer|1|Parent CheckBoxGroup|null
#|Parent Button Group|null|class|CanvasTree|29|Parent Canvas|1|Name|str
#ing|users_tree|Class Name|string|Tree|Import Name|string|gui|X Fix|nul
#l|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Default|null|X Spe
#c|integer|1|Y Spec|integer|17|W Spec|string|100%-2|H Spec|string|100%-
#18|X Align|string|l|Y Align|string|t|Is shaded|null|Is Button Subclass
#|null|Draw Border|integer|1|Attribs|list|1|string|bg=white|Tooltip|nul
#l|Accel|null|Event Handlers|list|1|list|2|string|MOUSE_RELEASE_EVENT|s
#tring|on_users_tree|Class Variable|integer|1|Parent Component|80|Selec
#t One|integer|1|Select Many|null|Show Root Handles|integer|1|Show Root
#|integer|1|class|CanvasTabItem|28|Parent Canvas|1|Name|string|mini_gro
#ups_tab|Class Name|string|TabItem|Import Name|string|gui|X Fix|null|Y 
#Fix|null|W Fix|null|H Fix|null|W Default|null|H Default|null|X Spec|in
#teger|0|Y Spec|integer|0|W Spec|string|100%|H Spec|string|100%|X Align
#|string|l|Y Align|string|t|Is shaded|null|Is Button Subclass|null|Draw
# Border|null|Attribs|list|0|Tooltip|null|Accel|null|Event Handlers|nul
#l|Class Variable|integer|1|Parent Component|76|Label|string|Groups|Par
#ent TabSet|76|Children|list|1|class|CanvasTree|29|Parent Canvas|1|Name
#|string|groups_tree|Class Name|string|Tree|Import Name|string|gui|X Fi
#x|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Default|null|
#X Spec|string|1|Y Spec|string|1|W Spec|string|100%-2|H Spec|string|100
#%-2|X Align|string|l|Y Align|string|t|Is shaded|null|Is Button Subclas
#s|null|Draw Border|integer|1|Attribs|list|1|string|bg=white|Tooltip|nu
#ll|Accel|null|Event Handlers|list|1|list|2|string|MOUSE_RELEASE_EVENT|
#string|on_groups_tree|Class Variable|integer|1|Parent Component|91|Sel
#ect One|integer|1|Select Many|null|Show Root Handles|integer|1|Show Ro
#ot|integer|1|class|CanvasTabItem|28|Parent Canvas|1|Name|string|mini_p
#rojects_tab|Class Name|string|TabItem|Import Name|string|gui|X Fix|nul
#l|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Default|null|X Spe
#c|integer|0|Y Spec|integer|0|W Spec|string|100%|H Spec|string|100%|X A
#lign|string|l|Y Align|string|t|Is shaded|null|Is Button Subclass|null|
#Draw Border|null|Attribs|list|0|Tooltip|null|Accel|null|Event Handlers
#|null|Class Variable|integer|1|Parent Component|76|Label|string|Projec
#ts|Parent TabSet|76|Children|list|1|class|CanvasTree|29|Parent Canvas|
#1|Name|string|projects_tree|Class Name|string|Tree|Import Name|string|
#gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Defau
#lt|null|X Spec|string|1|Y Spec|string|1|W Spec|string|100%-2|H Spec|st
#ring|100%-2|X Align|string|l|Y Align|string|t|Is shaded|null|Is Button
# Subclass|null|Draw Border|integer|1|Attribs|list|1|string|bg=white|To
#oltip|null|Accel|null|Event Handlers|list|1|list|2|string|MOUSE_RELEAS
#E_EVENT|string|on_projects_tree|Class Variable|integer|1|Parent Compon
#ent|98|Select One|integer|1|Select Many|null|Show Root Handles|integer
#|1|Show Root|integer|1|Which One|80|class|CanvasTabItem|28|Parent Canv
#as|1|Name|string|inventory_tab_item|Class Name|string|TabItem|Import N
#ame|string|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|n
#ull|H Default|null|X Spec|integer|0|Y Spec|integer|0|W Spec|string|100
#%|H Spec|string|100%|X Align|string|l|Y Align|string|t|Is shaded|null|
#Is Button Subclass|null|Draw Border|null|Attribs|list|0|Tooltip|null|A
#ccel|null|Event Handlers|null|Class Variable|integer|1|Parent Componen
#t|33|Label|string|Inventory|Parent TabSet|33|Children|list|2|class|Can
#vasLabel|27|Parent Canvas|1|Name|string|activequestslbl|Class Name|str
#ing|Label|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|null|H Fi
#x|null|W Default|null|H Default|null|X Spec|integer|4|Y Spec|integer|2
#3|W Spec|string|102|H Spec|string|25|X Align|string|l|Y Align|string|t
#|Is shaded|null|Is Button Subclass|null|Draw Border|null|Attribs|list|
#1|string|bg=whitish blue|Tooltip|null|Accel|null|Event Handlers|list|0
#|Class Variable|integer|1|Parent Component|105|Label|string| Active Qu
#ests|Internal Align|string|l|class|CanvasTextList|29|Parent Canvas|1|N
#ame|string|activequeststl|Class Name|string|TextList|Import Name|strin
#g|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Def
#ault|null|X Spec|string|2|Y Spec|string|50|W Spec|string|100%-4|H Spec
#|string|145|X Align|string|l|Y Align|string|t|Is shaded|null|Is Button
# Subclass|null|Draw Border|integer|1|Attribs|list|2|string|bg=pale blu
#e|string|font=serif,bold,15|Tooltip|null|Accel|null|Event Handlers|lis
#t|2|list|2|string|ACTION_EVENT|string|on_activequeststl|list|2|string|
#MOUSE_PRESS_EVENT|string|on_activequeststl|Class Variable|integer|1|Pa
#rent Component|105|Select One|integer|1|Select Many|null|Checked|list|
#1|null|Contents|list|1|string||class|CanvasTabItem|28|Parent Canvas|1|
#Name|string|newsfeed_tab_item|Class Name|string|TabItem|Import Name|st
#ring|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H 
#Default|null|X Spec|integer|0|Y Spec|integer|0|W Spec|string|100%|H Sp
#ec|string|100%|X Align|string|l|Y Align|string|t|Is shaded|null|Is But
#ton Subclass|null|Draw Border|null|Attribs|list|0|Tooltip|null|Accel|n
#ull|Event Handlers|null|Class Variable|integer|1|Parent Component|33|L
#abel|string|News Feed|Parent TabSet|33|Children|list|1|class|CanvasTre
#e|29|Parent Canvas|1|Name|string|newsfeed_tree|Class Name|string|Tree|
#Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W D
#efault|null|H Default|null|X Spec|string|2|Y Spec|string|2|W Spec|stri
#ng|100%-4|H Spec|string|100%-4|X Align|string|l|Y Align|string|t|Is sh
#aded|null|Is Button Subclass|null|Draw Border|integer|1|Attribs|list|1
#|string|bg=white|Tooltip|null|Accel|null|Event Handlers|list|1|list|2|
#string|MOUSE_RELEASE_EVENT|string|on_newsfeed_tree|Class Variable|inte
#ger|1|Parent Component|118|Select One|integer|1|Select Many|null|Show 
#Root Handles|integer|1|Show Root|integer|1|Which One|45|Title Obj|null
#|class|CanvasImage|29|Parent Canvas|1|Name|string|x_button|Class Name|
#string|Image|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|null|H
# Fix|null|W Default|null|H Default|null|X Spec|string|22.8%|Y Spec|str
#ing|75%|W Spec|string|1.1%|H Spec|string|1.45%|X Align|string|l|Y Alig
#n|string|t|Is shaded|null|Is Button Subclass|null|Draw Border|integer|
#1|Attribs|list|0|Tooltip|null|Accel|null|Event Handlers|list|3|list|2|
#string|MOUSE_PRESS_EVENT|string|on_press|list|2|string|MOUSE_DRAG_EVEN
#T|string|on_x|list|2|string|MOUSE_RELEASE_EVENT|string|on_release|Clas
#s Variable|integer|1|Parent Component|1|File name|string|dat/xbtn.gif|
#X Internal Alignment|string|c|Y Internal Alignment|string|c|Scale Up F
#lag|integer|1|class|CanvasImage|29|Parent Canvas|1|Name|string|image_6
#|Class Name|string|Image|Import Name|string|gui|X Fix|null|Y Fix|null|
#W Fix|null|H Fix|null|W Default|null|H Default|null|X Spec|string|82%|
#Y Spec|string|0|W Spec|string|4.5%|H Spec|string|4.5%|X Align|string|c
#|Y Align|string|t|Is shaded|null|Is Button Subclass|null|Draw Border|n
#ull|Attribs|list|2|string|resize=on|string|bg=very medium gray|Tooltip
#|null|Accel|null|Event Handlers|list|0|Class Variable|integer|1|Parent
# Component|1|File name|string|dat/images/cve_80.gif|X Internal Alignme
#nt|string|c|Y Internal Alignment|string|c|Scale Up Flag|integer|1|clas
#s|CanvasImage|29|Parent Canvas|1|Name|string|image_2|Class Name|string
#|Image|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|n
#ull|W Default|null|H Default|null|X Spec|string|97%+6|Y Spec|string|0|
#W Spec|string|4.5%|H Spec|string|4.5%|X Align|string|c|Y Align|string|
#t|Is shaded|null|Is Button Subclass|null|Draw Border|null|Attribs|list
#|2|string|resize=on|string|bg=very medium gray|Tooltip|null|Accel|null
#|Event Handlers|list|0|Class Variable|integer|1|Parent Component|1|Fil
#e name|string|dat/nmsulogo.gif|X Internal Alignment|string|c|Y Interna
#l Alignment|string|c|Scale Up Flag|integer|1|class|CanvasLabel|27|Pare
#nt Canvas|1|Name|string|label_3|Class Name|string|Label|Import Name|st
#ring|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H 
#Default|null|X Spec|string|84.5%|Y Spec|string|0|W Spec|string|11%+6|H
# Spec|string|4.5%|X Align|string|l|Y Align|string|t|Is shaded|null|Is 
#Button Subclass|null|Draw Border|null|Attribs|list|2|string|font=serif
#, bold, italic,12|string|fg=very dark red|Tooltip|null|Accel|null|Even
#t Handlers|list|0|Class Variable|integer|1|Parent Component|1|Label|st
#ring|Computer Science|Internal Align|string|c|class|CanvasBorder|28|Pa
#rent Canvas|1|Name|string|editarea|Class Name|string|Border|Import Nam
#e|string|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|nul
#l|H Default|null|X Spec|string|23%|Y Spec|string|4%|W Spec|string|77%|
#H Spec|string|71%|X Align|string|l|Y Align|string|t|Is shaded|null|Is 
#Button Subclass|null|Draw Border|null|Attribs|list|1|string|resize=on|
#Tooltip|null|Accel|null|Event Handlers|list|0|Class Variable|integer|1
#|Parent Component|1|Internal Alignment|string|l|Children|list|1|class|
#CanvasTabSet|27|Parent Canvas|1|Name|string|VCSC_tab|Class Name|string
#|BufferTabSet|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|null|
#H Fix|null|W Default|null|H Default|null|X Spec|string|1|Y Spec|string
#|1|W Spec|string|100%-2|H Spec|string|100%-2|X Align|string|l|Y Align|
#string|t|Is shaded|null|Is Button Subclass|null|Draw Border|null|Attri
#bs|list|2|string|resize=on|string|font=serif,17|Tooltip|null|Accel|nul
#l|Event Handlers|list|1|list|2|string|SELECTION_CHANGED_EVENT|string|o
#n_tab_selection|Class Variable|integer|1|Parent Component|140|Children
#|list|2|class|CanvasTabItem|28|Parent Canvas|1|Name|string|view_3d|Cla
#ss Name|string|TabItem|Import Name|string|gui|X Fix|null|Y Fix|null|W 
#Fix|null|H Fix|null|W Default|null|H Default|null|X Spec|integer|0|Y S
#pec|integer|0|W Spec|string|100%|H Spec|string|100%|X Align|string|l|Y
# Align|string|t|Is shaded|null|Is Button Subclass|null|Draw Border|nul
#l|Attribs|list|0|Tooltip|null|Accel|null|Event Handlers|null|Class Var
#iable|null|Parent Component|144|Label|string|Science Hall|Parent TabSe
#t|144|Children|list|1|class|CanvasBorder|28|Parent Canvas|1|Name|strin
#g|view_border|Class Name|string|Border|Import Name|string|gui|X Fix|nu
#ll|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Default|null|X Sp
#ec|integer|4|Y Spec|integer|3|W Spec|string|99%|H Spec|string|99%|X Al
#ign|string|l|Y Align|string|t|Is shaded|null|Is Button Subclass|null|D
#raw Border|null|Attribs|list|1|string|resize=on|Tooltip|null|Accel|nul
#l|Event Handlers|list|0|Class Variable|integer|1|Parent Component|149|
#Internal Alignment|string|l|Children|list|1|class|CanvasOverlaySet|27|
#Parent Canvas|1|Name|string|Science_Hall_overlay|Class Name|string|Ove
#rlaySet|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|
#null|W Default|null|H Default|null|X Spec|string|4|Y Spec|string|4|W S
#pec|string|100%-8|H Spec|string|100%-8|X Align|string|l|Y Align|string
#|t|Is shaded|null|Is Button Subclass|null|Draw Border|null|Attribs|lis
#t|0|Tooltip|null|Accel|null|Event Handlers|list|0|Class Variable|integ
#er|1|Parent Component|152|Children|list|1|class|CanvasOverlayItem|27|P
#arent Canvas|1|Name|string|View_3D_overlay_item|Class Name|string|Over
#layItem|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|
#null|W Default|null|H Default|null|X Spec|integer|0|Y Spec|integer|0|W
# Spec|string|100%|H Spec|string|100%|X Align|string|l|Y Align|string|t
#|Is shaded|null|Is Button Subclass|null|Draw Border|null|Attribs|list|
#0|Tooltip|null|Accel|null|Event Handlers|null|Class Variable|null|Pare
#nt Component|156|Children|list|1|class|CanvasBorder|28|Parent Canvas|1
#|Name|string|border_14|Class Name|string|Border|Import Name|string|gui
#|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Default|
#null|X Spec|string|2|Y Spec|string|2|W Spec|string|100%-4|H Spec|strin
#g|100%-4|X Align|string|l|Y Align|string|t|Is shaded|null|Is Button Su
#bclass|null|Draw Border|null|Attribs|list|0|Tooltip|null|Accel|null|Ev
#ent Handlers|list|0|Class Variable|null|Parent Component|160|Internal 
#Alignment|string|l|Children|list|1|class|CanvasCustom|25|Parent Canvas
#|1|Name|string|subwin|Class Name|string|Subwindow3D|Import Name|string
#|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|null|W Default|null|H Defa
#ult|null|X Spec|integer|4|Y Spec|integer|4|W Spec|string|100%-8|H Spec
#|string|100%-8|X Align|string|l|Y Align|string|t|Is shaded|null|Is But
#ton Subclass|null|Draw Border|integer|1|Attribs|list|1|string|resize=o
#n|Tooltip|null|Accel|null|Event Handlers|list|4|list|2|string|ACTION_E
#VENT|string|on_subwin|list|2|string|BUTTON_RELEASE_EVENT|string|on_br|
#list|2|string|MOUSE_RELEASE_EVENT|string|on_mr|list|2|string|KEY_PRESS
#_EVENT|string|on_kp|Class Variable|integer|1|Parent Component|163|Titl
#e Obj|null|Parent OverlaySet|156|Which One|160|Title Obj|null|class|Ca
#nvasTabItem|28|Parent Canvas|1|Name|string|view_map|Class Name|string|
#TabItem|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|null|H Fix|
#null|W Default|null|H Default|null|X Spec|integer|0|Y Spec|integer|0|W
# Spec|string|100%|H Spec|string|100%|X Align|string|l|Y Align|string|t
#|Is shaded|null|Is Button Subclass|null|Draw Border|null|Attribs|list|
#0|Tooltip|null|Accel|null|Event Handlers|null|Class Variable|integer|1
#|Parent Component|144|Label|string|Map|Parent TabSet|144|Children|list
#|1|class|CanvasImage|29|Parent Canvas|1|Name|string|image_5|Class Name
#|string|MapImage|Import Name|string|gui|X Fix|null|Y Fix|null|W Fix|nu
#ll|H Fix|null|W Default|null|H Default|null|X Spec|string|2%|Y Spec|st
#ring|2%|W Spec|string|96%|H Spec|string|96%|X Align|string|l|Y Align|s
#tring|t|Is shaded|null|Is Button Subclass|null|Draw Border|null|Attrib
#s|list|0|Tooltip|null|Accel|null|Event Handlers|list|0|Class Variable|
#integer|1|Parent Component|174|File name|string|dat/images/map.gif|X I
#nternal Alignment|string|c|Y Internal Alignment|string|c|Scale Up Flag
#|integer|1|Which One|149|Title Obj|null|Initial Focus|null|Event Handl
#ers|list|1|list|2|string|CLOSE_BUTTON_EVENT|string|on_close|
